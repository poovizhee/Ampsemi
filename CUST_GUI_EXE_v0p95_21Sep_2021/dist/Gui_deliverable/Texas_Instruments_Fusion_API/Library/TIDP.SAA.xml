<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TIDP.SAA</name>
    </assembly>
    <members>
        <member name="T:TIDP.SAA.IAdapterDriver">
            <summary>
            Base interface for a communications adapter driver supported by the Fusion toolset.
            </summary>
            <remarks>
            Note that you also must implement Dispose() via the IDisposable base
            interface. This will be called when Discover() is called a second time
            and we first Dispose() of any existing drivers. 
            </remarks>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriver.Get_Version(System.Version@)">
            <summary>
            Return the adapter version. Preference is to return the hardware 
            or firmware version of the adapter. If this is not available, return the 
            software driver version. This is only generally called once and is then cached by 
            SMBusAdapter. If there was an error fetching the version from your adapter,
            return SAAStatus.InvalidResponse.
            </summary>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriver.Is_Feature_Supported(TIDP.SAA.SAAFeature)">
            <summary>
            Provides a way for SMBusAdapter and others to query whether a particular optional 
            feature is available.
            </summary>
        </member>
        <member name="P:TIDP.SAA.IAdapterDriver.Short_Name">
            <summary>
            A short name for the device in general. For example, USB-TO-GPIO driver
            currently returns "USB-TO-GPIO".
            </summary>
        </member>
        <member name="P:TIDP.SAA.IAdapterDriver.Long_Name">
            <summary>
            A long name for the discovered adapter. It should be unique for each
            adapter if multiple adapters on the device are supported. For example, USB-TO-GPIO driver
            currently returns something like "USB-TO-GPIO \\?\hid#vid_0451&amp;pid_5f00#6&amp;309601ea&amp;0&amp;0000#{4d1e55b2-f16f-11cf-88cb-001111000030}",
            which contains the USB-HID identifier of the adapter.
            </summary>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriverFactory.Discover">
            <summary>
            Looks for adapters present on the PC that are supported. Creates an
            IAdapterDriver for each adapter found. The implementation must allow 
            this to be called multiple times in the case of initial failure or to 
            rescan for hardware change. Return an empty list if no adapters were found. 
            </summary>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriverExtras.Set_Parallel_Mode(System.Boolean)">
            <summary>
            Enable/disable parallel mode for I2C communication. This mode
            is supported by select UCD92xx controllers. Support for this is optional. Return 
            SAAStatus.UnsupportedFeature if you do not support parallel mode. If
            your driver does support parallel mode, return SAAStatus.Success if you
            could enable parallel mode.
            </summary>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriverExtras.Set_Pull_Ups(TIDP.SAA.SMBusAdapter.PullupValues)">
            <summary>
            Set the pullup resistors for CLOCK, DATA, and SMBALERT#. This is very focused
            on USB-TO-GPIO. Optional. Return SAAStatus.UnsupportedFeature if you do not support
            pullups or have some other way of setting (for example, because your driver has
            different pullup resistor values).
            </summary>
        </member>
        <member name="M:TIDP.SAA.IAdapterDriverExtras.GPIO_Read_Write(System.Byte,System.Byte,System.Byte@)">
            <summary>
            Read/write GPIOs. This is very focused on USB-TO-GPIO. Optional. Return 
            SAAStatus.UnsupportedFeature if you do not support
            </summary>
        </member>
        <member name="P:TIDP.SAA.IAdapterDriverExtras.Is_Attached">
            <summary>
            Return true if the adapter is still attached to PC, false if it is not.
            When false is returned, SMBusAdapter will skip trying to 
            call the driver and instead return SAAStatus.AdapterDetached. This 
            property is also used used when SMBusAdapter.Is_Attached is invoked.
            Return true always if you do not support detection of adapter detach.
            </summary>
        </member>
        <member name="E:TIDP.SAA.IAdapterDriverExtras.AdapterDetached">
            <summary>
            Fire this event when the adapter is detcached from the PC and you can support
            re-attach. Optional. When fired, the SMBusAdapter layer will automatically
            fail any adapter requests.
            </summary>
        </member>
        <member name="E:TIDP.SAA.IAdapterDriverExtras.AdapterReattached">
            <summary>
            Fire when the adapter is re-attached to the PC and the driver can again
            be used. Optional. If you raise AdapterDetached events, be sure to raise
            AdapterReattached events as well.
            </summary>
        </member>
        <member name="P:TIDP.SAA.IAdapterDriverExtras.Adapter">
            <summary>
            The Fusion API will inform the adapter driver what SMBusAdapter it has been
            assigned to if you implement IAdapterDriverOptional. You likely will not
            need the reference to the parent adapter, so your implementation could
            just ignore the assignment.
            </summary>
        </member>
        <member name="T:TIDP.SAA.ISMBusAdapterDriver">
            <summary>
            Defines an interface for a hardware adapter that will process SMBus
            requests. See parent interface, IAdapterDriver, for additional
            members.
            </summary>
            <remarks>
            The SAAStatus status codes indicate success/failure of each request.
            Success should be used to indicate ACK. InvalidResponse should be
            used to indicate NACK. If the physical adapter is not responding after
            Discover() was previously called succesfully, DriverError should be
            returned from a call. If there is a PEC mismatch, InvalidPEC should
            be returned (this is a new enum in SAAStatus).
            <para/>
            PEC byte is never included in data passed into the functions and
            returned from the functions. For writes, address does not include 
            shifting of address to account for I2C write protocol. 
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Receive_Byte(System.Byte,System.Byte@)">
            <summary>
            SMBus receive byte. This is not required for PMBus read/write and
            is not used in Fusion. Implementation is optional: return 
            UnsupportedFeature if not supported.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Read_Byte(System.Byte,System.Byte,System.Byte@)">
            <summary>
            SMBus read byte. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Read_Word(System.Byte,System.Byte,System.Byte@,System.Byte@)">
            <summary>
            SMBus read byte. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Read_Block(System.Byte,System.Byte,System.Byte[]@)">
            <summary>
            SMBus read block. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Send_Byte(System.Byte,System.Byte)">
            <summary>
            SMBus send byte. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Write_Byte(System.Byte,System.Byte,System.Byte)">
            <summary>
            SMBus write byte. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Write_Word(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            SMBus write word. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Write_Block(System.Byte,System.Byte,System.Int32,System.Byte[])">
            <summary>
            SMBus write block. Required.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Process_Call(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte@,System.Byte@)">
            <summary>
            SMBus process call. Optional. Return SAAStatus.UnsupportedFeature if your driver
            does not support.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Block_Write_Block_Read_Process_Call(System.Byte,System.Byte,System.Int32,System.Byte[],System.Byte[]@)">
            <summary>
            SMBus Block write-block read process call. Optional. Return 
            SAAStatus.UnsupportedFeature if your driver does not support.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Set_Bus_Speed(TIDP.SAA.SMBusAdapter.BusSpeed)">
            <summary>
            Sets I2C bus speed (100 kHz or 400 kHZ). Return SAAStatus.UnsupportedFeature
            if your driver does not support the bus speed passed.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Set_PEC_Enabled(System.Boolean)">
            <summary>
            Defines whether PEC byte is sent on SMBus write and verified on SMBus read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Get_SMBusAlert(TIDP.SAA.LogicLevel@)">
            <summary>
            Gets the value of the SMBALERT# line. Return SAAStatus.UnsupportedFeature if 
            your driver does not support SMBALERT#.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Get_Control(System.Int32,TIDP.SAA.LogicLevel@)">
            <summary>
            Gets the value of the specified control line. control_line_number should be 1 to 5.
            Return SAAStatus.UnsupportedFeature if your driver does not support 
            any control lines. Return SAAStatus.InvalidArgument if you do not support the 
            specified control line.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Set_Control(System.Int32,TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Return SAAStatus.UnsupportedFeature if your driver does not support 
            any control lines. Return SAAStatus.InvalidArgument if you do not support the 
            specified control line.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapterDriver.Send_Group_Command(System.Byte[])">
            <summary>
            Send a Group Command Protocol request, as described in the PMBus specification, Part I.
            Optional. Return SAAStatus.UnsupportedFeature if your driver does not support the
            group command protocol. Group command protocol is not generally exposed in Fusion
            Digital Power Designer.
            </summary>
            <remarks>
            This is not technically SMBus, but it seems overkill to create an interface for this single
            method.
            </remarks>
        </member>
        <member name="P:TIDP.SAA.ISMBusAdapterDriver.Num_Control_Lines">
            <summary>
            Returns the number of control lines supported by the driver/adapter. Return 0
            if none are supported.
            </summary>
        </member>
        <member name="M:TIDP.SAA.IReadByteResult.ToString">
            <summary>
            Returns the string version of the Data ("0xAABB", "Low", etc.) 
            or a textual version of the error ("NACK", "SAA DETACHED", etc.).
            </summary>
        </member>
        <member name="M:TIDP.SAA.IReadWordResult.ToString">
            <summary>
            Returns the string version of the Data ("0xAABB", "Low", etc.) 
            or a textual version of the error ("NACK", "SAA DETACHED", etc.).
            </summary>
        </member>
        <member name="M:TIDP.SAA.IReadBlockResult.ToString">
            <summary>
            Returns the string version of the Data ("0xAABB", "Low", etc.) 
            or a textual version of the error ("NACK", "SAA DETACHED", etc.).
            </summary>
        </member>
        <member name="M:TIDP.SAA.IReceiveByteResult.ToString">
            <summary>
            Returns the string version of the Data ("0xAABB", "Low", etc.) 
            or a textual version of the error ("NACK", "SAA DETACHED", etc.).
            </summary>
        </member>
        <member name="T:TIDP.SAA.SAADriverFactory">
            <summary>
            This searches for USB-TO-GPIO adapters on the PC and creates a driver
            instance for each that is found.
            </summary>
        </member>
        <member name="T:TIDP.SAA.TIBusAdapters">
            <summary>
            An interface to the Texas Instruments SAA USB adapter when loaded with SMBus/I2C
                firmware. We recommend this class for new development: 
                it does not have backwards compatible APIs and
            is more purely object oriented. This provides the same features as <b>SMBusAdapter</b>,
            but it a stream lined interface. <b>This is the
            interface available as a COM library</b>.
            </summary>
            <remarks>
            <para>
            The biggest difference between this class, <b>TIBusAdapters</b>, and <b>SMBusAdapter</b>
            is how you access multiple adapters. TIBusAdapters 
            has an adapter number argument for every function like Read_Block().
            SMBusAdapter has a static array of SMBusAdapter objects.
            </para>
            	<para>Call the <strong>Discover()</strong> method tofind all SAAs
                attached to the PC. It returns a count. 0 means no adapters were found.
                An individual SAA can be detached and
                reattached at any time: SAA actions will simply return the
                SAAStatus.AdapterDetached response cmd_code during this time.</para>
                <para>
                By default, the API will not throw exceptions unless you pass bad data or make some
                other programming error. When making an SAA request such as Read_Byte() or Write_Word(),
                you inspect a return cmd_code to determine if the call succeeded or not. This can get very
                repetitive and add a significant amount of status checking cmd_code to your application. 
                Because of this, the API supports an "Exception" mode. If this is enabled, any time
                there is an error -- such as a Write_Byte() was NACKed by the device -- an exception
                of type RequestException will be thrown. To turn on this mode, set 
                the Exceptions_On_Error property to true. The Message property will detail
                what went wrong and a nice detailed error message in the Message property. 
                </para>
            <para>
                The Status, Status_String, Request, or Message properties can be used to
                access additional infromation about the exception. Request
                is something like "SendByte." Message is something like
                "Send_Byte(address=11) error: NACK".
            </para>
            	<para>Events can be used to easily log SAA requests and keep tabs on changes made
                from other parts of your application:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            		<list type="bullet">
            			<item>
                        <strong>USBDetached</strong> and <strong>USBReattched</strong>
                        events can be subscribed to to monitor detach/attach events. But these are
                        for FYI only: you need not do anything to handle the re-attach.</item>
            			<item><strong>RequestComplete</strong> event is
                        fired after any request is made to the SAA. For example, a read, write, or
                        control line change. This event is fired on both success and
                        failure.</item>
            			<item>The <strong>Warning</strong> event is similar, but only
                        fired on error.</item>
            			<item>The <strong>SMBusAlertLineUpdated</strong>
                        will notify you when a new control or alert line value is read or
                        written.</item>
            		</list>
            	</blockquote>
            	<para>Cross-process locking is automatically performed around each SAA request, to
                ensure that multiple programs and threads can use the SAA without conflict. Locking
                is done per SAA. So if you have multiple SAAs and multiple GUIs or threads, each
                one can access a different SAA simultaneously. But in the more standard case where
                there is one SAA and multiple threads or GUIs, the locking automatically queues up
                one thread/process while the other thread/process does it's work.</para>
            	<para>If the other thread/process dies, the lock is automatically released. You may
                still need to add additional locking to your cmd_code to account for issues related to
                simultaneous access of a single device. For example, on UCD92XX the PAGE command is
                used to identify which rail will be accessed for follow-on commands. In a
                multi-threaded or multi-process environment, you would need to put a secondary lock
                around something like:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            		<list type="bullet">
            			<item>Write PAGE</item>
            			<item>Write to VOUT_COMMAND</item>
            		</list>
            	</blockquote>
            	<para>Why? With only the built-in automatic locking, process A might write PAGE,
                then process B might write PAGE to something else, then process A might write to
                VOUT_COMMAND. But it is easy to handle this situation. Just do something like
                this:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            			<code inline="true">
            				My_Lock();
            				PAGE.Write(0x1);
            				VOUT_COMMAND.Write(1.5);
            				My_Release();
            			</code>
            	</blockquote>
            	<para>
                My_Lock() and My_Release() are routines you would need to create to add
                secondary locks around a block of your cmd_code/etc. Inside of each SAA request a second
                lock is still done.
                </para>
            	<para>Because this is such a standard need, TIBusAdapters includes custom
                <strong>Lock(lock_name)</strong> and <strong>Release(lock_name)</strong> methods. These accept a lock
                ID/name/key, which should be the same for the Lock() and Release() call. The locks
                are PC-wide just like the automatic SAA-level locks. The actual Mutex lock name
                that is used behind the scenes will be have a unique identifier added to ensure
                that your lock is unique.
                </para>
            	<para>If you use exception handling techniques, be sure to put your Release() in a
                finally clause. An example with the custom lock:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            			<code inline="true">
                        try
                        {
                           Adapters.Lock(Device.ToString());
                           Device.Commands.PAGE.Write(0x1);
                           Device.Commands.VOUT_COMMAND.Write(1.5);
                         }
                        finally
                        {
                           Adapters.Release(Device.ToString());
                        }
            			</code>
            	</blockquote>
            	<para>This library was originally written by Marc Sousa of Texas
                Instruments. Mike Muegel ported to C# and added events, support for multiple SAAs,
                support for USB connect/disconnect, exception mode, locking, speed improvements,
                COM interop, and documentation.</para>
            </remarks>
            <example>
            	<para>The following example shows how to "discover" the USB adapter(s) (SAAs) that
                are attached to the PC. The steps:</para>
                <blockquote>
            	<list type="bullet">
            		<item>Call 
                            <strong>Adapters.Discover()</strong>. It looks for any SAAs
                            attached. It returns the number of adapters found.</item>
                    <item>Loop until there is an adapter found, but
                            give the user a chance to exit your program.</item>
            	</list>
                </blockquote>
            	<code lang="CS" title="Initializing the SAA">
            		<![CDATA[
            TIBusAdapters Adapters = new TIBusAdapters();
            
            [STAThread]
            static void Main()
            {
               
               while (true)
               {
                  if (Adapters.Discover() == 0)
                  {
                     DialogResult answer = MessageBox.Show("No SAA adapter found. Please check your USB connection and click Retry or click Cancel to exit XXX", "No USB Adapter Found", MessageBoxButtons.RetryCancel);
                     if (answer == DialogResult.Cancel)
                        return;
                  }
                  else
                  {
                      break;
                  }
                }
             
                Application.Run(new MainForm());
            }]]>
            	</code>
            </example>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Discover">
            <summary>
            Looks for adapters on the PC. You can call this any number of times
            to account for new adapters being attached or adapters removed.
            Each time it is run, adapters are cleared.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Is_Attached(System.Int32)">
            <summary>
            Returns true when the USB adapter previously discovered is still
            attached to the PC. 
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Version(System.Int32)">
            <summary>
            The USB adapter firmware version.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Status_String(TIDP.SAA.SAAStatus)">
            <summary>
            Converts an SAAStatus enumeriation (status) code to a meaningful textual description.
            Success is "ACK", InvalidResponse is "NACK", and then various other
            conditions are reported ("SAA DETACHED", "USB/SAA ERROR", 
            "BAD SMBUS ADDRESS", etc.)
            </summary>        
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Get_SMBus_Alert(System.Int32)">
            <summary>
            Gets the value of the SMBus ALERT line. Fires SMBusAlertLineUpdated when the 
            value read differs from what was previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Get_Control(System.Int32,System.Int32)">
            <summary>
            Gets the value of the specified control line. control_line_number should be 1 to 5. Returns 
            null on read error. Fires ControlLineUpdated when the value read differs from what was 
            previously read or on first read.
            </summary>
            <param name="control_line_number">
            Use 1 for CONTROL line 1, 2 for CONTROL line 2, ..., 5 for CONTROL line 5.
            </param>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Set_Control(System.Int32,System.Int32,TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Returns status of the change.
            </remarks>
            <param name="control_line_number">
            Use 1 for CONTROL line 1, 2 for CONTROL line 2, ..., 5 for CONTROL line 5.
            </param>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Set_Pullups(System.Int32,TIDP.SAA.SMBusAdapter.PullupValues)">
            <summary>
            Sets the pullup resistors for pin 8 (alert), pin 9 (clock), and pin 10 (data).
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Set_Pullups(System.Int32,TIDP.SAA.SMBusAdapter.ResistorValue,TIDP.SAA.SMBusAdapter.ResistorValue,TIDP.SAA.SMBusAdapter.ResistorValue)">
            <summary>
            Sets the pullup resistors for pin 8 (alert), pin 9 (clock), and pin 10 (data).
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Undiscover">
            <summary>
            Closes all USB-HID filehandles in use and clears the Adapters cache.
            You can call Discover() again at this point. Note that Discover()
            automatically calls Undiscover() first.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Dispose">
            <summary>
            Call to unbind all events and dispose of USB handles/etc. Calls
            Undiscover(). Your client should call this before exiting
            it's program, etc.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Lock(System.String)">
            <summary>
            Acquire an exclusive lock accross all processes on this PC. The lock
            will have the specified name. A TI prefix actually gets
            automatically added to the name ("TI-Dallas-DP-SAA-" + lock_name).
            See the Summary section of TIBusAdapters for more information.
            </summary>
        </member>
        <member name="M:TIDP.SAA.TIBusAdapters.Release(System.String)">
            <summary>
            Release the named mutex lock. See Lock(lock_name).
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.USBDetached">
            <summary>
            Fired when a specific adapter is detached. The Adapter that was detached
            is available via the event args. At this point actions performed on the
            Adapter should fail. If SAA is later re-attached, the USBReattached will
            be fired and actions such as get/set should again succeed.
            <para/>
            This event is for FYI only. You do not need to do anything 
            when the SAA is re-attached.
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.USBReattached">
            <summary>
            Fired when a specific adapter is re-attached. The Adapter that was re-attached
            is available via the event args. At this point the Adapter is ready to go and
            actions performed on the Adapter should succeed. 
            <para/>
            This event is for FYI only. You do not need to do anything when the SAA is re-attached.
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.ControlLineUpdated">
            <summary>
            Fired after a call to getControl() and Set_Control() when a CONTROL value read
            differs from the previous value read/written for the specified line/default.
            So no true polling is done of the line, but if you simply re-read
            the line in any type of polling loop you will get events fired
            on updates. 
            <para/>
            An initial event is fired the first time a value is set or read,
            setting the initial value. The event args contains the line number that was 
            updated.
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.SMBusAlertLineUpdated">
            <summary>
            Fired after a call to Get_SMBus_Alert() when the value read differs from the previous 
            value read. So no true polling is done of the line, but if you simply re-read
            the alert line in any type of polling loop you will get events fired
            on updates. 
            <para/>
            An initial event is fired the first time Get_SMBus_Alert() is called.
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.Warning">
            <summary>
            A USB warning even, including attach/detactch information included in the
            USBDetach and USBReattached. Useful mostly for debugging USB problems.
            </summary>
        </member>
        <member name="E:TIDP.SAA.TIBusAdapters.RequestComplete">
            <summary>
            Fired whenever there is a transaction on the SAA. For example,
            Read_Byte or Write_Word or even Set_Control. Only fired when there
            is true SAA communication. Not when something cached is returned
            or some call does not actually operate on the SAA.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.Num_Adapters">
            <summary>
            The number of adapters found by Discover(). Will be 0 after
            a call to Undiscover() or Dispose().
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.GUID">
            <summary>
            Possibly useful for debugging, a unique ID for this instance of
            a TIBusAdapters object. Guranteed to be unique for each object
            constructed.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.Exceptions_On_Error">
            <summary>
            When set to true, any request that would normally return a status
            result -- all methods that actually make a request to the USB
            adapter -- will instead throw an exception. The exception
            will have a nice detailed Message. With COM, this will cause
            a runtime error. The default is false.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Request">
            <summary>
            A unique identifier for the SAA request.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Is_SAA_Settings_Request">
            <summary>
            Returns true if the request SAA request was either SetBusSpeed or EnablePec.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.SMBus_Address">
            <summary>
            Address for the transaction. Will be 0xFF when not appropriate.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.SMBus_Command">
            <summary>
            Command cmd_code for transaction. Will be 0xFF when not appropriate.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.SMBus_Data">
            <summary>
            The data sent or received. May be null on error or commands like
            SendByte.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Status">
            <summary>
            Response cmd_code. Status_String provides a user friendly
            description.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Is_Success">
            <summary>
            Returns true when Status is SAAStatus.Success.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Received">
            <summary>
            A textual description of what was received should the command
            read something, either from a device or a setting/etc. from
            the SAA.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Status_String">
            <summary>
            Something like "ACK", "NACK" or "USB ERROR".
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.RequestCompleteEventArgs.Message">
            <summary>
            A summary of the request. For example, "Address 49 ReadByte: ACK [0x00]".
            </summary>
        </member>
        <member name="F:TIDP.SAA.TIBusAdapters.ControlLineUpdatedEventArgs.Line">
            <summary>
            Line number from 1 to 5.
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.ControlLineUpdatedEventArgs.Message">
            <summary>
            Something like "USB #1 CONTROL1 now High".
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.SMBusAlertLineUpdatedEventArgs.Message">
            <summary>
            Something like "USB #1 SMBALERT# now Low".
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.USBDetachedEventArgs.Message">
            <summary>
            Returns "USB #1 SAA detached".
            </summary>
        </member>
        <member name="P:TIDP.SAA.TIBusAdapters.USBReattachedEventArgs.Message">
            <summary>
            Returns "USB #1 SAA re-attached".
            </summary>
        </member>
        <member name="T:TIDP.SAA.SAA">
            <summary>
            Static class to provide some general purpose utilities.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAA.Status(System.Nullable{TIDP.SAA.SAAStatus})">
            <summary>
            Converts an SAAStatus enumeriation (status) code to a meaningful textual description.
            Success is "ACK", InvalidResponse is "NACK", and then various other
            conditions are reported ("SAA DETACHED", "USB/SAA ERROR", 
            "BAD SMBUS ADDRESS", etc.
            </summary>        
        </member>
        <member name="T:TIDP.SAA.SMBusOfflineAdapter2">
            <summary>
            An ISMBusAdapter that is offline. All device write calls will return
            success and fire appropriate events. All read calls and other SAA
            calls like getting signal status will return failure.
            </summary>
            <remarks>
            Used to determine the SMBus/I2C writes that would be
            done if online, during the SMBus/I2C export process of DeviceExporter.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Get_SMBus_Alert">
            <summary>
            Gets the value of the SMBus ALERT line. Fires SMBusAlertLineUpdated when the 
            value read differs from what was previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Get_Control(System.Int32)">
            <summary>
            Gets the value of the specified control line. control_line_number should be 1 to 5. 
            Fires ControlLineUpdated when the value read differs from what was 
            previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Get_Control">
            <summary>
            Gets the value of the primary control line, CONTROL line #1 (signal index 0). 
            Fires ControlLineUpdated when the value read differs from what was 
            previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Set_Control(TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the primary control line, CONTROL line #1. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Set_Control(System.Boolean)">
            <remarks>
            Sets the primary control line, CONTROL line #1. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Set_Control(System.Int32,System.Boolean)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.ISMBusAdapter.Set_Control(System.Int32,TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="P:TIDP.SAA.ISMBusAdapter.Is_Attached">
            <summary>
            Returns true if the low-level USB-HID driver is attached to the SAA
            previously found. If not, then all reads/writes will fail automatically
            with the error AdapterDetached.
            <para/>
            So this property is mostly useful to know why a read/write failed.
            </summary>
        </member>
        <member name="P:TIDP.SAA.ISMBusAdapter.Is_Offline">
            <summary>
            True when the adapter is an SMBusOfflineAdapter or SMBusOfflineAdapter2.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusOfflineAdapter2.Block_Write_Block_Read_Process_Call(System.Byte,System.Byte,System.Int32,System.Byte[],System.Byte[]@)">
            <summary>
            Use for import and export
            </summary>
            <param name="addr"></param>
            <param name="cmd_code"></param>
            <param name="byteCount"></param>
            <param name="write_block"></param>
            <param name="expected_read_block"></param>
            <returns></returns>
        </member>
        <member name="E:TIDP.SAA.SMBusOfflineAdapter2.RequestComplete">
            <summary>
            Fired for the write commands we simulate
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusOfflineAdapter2.Retry_On_Failure">
            <summary>
            Always returns 0. Setting is ignored.
            </summary>
        </member>
        <member name="T:TIDP.SAA.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.usb_saa_v1_0_10_bin">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.usb_saa_v1_0_11_bin">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.usb_saa_v1_0_13_bin">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:TIDP.SAA.Properties.Resources.usb_saa_v1_0_14_bin">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusData.ToString(TIDP.HexFormat)">
            <summary>
            Returns something like 0xAABB, AABB, or AA-BB, depending
            on the setting of HexFormat.
            </summary>
        </member>
        <member name="T:TIDP.SAA.PMBusByte">
            <summary>
            Represents a byte received or transmitted. You can do value equality
            testing using == and !=. You can access a bit via my_byte[0] syntax.
            </summary>
            <remarks>
            Would have prefered to rename this SMBusByte, but this is already embedded
            in project files and other cmd_code.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.#ctor">
            <summary>
            The Byte will be 0x00.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.#ctor(System.Byte)">
            <summary>
            Define the Byte.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.#ctor(System.String)">
            <summary>
            Accepts a hex string in a variety of formats (0xAA, AA, etc). See 
            BitUtils.Parse_Hex_Byte() for all formats supported. 
            </summary>
            <exception cref="T:TIDP.HexParseException">
            Throw an exception if the hex string can not parsed or contains too many or too 
            few bytes.
            </exception>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.Equals(System.Object)">
            <summary>
            Compares the supplied object for value equality to this PMBusByte.
            OK to pass null, which will always return false.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.GetHashCode">
            <summary>
            Overriden to return a unique hash cmd_code based on the 
            byte. So two objects with the same bytes will be
            equal.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusByte.ToString">
            <summary>
            Returns something like "0x02".
            </summary>
        </member>
        <member name="P:TIDP.SAA.PMBusByte.Item(System.Int32)">
            <summary>
            Get or set a bit in the byte.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.Extract(System.Int32,System.Int32)">
            <summary>
            Extract a series of bytes from the block and return as an 
            array of bytes. Will throw an exception if arguments are
            inavlid.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.Insert(System.Int32,System.Byte[])">
            <summary>
            Inserts a series of bytes at the specified position into
            a block that has been preallocated. Will throw an exception
            if it can not fit or index is invalid. OK to pass an empty
            array, which will be ignored.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.#ctor(System.Int32,System.Byte[])">
            <summary>
            Creates a block of the specified length, and copies the specified
            bytes into it. OK if there are fewer or more bytes passed then
            length supports: missing bytes will be the 0x00 default and extra
            bytes passed will be skipped.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.#ctor(System.String)">
            <summary>
            Accepts "" or "&lt;empty&gt;" to return a null block (length 0) String should be 
            in the format 0xFF... Will throw a HexParseException on parse error. 
            </summary>
            <param name="bytes"></param>
            <exception cref="T:TIDP.HexParseException">
            Throw an exception if the hex string can not parsed or contains too many or too 
            few bytes.
            </exception>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.Equals(System.Object)">
            <summary>
            Compares the supplied object for value equality to this PMBusBlock.
            OK to pass null, which will always return false.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.GetHashCode">
            <summary>
            Overriden to return a unique hash cmd_code based on the 
            bytes. So two objects with the same bytes will be
            equal.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.ToString">
            <summary>
            Returns either "&lt;empty&gt;" or the block in 0x... format.
            When printing the block, the bytes are printed lo to hi order
            (index 0, 1, 2, etc.).
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.Is_All(System.Byte)">
            <summary>
            Returns true if every byte in the block has the same value.
            Returns false always if the block is zero length.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusBlock.Clone">
            <summary>
            Returns a deep Clone.
            </summary>
        </member>
        <member name="P:TIDP.SAA.PMBusBlock.Bytes">
            <summary>
            The hi byte is byte 0. The low byte is byte Length-1.
            </summary>
        </member>
        <member name="P:TIDP.SAA.PMBusBlock.Hex">
            <summary>
            Get/set based on hex string.
            </summary>
        </member>
        <member name="P:TIDP.SAA.PMBusBlock.Item(System.Int32)">
            <summary>
            The hi byte is byte 0. The low byte is byte Length-1.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor">
            <summary>
            Creates a two byte Bytes array, but the individual values will
            be undefined.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.Boolean)">
            <summary>
            Does not define the underlying Bytes array if preallocate is false. 
            Might safe a cycle or a bit of memory when you just want to assign
            to it later.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Assigns the array passed to Bytes. Specify whether to copy or assign
            the array by reference.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.Byte[])">
            <summary>
            Creates a PMBusWord using a copy of the passed bytes.
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.Byte,System.Byte)">
            <summary>
            Creates a two byte Bytes array and sets the values.
            </summary>
            <param name="hi_byte"></param>
            <param name="lo_byte"></param>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.UInt16)">
            <summary>
            Create the word based on the unsigned integer it represents. I.e.
            a number from 0 to 2^16 - 1.
            </summary>
        </member>
        <member name="M:TIDP.SAA.PMBusWord.#ctor(System.String)">
            <summary>
            Accepts a hex string in a variety of formats (0xAAAA, AAAA, etc). See 
            BitUtils.Parse_Hex_Bytes() for all formats supported. Will 
            </summary>
            <exception cref="T:TIDP.HexParseException">
            Throw an exception if the hex string can not parsed or contains too many or too 
            few bytes.
            </exception>
        </member>
        <member name="P:TIDP.SAA.PMBusWord.Hi_Byte">
            <summary>
            Alias for Bytes[0].
            </summary>
        </member>
        <member name="P:TIDP.SAA.PMBusWord.Lo_Byte">
            <summary>
            Alias for Bytes[1].
            </summary>
        </member>
        <member name="M:TIDP.SAA.AdapterResult.ToString">
            <summary>
            Same as SAA_Status_String. 
            </summary>
        </member>
        <member name="P:TIDP.SAA.AdapterResult.SAA_Status">
            <summary>
            A status code representing the success/failure of the
            request. Probably easier to look at the Success property and
            then inspect SAA_Status_String for a nice textual version
            of the error.
            </summary>
        </member>
        <member name="P:TIDP.SAA.AdapterResult.SAA_Status_String">
            <summary>
            Converts SAA_Status code to a meaningful textual description.
            Success is "ACK", InvalidResponse is "NACK", and then various other
            conditions are reported ("SAA DETACHED", "USB/SAA ERROR", 
            "BAD SMBUS ADDRESS", etc.).
            </summary>        
        </member>
        <member name="P:TIDP.SAA.AdapterResult.Success">
            <summary>
            A quick way to determine whether your request was a success (true)
            or failure (false).
            </summary>
        </member>
        <member name="M:TIDP.SAA.EncodedResultBase.ToString">
            <summary>
            Returns "ACK: 0xAA" (or word or block) or something like "NACK" on error.
            </summary>
        </member>
        <member name="P:TIDP.SAA.EncodedResultBase.Bytes">
            <summary>
            Returns the bytes received from the request. If there
            was an error, always returns null.
            </summary>
        </member>
        <member name="M:TIDP.SAA.EncodedResult`1.ToString">
            <summary>
            Returns the string version of the Data ("0xAABB", "Low", etc.) 
            or a textual version of the error ("NACK", "SAA DETACHED", etc.).
            </summary>
        </member>
        <member name="M:TIDP.SAA.ByteEncodedResult.#ctor(TIDP.SAA.PMBusByte)">
            <summary>
            Creates a copy of the data object passed.
            </summary>
        </member>
        <member name="M:TIDP.SAA.WordEncodedResult.#ctor(System.Boolean)">
            <summary>
            If preallocate is true, the underlying PMBusWord byte array
            is created.
            </summary>
        </member>
        <member name="M:TIDP.SAA.WordEncodedResult.Error">
            <summary>
            Creates an error result with SAAStatus.GeneralFailure.
            </summary>
        </member>
        <member name="P:TIDP.SAA.WordEncodedResult.Bytes">
            <summary>
            Returns null if Success is false.
            </summary>
        </member>
        <member name="M:TIDP.SAA.LogicLevelResult.ToString">
            <summary>
            Returns "ACK: High" or something like "NACK" on error.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.InvalidResponse">
            <summary>
            This is generally equivalent to a "NACK" from the device.
            For commands such as Write_Byte(), this response means that
            the SAA responded with "FAIL".
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.InvalidPEC">
            <summary>
            PEC mismatch. Not supported by SAA, but may be supported by
            other adapters.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.InvalidArgument">
            <summary>
            A bad argument other than address/length was passed.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.DriverError">
            <summary>
            We were either unable to write to the SAA via USB or the
            response from the SAA was not in the expected format.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SAAFirmwareDoesNotSupportParallelMode">
            <summary>
            Returned if someone tries to enable parallel mode on the SAA but
            it does not support it.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SAAFirmwareDoesNotSupportProcessCall">
            <summary>
            Returned if someone tries to use execute a process call but the SAA does not
            support it.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.AdapterDetached">
            <summary>
            The adapter has been detached and not reattached yet.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.UnsupportedFeature">
            <summary>
            The request (write block, set control, etc.) is not supported by the device/driver.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.Skipped">
            <summary>
            This request was skipped for some reason. Not used by SMBusAdapter.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.BadEncoding">
            <summary>
            If we can not decode what we read from the device. Not used by SMBusAdapter.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.Undefined">
            <summary>
            Useful for representing a null state w/out using a nulled version of SAAStatus.
            Not used by SMBusAdapter.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToTestMode">
            <summary>
            Skipped because the command is a test mode command and test mode has not been enabled.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToAdvancedFeatureMode">
            <summary>
            Skipped because the command requires the protected features mode to be enabled, and it
            has not been enabled.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.WriteReadBackNACKed">
            <summary>
            After a write is done and if read-back validation is enabled, this will be returned if the
            read NACKed
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.WriteReadBackMismatch">
            <summary>
            After a write is done and if read-back validation is enabled, this will be returned if the
            value read back did not match what was written
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.Timeout">
            <summary>
            USB timeout. The adapter did not respond within 1000 msec.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToTLOBitNotSet">
            <summary>
            Skipped because the command is a test mode command, and test mode is enable, but TLO bit is not set
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToBeingSlaveChannel">
            <summary>
            Skipped because the command is paged-command and channel is slave
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToBeingBlocked">
            <summary>
            Skipped because the command is either test mode command, or channel is slave, or TLO bit is not set,
            or else (TPS Devices in AVS mode, etc)
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToWriteProtected">
            <summary>
            Skip because the command is not writable due to WRITE_PROTECT command is set to 0x80
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToPageWriteProtected">
            <summary>
            Skip because the command is either paged-command, and
            PAGE command are not writable due to WRITE_PROTECT command is set to 0x80
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAAStatus.SkippedDueToPhaseWriteProtected">
            <summary>
            Skip because the command is either phase-command, and
            PHASE command are not writable due to WRITE_PROTECT command is set to 0x80
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter">
            <summary>
                An interface to the Texas Instruments SAA USB adapter when loaded with SMBus/I2C
                firmware. Supports multiple physical SAA adapters. Supports most older legacy
                functions from the old <b>PMBusTransport</b> class. We recommend <b>TIBusAdapters</b> for
                new applications.
            </summary>
            <remarks>
            	<para>Call the static/shared <strong>Discover()</strong> method tofind all SAAs
                attached to the PC. They are then available via the static/shared
                <strong>Adapters</strong> list, where a separate SMBusAdapter object is
                automatically created for each SAA found. An individual SAA can be detached and
                reattached at any time: SAA actions will simply return the
                SAAStatus.AdapterDetached response cmd_code during this time.</para>
            	<para>You will find that are many ways to do the same thing, usually via method
                overloads. For example, readWord() -- to perform an SMBus read word -- can be
                called two different ways:</para>
                <blockquote>
            	<list type="number">
            		<item>Pass by reference approach: <strong>readWord(address, cmd_code, ref
                    hi_byte, ref low_byte)</strong>. A status cmd_code is returned.</item>
            		<item>Return custom object approach: <strong>readWord(address,
                    cmd_code)</strong>. Returns a <strong>WordEncodedResult</strong> object, which
                    has a Success property to determine whether the request was successful and, if
                    it was, a Bytes property to access the word that was read.</item>
            	</list>
            	</blockquote>
            	<para>(2) is recommended for new cmd_code. (1) is provided for backwards compatability
                to users of older SAA APIs.</para>
                <para>
                By default, the API will not throw exceptions unless you pass bad data or make some
                other programming error. When making an SAA request such as Read_Byte() or Write_Word(),
                you inspect a return cmd_code to determine if the call succeeded or not. This can get very
                repetitive and add a significant amount of status checking cmd_code to your application. 
                Because of this, the API supports an "Exception" mode. If this is enabled, any time
                there is an error -- such as a Write_Byte() was NACKed by the device -- an exception
                of type RequestException will be thrown. To turn on this mode, set 
                SMBusAdapter.Exceptions_On_Error to true. The Message property will detail
                what went wrong and a nice detailed error message in the Message property. 
                </para>
            <para>
                The Status, Status_String, Request, or Message properties can be used to
                access additional infromation about the exception. Request
                is something like "SendByte." Message is something like
                "Send_Byte(address=11) error: NACK".
            </para>
            	<para>Events can be used to easily log SAA requests and keep tabs on changes made
                from other parts of your application:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            		<list type="bullet">
            			<item>The static/shared
                        <strong>USBDetached</strong> and <strong>USBReattched</strong>
                        events can be subscribed to to monitor detach/attach events. But these are
                        for FYI only: you need not do anything to handle the re-attach.</item>
            			<item>The static/shared <strong>RequestComplete</strong> event is
                        fired after any request is made to the SAA. For example, a read, write, or
                        control line change. This event is fired on both success and
                        failure.</item>
            			<item>The <strong>Warning</strong> event is similar, but only
                        fired on error.</item>
            			<item>The <strong>SMBusAlertLineUpdated</strong>
                        will notify you when a new control or alert line value is read or
                        written.</item>
            		</list>
            	</blockquote>
            	<para>Cross-process locking is automatically performed around each SAA request, to
                ensure that multiple programs and threads can use the SAA without conflict. Locking
                is done per SAA. So if you have multiple SAAs and multiple GUIs or threads, each
                one can access a different SAA simultaneously. But in the more standard case where
                there is one SAA and multiple threads or GUIs, the locking automatically queues up
                one thread/process while the other thread/process does it's work.</para>
            	<para>If the other thread/process dies, the lock is automatically released. You may
                still need to add additional locking to your cmd_code to account for issues related to
                simultaneous access of a single device. For example, on UCD92XX the PAGE command is
                used to identify which rail will be accessed for follow-on commands. In a
                multi-threaded or multi-process environment, you would need to put a secondary lock
                around something like:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            		<list type="bullet">
            			<item>Write PAGE</item>
            			<item>Write to VOUT_COMMAND</item>
            		</list>
            	</blockquote>
            	<para>Why? With only SMBusAdapter automatic locking, process A might write PAGE,
                then process B might write PAGE to something else, then process A might write to
                VOUT_COMMAND. But it is easy to handle this situation. Just do something like
                this:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            			<code inline="true">
            				My_Lock();
            				PAGE.Write(0x1);
            				VOUT_COMMAND.Write(1.5);
            				My_Release();
            			</code>
            	</blockquote>
            	<para>
                My_Lock() and My_Release() are routines you would need to create to add
                secondary locks around a block of your cmd_code/etc. Inside of each SAA request a second
                lock is still done.
                </para>
            	<para>Because this is such a standard need, SMBusAdapter includes custom
                <strong>Lock(lock_name)</strong> and <strong>Release(lock_name)</strong> methods. These accept a lock
                ID/name/key, which should be the same for the Lock() and Release() call. The locks
                are PC-wide just like the automatic SAA-level locks. The actual Mutex lock name
                that is used behind the scenes will be have a unique identifier added to ensure
                that your lock is unique.
                </para>
            	<para>If you use exception handling techniques, be sure to put your Release() in a
                finally clause. An example with the custom lock:</para>
            	<blockquote dir="ltr" style="MARGIN-RIGHT: 0px">
            			<code inline="true">
                        try
                        {
                           Adapter.Lock(Device.ToString());
                           Device.Commands.PAGE.Write(0x1);
                           Device.Commands.VOUT_COMMAND.Write(1.5);
                         }
                        finally
                        {
                           Adapter.Release(Device.ToString());
                        }
            			</code>
            	</blockquote>
            	<para>This library was originally written by Marc Sousa of Texas
                Instruments. Mike Muegel ported to C# and added events, support for multiple SAAs,
                support for USB connect/disconnect, exception mode, locking, speed improvements,
                COM interop, and documentation.</para>
            </remarks>
            <example>
            	<para>The following example shows how to "discover" the USB adapter(s) (SAAs) that
                are attached to the PC. The steps:</para>
                <blockquote>
            	<list type="bullet">
            		<item>Call static (aka shared)
                            <strong>SMBusAdapter.Discover()</strong>. It looks for any SAAs
                            attached. It returns the number of adapters found.</item>
                    <item>Loop until there is an adapter found, but
                            give the user a chance to exit your program.</item>
            	</list>
                </blockquote>
            	<para>Once one or more adapters have been found, all the adapters are available in
                the static (shared) <strong>SMBusAdapter.Adapters</strong> list. This is a
                read-only List (like an array) of the Adapters automatically created. Thus all you
                need to do is call Discover() until an adapter is found.</para>
            	<para>Since many programs only support a single device and therefore only need to
                be concerned with a single adapter, a convienence static property
                <strong>SMBusAdapter.Adapter</strong> is available.</para>
            	<code lang="CS" title="Initializing the SAA">
            		<![CDATA[
            [STAThread]
            static void Main()
            {
               while (true)
               {
                  if (SMBusAdapter.Discover() == 0)
                  {
                     DialogResult answer = MessageBox.Show("No SAA adapter found. Please check your USB connection and click Retry or click Cancel to exit XXX", "No USB Adapter Found", MessageBoxButtons.RetryCancel);
                     if (answer == DialogResult.Cancel)
                        return;
                  }
                  else
                  {
                      break;
                  }
                }
             
                Application.Run(new MainForm());
            }]]>
            	</code>
            </example>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.MAX_PAGE_PLUS_WRITE_DATA_LENGTH">
            <summary>
            The number of data bytes that can be written with PAGE_PLUS_WRITE. This is
            32 - 1 (cmd code byte) - 1 (page byte).
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ENSURE_REMOTING_SECURITY">
            <summary>
            If the ensureSecurity parameter is set to true, the remoting 
            system determines whether the channel implements ISecurableChannel, 
            and if so, enables encryption and digital signatures. An exception 
            is thrown if the channel does not implement ISecurableChannel. 
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter._Default_Adapter_Num">
            <summary>
            backing field for Default_Adapter_Num
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.Exceptions_On_Error">
            <summary>
            When set to true, any request that would normally return a SAAStatus
            that is not Success will instead throw an exception. The exception
            will be a 
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.WIRE_REQUEST_POST_EXECUTE_DELAY">
            <summary>
            Time, in milliseconds, to pause after every I2C/SMBus request. Useful
            in debug situations.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Run_Events_On_UI_Thread(System.Threading.SynchronizationContext)">
            <summary>
            We need a non-null Context in order to marshall events onto the
            UI thread. The static constructor will only produce a non-null
            context if it is run from within a form. Calling this will ensure
            this is setup. It should be called from within a form event
            handler such as OnShown(). An exception will be thrown if there 
            is no UI context.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if there is an error getting a UI context. Usually this
            means you called Define_Context() outside of a 
            </exception>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.Mutexes">
            <summary>
            SAA and user locks.
            </summary>
            <remarks>
            When used a non-static Mutex received the error "Object synchronization 
            method was called from an unsynchronized block of cmd_code" on some releases.
            </remarks>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.Remoting_Server_Password">
            <summary>
            If set, clients must send this password with some key bootstrap requests.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.Remoting_Helper">
            <summary>
            This gets created by the client and is a remote object on the server.
            It is used by the client's static Discover() method to perform similar
            actions on the server.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.InitializeLifetimeService">
            <summary>
            For .NET remoting.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Start_Remoting_Server(TIDP.SAA.SMBusAdapter.ServerOptions)">
            <summary>
            Makes all adapters previously discovered via SMBusAdapter.Discover()
            available via .NET remoting.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if you try to start when you are already in client or server mode.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Stop_Remoting_Server">
            <summary>
            Stops listening for remoting requests. OK if Start had never 
            been called. Does not actually switch back to standard server-less
            mode. But does provide a way to stop inbound requests until
            Start_Remoting_Server is called again.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Connect_To_Remoting_Server(TIDP.SAA.SMBusAdapter.ClientOptions)">
            <summary>
            Configures the SMBusAdapter class to act as a remote client to the passed
            server info. SMBusAdapter.Discover() can be called as normal, and when
            done all adapters on the remote server will be available via remoting-based
            SMBusAdapter objects via SMBusAdapter.Adapters.
            </summary>
            <remarks>
            You can call Disconnect_From_Remoting_Server() to stop using remoting.
            This is used by the SMBusAdapterClientForm to test remoting but 
            turn off when done.
            </remarks>
            <exception cref="T:System.Exception">
            Thrown if you try to start when you are already in client or server mode.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Disconnect_From_Remoting_Server">
            <summary>
            Stops using remoting for the SMBusAdapter class. Undiscovers 
            any adapters previously found first. OK to call
            if not actually in client mode: just ignored.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Register_Driver(TIDP.SAA.IAdapterDriverFactory)">
            <summary>
            Adds a new low-level adapter driver. Call this before calling
            Discover(). The standard USB-TO-GPIO driver is automatically
            added.
            </summary>
            <remarks>
            For now no facility to remove a driver, as there does not appear
            to be a need.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.ToString">
            <summary>
            Returns something like Adapter #1 [ SAA 1\\?\hid#vid_0451&amp;pid_5f00#6&amp;309601ea&amp;0&amp;0000#{4d1e55b2-f16f-11cf-88cb-001111000030} ]
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Discover">
            <summary>
            Finds all SAA adapters that are attached and constructs SMBusAdapter
            instances for each one found. You can access this array via the Adapters 
            static property. This function returns the number of SAA adapters that
            were found. If called multiple times, new adapter(s) are created and the 
            old ones are released.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Undiscover">
            <summary>
            Closes all USB-HID filehandles in use and clears the Adapters cache.
            You can call Discover() again at this point. Note that Discover()
            automatically calls Undiscover first.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Read_Block(System.Byte,System.Byte,System.Byte[]@,System.Boolean)">
            <summary>
            Reads a block of data. Inspect the size of the data array that is set to
            determine number of bytes received. Will be 0 elements if none were
            received.
            </summary>
            <param name="addr"></param>
            <param name="cmd_code"></param>
            <param name="data">Do not initialize.</param>
            <param name="block96"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Write_Word(System.Byte,System.Byte,System.Byte[])">
            <summary>
            </summary>
            <param name="addr"></param>
            <param name="cmd_code"></param>
            <param name="word">word[0] is the hi byte. word[1] is the low byte.</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Write_Block_MSP430(System.Byte,System.Byte,System.Byte[])">
            <summary>
            If PEC is enabled, uses I2CWrite to manually send PEC byte and then add extra
            dummy byte at end. If PEC is disabled, just uses standard Write_Block() function.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Block_Write_Block_Read_Process_Call(System.Byte,System.Byte,System.Byte[])">
            <summary>
            Implements the block read, block write process call model.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.PEC_Enabled">
            <summary>
            Returns null if this API has never been used to set PEC on/off. I.e.
            we don't know what the current setting of the SAA is.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Parallel_Mode_Enabled">
            <summary>
            Returns null if this API has never been used to set parallel mode on/off. I.e.
            we don't know what the current setting of the SAA is.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Bus_Mode(TIDP.SAA.SMBusAdapter.BusMode)">
            <summary>
            Wrapper around Set_Parallel_Mode().
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Bus_Mode">
            <summary>
            Wrapper around getParallelMode(). Returns null if this API has 
            never been used to set parallel mode on/off. I.e.
            we don't know what the current setting of the SAA is.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Parallel_Mode_If_Update(System.Boolean)">
            <summary>
            Only invokes Set_Parallel_Mode if the current state does not match
            enabled.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Parallel_Mode(System.Boolean)">
            <summary>
            If enabled is false, then serial mode is set. Serial mode is the power on
            default. Returns SAAFirmwareDoesNotSupportParallelMode if the SAA firmware 
            does not support parallel mode.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Parallel_Mode">
            <summary>
            Returns null if this API has never been used to set PEC on/off. I.e.
            we don't know what the current setting of the SAA is.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Major_Settings">
            <summary>
            This and Set_Major_Settings() provides a nice way to save the
            state of the SAA for major settings -- PEC, Speed, and 
            Parallel/Serial -- and later restore it.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Major_Settings(System.Nullable{TIDP.SAA.SMBusAdapter.BusSpeed},System.Nullable{System.Boolean},System.Nullable{TIDP.SAA.SMBusAdapter.BusMode},System.Boolean)">
            <summary>
            Sets only those SAA settings that are not null. Returns a class that
            contains the original, pre-call settings and the post-call settings.
            Also holds whether there was an error and if anything was actually
            updated. Ignores mode if the SAA FW will not support it (less than
            1.0.12).
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_UCD_ROM_Settings">
            <summary>
            Forces PEC mode to on and serial mode on. Does not change bus speed.
            suitable for the SAA to talk to a UCDXXXX ROM.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_UCD_ROM_Settings(System.Boolean)">
            <summary>
            Forces PEC mode to on, and serial mode on, suitable for the SAA to talk 
            to a UCDXXXX ROM. Does not change bus speed.
            </summary>
            <param name="never_throw_exceptions">
            If true, Exceptions_On_Error setting is ignore and this function
            will always return a SetMajorResult.
            </param>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Major_Settings(TIDP.SAA.SMBusAdapter.MajorSettings,System.Boolean)">
            <summary>
            Configures the SAA so it matches what is passed. If force is
            false, only changes will cause SAA commands to be invoked. But
            if force is true, all settings will be written. Ignores 
            mode request if the SAA does not support it.
            </summary>
            <returns>
            Returns SAAStatus.Success if 100% success. Returns the last error
            encountered if there was an error in any one SAA command (but all are invoked).
            </returns>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_SMBus_Alert">
            <summary>
            Gets the value of the SMBus ALERT line (SAA SIGNAL index 6). Fires SMBusAlertLineUpdated when 
            the value read differs from what was previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Control(System.Int32)">
            <summary>
            Gets the value of the specified control line. control_line_number should be 1 to 5. Returns 
            null on read error. Fires ControlLineUpdated when the value read differs from what was 
            previously read or on first read.
            </summary>
            <param name="control_line_number">
            Use 1 for CONTROL line 1, 2 for CONTROL line 2, ..., 5 for CONTROL line 5.
            </param>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Control">
            <summary>
            Gets the value of the primary control line, CONTROL line #1. Returns 
            null on read error. Fires ControlLineUpdated when the value read differs from what was 
            previously read or on first read.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Control(TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the primary control line, CONTROL line #1. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Control(System.Boolean)">
            <remarks>
            Sets the primary control line, CONTROL line #1. Leaves other lines alone.
            Returns status of the change.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Control(System.Int32,System.Boolean)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Returns status of the change.
            </remarks>
            <param name="control_line_number">
            Use 1 for CONTROL line 1, 2 for CONTROL line 2, ..., 5 for CONTROL line 5.
            </param>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Control(System.Int32,TIDP.SAA.LogicLevel)">
            <remarks>
            Sets the CONTROL line specified, numbered 1 to 5. Leaves other lines alone.
            Returns status of the change.
            </remarks>
            <param name="control_line_number">
            Use 1 for CONTROL line 1, 2 for CONTROL line 2, ..., 5 for CONTROL line 5.
            </param>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Write(System.Byte,System.Byte,System.Byte[])">
            <summary>
            High-level I2C write. You pass standard unshifted address, a command byte,
            and the data to write. The API shifts the address for you.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Write(System.Byte,System.Byte,System.Int32,System.Byte[])">
            <summary>
            High-level I2C write. You pass standard unshifted address, a command byte,
            data length to write, and the data to write. The API shifts the address
            for you.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Read(System.Byte,System.Byte,System.Int32)">
            <summary>
            High-level I2C read. You pass standard unshifted address, a command byte,
            and the data length to read. The API shifts and sets the address read bit
            for you.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Read(System.Byte,System.Byte,System.Int32,System.Byte[]@)">
            <summary>
            High-level I2C read. You pass standard unshifted address, a command byte,
            and the data length to read. The API shifts and sets the address read bit
            for you.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Write_Generic(System.Byte[])">
            <summary>
            Low-level I2C write. No special processing is done and you must setup address/etc. byte elements
            as appropriate.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Write_Generic(System.String)">
            <summary>
            Low-level I2C write. No special processing is done and you must setup address/etc. byte elements
            as appropriate.
            </summary>
            <param name="hex_bytes"></param>
            <returns></returns>
            <exception cref="T:System.Exception">
            Thrown if the hex string can not be parsed.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.I2C_Write_Generic(System.Int32,System.Byte[])">
            <summary>
            Low-level I2C write. dataLen bytes from data array are passed to the adapter.
            No special processing is done and you must setup address/etc. byte elements
            as appropriate.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.GPIO_Read_Write(System.Byte,System.Byte,System.Byte@)">
            <summary>
            Reads and/or writes a GPIO. The readMask determines whether a given bit will be
            read or written. If a bit in readMask is 1, then the corresponding GPIO will be
            read and the bit result placed in readData. If it is 0, the corresponding 
            bit will be written. The bit to write will be taken from writeData. There are easier
            to use versions of this that do not use byte bitmasks.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Pull_Ups(TIDP.SAA.SMBusAdapter.PullupValues)">
            <summary>
            Sets the pullup resistors for pin 8 (alert), pin 9 (clock), and pin 10 (data).
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Set_Pull_Ups(TIDP.SAA.SMBusAdapter.ResistorValue,TIDP.SAA.SMBusAdapter.ResistorValue,TIDP.SAA.SMBusAdapter.ResistorValue)">
            <summary>
            Sets the pullup resistors for pin 8 (alert), pin 9 (clock), and pin 10 (data).
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Get_Version">
            <summary>
            Returns a USB adapter version object. On error, returns null.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Is_Wire_Request(TIDP.SAA.SMBusAdapter.SAARequestID)">
            <summary>
            Returns true if request_id is one that will result in a 
            read or a write on the wire, in parallel or serial mode.
            I.e. not just setting PEC in the adapter or some such.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Lock(System.String)">
            <summary>
            Acquire an exclusive lock accross all processes on this PC. The lock
            will have the specified name. A TI prefix actually gets
            automatically added to the name ("TI-Dallas-DP-SAA-" + lock_name).
            See the Summary section of SMBusAdapter for more information.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Release(System.String)">
            <summary>
            Release the named mutex lock. See Lock(lock_name).
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Page_Plus_Read_Byte(System.Byte,System.Byte,System.Byte)">
            <summary>
            Does a PAGE_PLUS_READ, but verifies that the data returned was 1 byte wide. 
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Page_Plus_Read_Word(System.Byte,System.Byte,System.Byte)">
            <summary>
            Does a PAGE_PLUS_READ, but verifies that the data returned was 2 byte wide. 
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Measure_Remoting_Client_Speed(TIDP.SAA.SMBusAdapter,System.Int32)">
            <summary>
            Runs a very simple test of remoting speed on this client adapter
            (ie you must have first called SMBusAdapter.Connect_To_Remoting_Server).
            A getControl() is performed in a loop to measure average SAA request 
            speed. Since this SAA request does not have an I2C component, it measures
            the combined network+remoting+USB+API latency.
            </summary>
            <remarks>
            This is static so it runs fully on the client.
            </remarks>
            <exception cref="T:System.Exception">
            Thrown on any SAA/remoting error.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Find_And_Register_Driver(System.Reflection.Assembly)">
            <summary>
            Looks at all public types in the passed assembly. If a class implements
            IAdapterDriverFactory, the class will be instantiated and registered as
            a custom driver via Register_Driver. A list of the driver factories that
            were registered is returned (usually 0 or 1 length).
            </summary>
            <exception cref="T:System.Exception">
            An exception might be thrown if the plug-in folder is not valid, a dll found cannot
            be loaded, or a factory class could not be instantiated (constructed).
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Find_And_Register_Driver_From_Plugin_Folder(System.String)">
            <summary>
            Looks for *.dll assembly (library) files in the specified folder. For each found, loads the 
            assembly into the current app domain so the code is now available. From there, it calls
            Find_And_Register_Driver(assembly) to register any SMBusAdapter drivers found. 
            A list of the driver factories that were registered is returned (usually 0 or 1 length).
            </summary>
            <exception cref="T:System.Exception">
            An exception might be thrown if the plug-in folder is not valid, a dll found cannot
            be loaded, or a factory class could not be instantiated (constructed).
            </exception>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Lock_SAA(System.String)">
            <summary>
            Acquire an exclusive lock accross all processes on this PC for this
            specific SAA adapter (i.e. each adapter has it's own lock).  This
            is invoked automatically around each SAA request. You can also call
            to lock a group of SAA requests. See
            the Summary section of SMBusAdapter for more information.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Release(TIDP.SAA.SAAStatus)">
            <summary>
            Release the mutex lock and returns the status passed unless Exceptions_On_Error
            is true and the status is bad, in which case a custom exception will be thrown.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.Fire_Event``1(System.Object,System.EventHandler{``0},``0)">
            <summary>
            Use this to fire an event. It ensures the event gets fired on
            the UI thread if available.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.USBDetached">
            <summary>
            Fired when a specific adapter is detached. The Adapter that was detached
            is available via the event args. At this point actions performed on the
            Adapter should fail. If SAA is later re-attached, the USBReattached will
            be fired and actions such as get/set should again succeed.
            <para/>
            This event is for FYI only. You do not need to do anything to recreate
            the SMBusAdapter object or such when the SAA is re-attached.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.USBReattached">
            <summary>
            Fired when a specific adapter is re-attached. The Adapter that was re-attached
            is available via the event args. At this point the Adapter is ready to go and
            actions performed on the Adapter should succeed. 
            <para/>
            This event is for FYI only. You do not need to do anything to recreate
            the SMBusAdapter object or such.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.ControlLineUpdated">
            <summary>
            Fired after a call to getControl() and Set_Control() when a CONTROL value read
            differs from the previous value read/written for the specified line/default.
            So no true polling is done of the line, but if you simply re-read
            the line in any type of polling loop you will get events fired
            on updates. 
            <para/>
            An initial event is fired the first time a value is set or read,
            setting the initial value. The event args contains the line number that was 
            updated.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.SMBusAlertLineUpdated">
            <summary>
            Fired after a call to Get_SMBus_Alert() when the value read differs from the previous 
            value read. So no true polling is done of the line, but if you simply re-read
            the alert line in any type of polling loop you will get events fired
            on updates. 
            <para/>
            An initial event is fired the first time Get_SMBus_Alert() is called.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.Warning">
            <summary>
            A USB warning even, including attach/detactch information included in the
            USBDetach and USBReattached. Useful mostly for debugging USB problems.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.RequestComplete">
            <summary>
            Fired whenever there is a transaction on the SAA. For example,
            Read_Byte or Write_Word or even Set_Control. Only fired when there
            is true SAA communication. Not when something cached is returned
            or some call does not actually operate on the SAA.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.SettingUpdated">
            <summary>
            Fired when PEC, mode, or speed is updated.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.RemotingServerMessage">
            <summary>
            Debug messages fired by a remoting server. Static so that they can be
            received by the server UI, and not the client.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SMBusAdapter.AdapterFound">
            <summary>
            Fired when an adapter has been found.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Adapters">
            <summary>
            A list of SMBusAdapter instances for the SAAs that were
            found when SMBusAdapter.Discover() was called. This 
            property will return an empty -- but defined -- list
            if no SAAs were found.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Adapter">
            <summary>
            The USB adapter specified by the Default Adapter Number  default is the first adapter found. This Will return null if Discover() was never
            called or was unable to find any adapters. 
            multiple adapters.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Default_Adapter_Num">
            <summary>
            API calls that use SMBAdapter.Adapter which will use the default adapter number specified here.
            adapters are numbered starting from 1. 
            Default is 1.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Number">
            <summary>
            SAA identifer. Automatically set when Discovered. Numbering starts
            at 1.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Is_Attached">
            <summary>
            Returns true if the low-level driver is attached to the SAA
            previously found. If not, then all reads/writes will fail automatically
            with the error AdapterDetached. Not all drivers support this. If 
            a driver does not support this, true is always returned.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Num_Adapters">
            <summary>
            The number of SAA adapters that were found.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Num_Control_Lines">
            <summary>
            The number of control lines this adapter supports for
            Set_Control() / getControl().
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Version">
            <summary>
            Returns the USB adapter version. Cached. Returns null if there
            was an error retrieving. To force refresh of the version from
            the adapter, set to null.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Remoting_Host">
            <summary>
            When Is_Remoting_Client is true, this is the name or IP address of
            the remote server.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Remoting_Port">
            <summary>
            When Is_Remoting_Client is true, this is port number of the remote server.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver_Factories">
            <summary>
            The low-level adapter drivers that are loaded and used when Discover()
            is called. 
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver">
            <summary>
            The low-level adapter driver that is being used for this SMBusAdapter
            object.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver_SAA">
            <summary>
            Driver cast as the USB-TO-GPIO adapter driver. Will return null if other
            driver is being used.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver_Number">
            <summary>
            Drivers may support multiple physical adapters. If they do, Discover()
            can return a number greater than 1. An SMBusAdapter is created for
            each 
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver_SMBus">
            <summary>
            Driver cast as an ISMBusAdapterDriver. Will return null if it is not.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.Driver_I2C">
            <summary>
            Driver cast as an II2CAdapterDriver. Will return null if it is not.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingServerMessageCategory.Server">
            <summary>
            High-level server statuc messages: client connect, SAA discovery, etc.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingServerMessageCategory.Request">
            <summary>
            Low-level debug of every SAA request.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingServerMessageEventArgs.Category">
            <summary>
            Server (high-level, minimal messages) or request (low-level, lots of messages).
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingServerMessageEventArgs.Type">
            <summary>
            Normal, Warn, and Error can be generated.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingServerMessageEventArgs.Request">
            <summary>
            If Category is Request, this will contain detailed info about the request.
            Same as the event args for the standard SMBusAdapter.RequestComplete event.
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.RemoteAdapterHelper">
            <summary>
            Provides remoting-specific adapter services. The client uses this
            to authenticate against the server and determine the number of adapters 
            on the server. There is only one RemoteAdapterHelper shared between client
            and server, while there may be mutliple SMBusAdapter instances, each
            representing a single USB adapter attached to the server PC.
            </summary>
            <remarks>
            A key implementation detail is that client and server each have unique static
            members.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.RemoteAdapterHelper.#ctor(System.String)">
            <summary>
            Throws an exception if the password does not match the servers.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.RemoteAdapterHelper.Discover">
            <summary>
            Performs actual discovery on the server. The list of adapters is cached
            on the server and also returned to the client. The list will be empty --
            but not null -- if no adapters are found.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingTransportMode.TCP">
            <summary>
            Recommended transport. Same speed as UDP in tests, but has more error
            checking of TCP. 
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RemotingTransportMode.HTTP">
            <summary>
            Not rcommended. > 2x slower than UDP or TCP in tests.
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.MajorSettings">
            <summary>
            Encapsulates the bus speed, PEC mode, and serial/parallel mode in a single
            struct. 
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.MajorSettings.PEC">
            <summary>
            Returns null if the API has never been used to turn PEC on/off. I.e. we
            don't know what the current state on the SAA is.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.MajorSettings.Mode">
            <summary>
            Returns null if the API has never been used to set parallel or serial mode. I.e. we
            don't know what the current state on the SAA is.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.MajorSettings.Speed">
            <summary>
            Returns null if the API has never been used to set the bus speed. I.e. we
            don't know what the current state on the SAA is.
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.SetMajorResult">
            <summary>
            Returns by one of the Set_Major_Settings() calls.
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.SAARequestID">
            <summary>
            Host (PC) -> USB adapter commands. The value of the enum is the 
            actual SAA operation cmd_code sent to the SAA.
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.RequestException">
            <summary>
            When SMBusAdapter.Exceptions_On_Error is set to true, this
            exception is thrown on error. The Message property will detail
            what went wrong. The Status field gives the reason for the
            error.
            <para/>
            The Status, Status_String, Request, or Message properties can be used to
            access additional infromation about the exception. Request
            is something like "SendByte." Message is something like
            "Send_Byte(address=11) error: NACK".
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestException.Status">
            <summary>
            The status cmd_code enumeration. Status_String should be what you
            present to the user, log, etc.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestException.Request">
            <summary>
            What kind of request this was. For example, SendByte or SetPecMode.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestException.Status_String">
            <summary>
            Usually "NACK", but might be "USB ERROR" or other short string. Based
            on Status.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestException.Message">
            <summary>
            Something like "Send_Byte(address=11) error: NACK."
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ControlLineUpdatedEventArgs.Line">
            <summary>
            Line number from 1 to 5.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.ControlLineUpdatedEventArgs.Msg">
            <summary>
            Something like "CONTROL1 now High".
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.SMBusAlertLineUpdatedEventArgs.Msg">
            <summary>
            Something like "SMBALERT# now Low".
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.USBDetachedEventArgs.Msg">
            <summary>
            Returns "USB SAA detached".
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.USBReattachedEventArgs.Msg">
            <summary>
            Returns "USB SAA re-attached".
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestType.Read">
            <summary>
            Read from bus, get signal line state, etc.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestType.Write">
            <summary>
            Write to bus, set signal line state, etc.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestType.WriteRead">
            <summary>
            Process call.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Request">
            <summary>
            A unique identifier for the SAA request.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.SMBus_Address">
            <summary>
            Address for the transaction. May be null when not
            appropriate.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.SMBus_Command">
            <summary>
            Command cmd_code for transaction. May be null when not
            appropriate.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.SMBus_Sub_Command">
            <summary>
            Sub Command cmd_code for transaction. Used in ProcessCall. May be null when not
            appropriate.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.SMBus_Data">
            <summary>
            The data sent or received. May be null on error or commands like
            SendByte.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Status">
            <summary>
            Response cmd_code. Status_String provides a user friendly
            description.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Received">
            <summary>
            A textual description of what was received should the command
            read something, either from a device or a setting/etc. from
            the SAA.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Payload">
            <summary>
            A short text summary of what was sent or received to/from the SAA.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Message">
            <summary>
            A summary of the request. For example, "Address 49 ReadByte: ACK [0x00]".
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Is_SAA_Settings_Request">
            <summary>
            Returns true if the request SAA request was either SetBusSpeed or EnablePec.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Is_Bus_Read">
            <summary>
            Returns true if the request is an SMBus or I2C read.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Is_Bus_Write">
            <summary>
            Returns true if the request is an SMBus or I2C write.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.RequestCompleteEventArgs.Is_Success">
            <summary>
            Returns true when Status is SAAStatus.Success.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ServerOptions.Transport">
            <summary>
            Whether to use UDP, TCP, or HTTP. Default is TCP.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ServerOptions.Password">
            <summary>
            Optional password of the server
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ServerOptions.Port">
            <summary>
            IP port of the server. Default is 8090.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.ClientOptions.Host">
            <summary>
            Hostname or IP address of the server. For example, "localhost" or "192.168.1.1".
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.ClientOptions.Host_And_Port">
            <summary>
            Returns something like 111.222.333.444:8888.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SMBusAdapter.SAARequest.Debug_Received">
            <summary>
            Used to build up the RequestEventArgs. This is what was received from
            the SAA.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SMBusAdapter.SAARequest.ToString">
            <summary>
            Just returns Request_String.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.SAARequest.Is_Wire_Request">
            <summary>
            Returns true if this is a request that will result in a 
            read or a write on the wire, in parallel or serial mode.
            I.e. not just setting PEC in the adapter or some such
            </summary>
        </member>
        <member name="P:TIDP.SAA.SMBusAdapter.SAARequest.Debug_Prefix">
            <summary>
            Used to build up the RequestEventArgs. 
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusAdapter.MutexLocks">
            <summary>
            Handles creating mutex (cross-process) lock, with multiple locks supported 
            via key argument. Allows Release() to be called more than once, ignoring
            second call. This is accomplished by use of per-thread sub-key used to
            keep track of whether Release() has been called yet on the mutex previously
            locked. 
            </summary>
        </member>
        <member name="T:TIDP.SAA.SMBusOfflineAdapter">
            <summary>
            An ISMBusAdapter that is offline: all calls will return bad status.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.TIMEOUT">
            <summary>
            Timeout in milliseconds for a request. If 0, bad SAA firmware could
            freeze the GUI. Slight CPU overhead for supplying a timeout. No
            SAA FW currently hangs the GUI, so leaving "off" (0) for now.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Version_Acceptable">
            <summary>
            The minimum SAA firmware version that can be successfully used
            with TIDP applications.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Version_Acceptable_And_Dont_Offer_Upgrade">
            <summary>
            If the firmware is this and less than Version_Recommended, we allow
            it and don't offer to upgrade the user.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Version_Recommended">
            <summary>
            The recommended SAA firmware version to use with TIDP applications.
            </summary>
            <remarks>
            Search for _bin resource if you change this.
            </remarks>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Version_With_Parallel_Mode">
            <summary>
            The minimum SAA firmware version that supports parallel mode.
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Version_Supports_58_Bytes_Data">
            <summary>
            SAA firmware version that supports up to 58 data bytes length
            </summary>
        </member>
        <member name="F:TIDP.SAA.SAADriver.Log">
            <summary>
            How many times to retry a an SAA request failure when 
            Retry_On_Failure is > 0. Default is 2.
            This setting applies to all adapters.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Finalize">
            <summary>
            in case someone forgets to call the dispose
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Read_Firmware_Image(System.String)">
            <summary>
            Reads the Intel style firmware image and returns the bytes. Throws
            an exception on any error, with inner exception giving more detail.
            </summary>
            <remarks>
            The returned array will be sized exactly to the size of the firmware image bytes.
            </remarks>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Download_Firmware(System.String,System.Boolean)">
            <summary>
            Downloads the SAA firmware file and optionally validates the image by reading
            it back from the SAA and comparing against what was written. If there was any
            error, including a validation error, an exception will be thrown. Check the
            inner exception for more detail.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Download_Latest_Firmware(System.Boolean)">
            <summary>
            Downloads the latest SAA firmware recommended for I2C/SMBus/PMBus
            use. This firmware is embedded in this assembly and thus no 
            external files are needed. This is the same version defined by the
            Version_Recommended constant.
            </summary>
            <exception cref="T:System.Exception">
            An exception is thrown on any error, possibly with an inner exception
            with additional detail.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Download_Firmware(System.Byte[])">
            <summary>
            Downloads a previously read firmware image. See 
            Download_Firmware(filename, read_back_validate) for easy interface.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any error.
            </exception>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Verify_Firmware_On_SAA(System.String)">
            <summary>
            Verifies that the firmware file passed is what is loaded in the
            SAA's firmware EEPROM. Throws an exception if the firmware file
            passed can not be read, the firmware image can not be
            read from the SAA, or it does not match (ex.Message will have detail
            and possibly an inner exception).
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Verify_Firmware_On_SAA(System.Byte[])">
            <summary>
            Verifies that the firmware image data passed is what is loaded in the
            SAA's firmware EEPROM. Throws an exception if the image can not be
            read or it does not match (ex.Message will have detail).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TIDP.SAA.SAADriver.I2C_Read(System.Byte,System.Byte,System.Int32,System.Byte[]@)" -->
        <!-- Badly formed XML comment ignored for member "M:TIDP.SAA.SAADriver.I2C_Write(System.Byte,System.Byte,System.Int32,System.Byte[])" -->
        <member name="M:TIDP.SAA.SAADriver.Recreate">
            <summary>
            Tries to create a new low-level HID device.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Read_Firmware_Image(System.IO.Stream)">
            <summary>
            Throws exception on error. Closes stream always.
            </summary>
        </member>
        <member name="M:TIDP.SAA.SAADriver.Get_Signal(System.Int32,TIDP.SAA.LogicLevel@)">
            <summary>
            Gets SMBALERT# (index 5) or control line (index 0-4).
            </summary>
        </member>
        <member name="E:TIDP.SAA.SAADriver.FirmwareDownloadProgress">
            <summary>
            When Firmware_Download() is used to upgrade the SAA, this event is fired
            to keep tabs on the progress.
            </summary>
        </member>
        <member name="E:TIDP.SAA.SAADriver.FirmwareVerifyProgress">
            <summary>
            When Verify_Firmware() is used to verify a firmware download or Firmware_Download()
            was called with the verify option, this event is fired to keep tabs on the progress.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SAADriver.Firmware_Upgrade_Required">
            <summary>
            Returns true if this SAA should have it's firmware upgraded to be
            compatible with TIDP applications. This is true when the firmware
            version can not be read or is &lt; Version_Acceptable, a constant.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SAADriver.Firmware_Upgrade_Recommended">
            <summary>
            Returns true if it is recommended that this SAA have it's firmware upgraded. 
            See Firmware_Upgrade_Required. This is true when the firmware
            version is &lt; Version_Recommended, a constant.
            </summary>
        </member>
        <member name="P:TIDP.SAA.SAADriver.USB_Pathname">
            <summary>
            Returns a device pathname for the USB adapter associated with this SMBusAdapter. 
            </summary>
        </member>
        <member name="T:TIDP.SAA.SAADriver.SAAResponseID">
            <summary>
            Set of response codes that can be received from the SAA
            after a request is sent.
            </summary>
        </member>
    </members>
</doc>
