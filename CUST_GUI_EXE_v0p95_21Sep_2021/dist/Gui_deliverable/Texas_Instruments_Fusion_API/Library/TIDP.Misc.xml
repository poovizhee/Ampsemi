<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TIDP.Misc</name>
    </assembly>
    <members>
        <member name="T:AppSettings">
            <summary>
            This is simply a front-end to System.Configuration.AppSettingsReader because
            Framework 1.x did not have any typed application settings suppport. Also, this
            is not a general prefs persistance system.
            </summary>
        </member>
        <member name="M:BetterArrayList.Join(System.String,System.Collections.ArrayList,System.String)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:TIDP.ColorVSeries">
            <summary>
            Provides some canned color progressions useful when assigning
            different colors to different things (plots, etc). Currently
            supports up to 14 different unique colors before then 
            wrapping around. Use the static Lookup(index) method to get some
            colors that can be used.
            </summary>
            <remarks>
            http://www.centerkey.com/ColorVs/ used to help select ColorVs.
            </remarks>
        </member>
        <member name="F:TIDP.ColorVSeries.Color_Series">
            <summary>
            The actual color series array. This gets defined for you, but
            you could throw it out in your app (but it is static). Use Lookup(i)
            to get a color series for a certain index: it rolls over to the start
            of the series if i >= Num_Unique_Colors.
            </summary>
        </member>
        <member name="M:TIDP.ColorVSeries.Lookup(System.Int32)">
            <summary>
            Find colors to use for the assuming a progression from a 0
            point. If the number is greater than the number of unique 
            colors, colors will be reused modulo style.
            </summary>
        </member>
        <member name="F:CommandRunner.Buffer_Output">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:CommandRunner.Log">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandRunner.Run(CommandRunner.CommandInfo,CommandRunner.RunMode,System.Action)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandRunner.Output_Thread_Mgr_OnDone(ThreadManager,ThreadManager.OnDoneEventArgs)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandRunner.Finished">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="E:CommandRunner.OnStdout">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:CommandRunner.CommandInfo">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:ThreadManager.Log">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:ThreadManager.Cancel_All">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:ThreadManager.Log_Executing_Requests">
            Misc '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:ThreadManager.Worker">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:ThreadManager.Thread_Wrapper">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="E:ThreadManager.OnError">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="P:ThreadManager.Num_Active_Threads">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:ThreadManager.ThreadState">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:ThreadManager.Delegate_Raise_OnError">
            OnError() Support ''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:ThreadManager.Delegate_Raise_OnCancelled">
            OnCancelled() Support ''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:ThreadManager.Delegate_Raise_OnDone">
            OnDone() Support ''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:CommandOutputThreadManager.Exit_Code">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:CommandOutputThreadManager.Log">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandOutputThreadManager.Monitor(System.Diagnostics.Process)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandOutputThreadManager.Worker">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:CommandOutputThreadManager.Thread_State">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="E:CommandOutputThreadManager.OnStdout">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:CommandOutputThreadManager.OnOutputEventArgs">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:CommandOutputThreadManager.MyThreadState">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:CommandOutputThreadManager.Delegate_Raise_OnOutput">
            OnStdout/OnStderr() Support ''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:DateTimeUtils.Timespan_To_Text(System.TimeSpan,DateTimeUtils.TimespanToTextMode)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:DateTimeUtils.Timespan_To_Text2(System.TimeSpan,DateTimeUtils.TimeSpanFormat2)">
            <summary>
            Tweaks TimeSpan.ToString() output from [-][d.]hh:mm:ss[.fff] to one of [-][d+]hh:mm:ss[.fff],
            [-][d+]hh:mm:ss, or [-][d+][hh:]mm:ss depending on opts. 
            </summary>
        </member>
        <member name="M:DateTimeUtils.Timespan_To_Text2(System.TimeSpan)">
            <summary>
            Tweaks TimeSpan.ToString() output from [-][d.]hh:mm:ss[.ff] to one of [-][d+]hh:mm:ss.
            </summary>
        </member>
        <member name="M:DateTimeUtils.Timestamp_For_File(System.DateTime)">
            <summary>
            Returns a formatted version of the specified DateTime suitable for inclusion in
            a filename. Key is ":" is not used, and instead "." is. Example is
            "2006.08.01-03.15.01".
            </summary>
            <param name="Date_Time"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:DateTimeUtils.Timestamp_For_File">
            <summary>
            Returns a Timestamp_For_File formatted version of the current date and time.
            For example, 2006.08.01-03.15.01.
            </summary>
            <returns></returns>
        </member>
        <member name="M:DateTimeUtils.Timestamp_For_Log">
            <summary>
            Returns the current date/time formatted for use in log files and such. Example:
            "2006-08-01 03:15:01.210", where 210 is the number of millseconds.
            </summary>
        </member>
        <member name="M:DateTimeUtils.Timestamp_For_Log(System.DateTime)">
            <summary>
            Returns the date/time formatted for use in log files and such. Example:
            "2006-08-01 03:15:01.210", where 210 is the number of millseconds.
            </summary>
        </member>
        <member name="T:DateTimeUtils.TimespanToTextMode">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:HTMLUtils.Dot_Sep">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:HTMLUtils.Copy_HTML_To_Clipboard(System.String,System.String)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:HTMLUtils.Strip_Markup(System.String)">
            <summary>
            Works by first removing all balanced tags like &lt;a href='url'&gt;&lt;b&gt;foo&lt;/b&gt;&lt;/url&gt;
            to foo; then removes all remaining tags like &lt;br&gt; or &lt;br/&gt;.
            </summary>
        </member>
        <member name="M:HTMLUtils.Strip_Markup2(System.String)">
            <summary>
            Similar to Strip_Markup(), but replaces &lt;br&gt; and &lt;br/&gt; with a single newline and
            &lt;p&gt; pr &lt;p/&gt; with a double newline.
            </summary>
            <param name="Str"></param>
        </member>
        <member name="M:HTMLUtils.Tooltip_Span(System.String,System.String,System.String,System.Boolean,System.Nullable{TIDP.ColorV})">
            <summary>
            Creates an HTML span that, when inserted into a TIWebBrowser, will automatically show
            a cool DevEx tooltip baloon when moused over. You can specify tooltip_title and/or
            tooltip_text.
            </summary>
        </member>
        <member name="F:Logger.Global_Do_Heartbeats">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:Logger.Capture_Debug_To_Level">
            <summary>
            What log level to map Debug.WriteLine() messages to. Default is
            LogLevel.DEBUG.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Logger.Capture_Trace_To_Level">
            <summary>
            What log level to map Trace.WriteLine() messages to. Default is
            LogLevel.INFO.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Logger.Caller_Name">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:Logger.#cctor">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:Logger.Heartbeat">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:Logger.Real_Log(LogLevel,System.Object)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="E:Logger.Message">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:Logger.MessageEventArgs">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:TIDP.Memory.MemoryMapInput.MD5_Checksum">
            <summary>
            Calculate the MD5 checksum of the combined map and pp files or buffers.
            </summary>
        </member>
        <member name="F:MiscUtils.Mutexes">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:MiscUtils.Launch_Command(System.String,System.Object[])">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:MiscUtils.Concat_Exceptions(System.Exception)">
            <summary>
            Returns the exception .Message text concatened together for the outer and
            all inner exceptions. Format is ex1.Message; ex2.Message; ex3.Message; ...
            Does not include any "Exception has been thrown by the target of an invocation"
            message, as this is not useful and is generated when using reflection to 
            execute a method.
            </summary>
        </member>
        <member name="M:MiscUtils.Concat_Stack_Traces(System.Exception)">
            <summary>
            Returns the exception .Message text and stack trace for the outer and
            all inner exceptions. Format is:
               ex1.Message
               ex1.StackTrace
                  ex2.Message
                  ex2.StackTrace
                     ...
            </summary>
        </member>
        <member name="F:SimpleDataTable.Log">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:SimpleDataTable.#ctor">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:SimpleDataTable.Add_Column(System.String)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:SimpleMutex.Name">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:SimpleMutex.Mutex">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:SimpleMutex.#ctor(System.String)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:SimpleMutex.Aquire(System.Int32)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:TIDP.SMBusCRC8Calculator">
            <summary>
            CRC8 checksum calculator. This is used by TIUtils.SMBus_CRC8().
            </summary>
        </member>
        <member name="M:TIDP.SMBusCRC8Calculator.Reset">
            <summary>
            CRC verification, establishes the verification value
            </summary>
        </member>
        <member name="M:TIDP.SMBusCRC8Calculator.Crc(System.Byte,System.Byte)">
            <summary>
            8 CRC verifications have the verification code to need to verify the code and the verification code
            </summary>
            <param name= " CRC " ></param>
            <param name= " OldCRC " > initial is 0, later for returns value ret </param>
            <returns> has when the verification code ret is verification code </returns>
        </member>
        <member name="M:TIDP.SMBusCRC8Calculator.Crc(System.Int32)">
            <summary>
            8 CRC verifications have the verification code, so long as is verified the code
            </summary>
            <param name= " bval " ></param>
        </member>
        <member name="M:TIDP.SMBusCRC8Calculator.Crc(System.Collections.Generic.IList{System.Byte})">
            <summary>
            8 CRC verifications have the verification code, so long as is verified byte array
            </summary>
            <param name= " buffer " ></param>
        </member>
        <member name="M:TIDP.SMBusCRC8Calculator.Crc(System.Collections.Generic.IList{System.Byte},System.Int32,System.Int32)">
            <summary>
            8 CRC verifications have the verification code to the byte array which, the outset result position and the byte length verifies
            </summary>
            <param name= " buf " ></param>
            <param name= " off " ></param>
            <param name= " len " ></param>
        </member>
        <member name="P:TIDP.SMBusCRC8Calculator.Value">
            <summary>
            returns to the CRC8 verification result;
            </summary>
        </member>
        <member name="T:TIDP.CommandLineProgramOptions">
            <summary>
            Use this as the base class for your command line program (or
            consider PMBusDeviceToolOpts for a device oriented command line
            program). See FusionX0ToHexOpts project for example of basic 
            command line program. FusionParamWriter is an example that 
            sub-classes from PMBus versions of these classes to provide 
            built-in ability to handle device scanning and options. 
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgramOptions.Args">
            <summary>
            Leftover command line args that are not switches or switch
            arguments. Will be null if there are none.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgramOptions.Original_Args">
            <summary>
            The original, un-modified command line args.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgramOptions.Descriptions">
            <summary>
            Provides an easy way to define option descriptions programatically
            vs. the attribute approach. This may be useful when reusing option
            description text from somewhere else. The key of the class is the
            dash-dash style argument name. For example "my-arg".
            </summary>
        </member>
        <member name="P:TIDP.Misc.Compiler.Is_NeverEx_Mode">
            <summary>
            Returns true if the NEVEREX compile macro is set and some exceptions
            will not be trapped like they normally are.
            </summary>
        </member>
        <member name="T:TIDP.CompressUtils">
            <summary>
            GZip compress and decompress helper functions.
            </summary>
        </member>
        <member name="T:TIDP.HexFormat">
            <summary>
            Hex string formatting style.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.CoderUpper">
            <summary>
            0x0F, 0x9AD0, etc.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.CompactUpper">
            <summary>
            0F, 9AD0, etc.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.DashUpper">
            <summary>
            0F, 9A-D0, etc.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.CoderDashUpper">
            <summary>
            0x0F, 0x9A-0xD0, etc.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.ASCIIDump">
            <summary>
            An ASCII representation of each byte. If the byte is
            an unprintable character, the . is used instead.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.MultiLine">
            <summary>
            A multiline format suitable for printing. 0: 9A\n1: D0 etc. The
            index is printed first and is pad spaced so that all output
            aligns. NO leading or trailing newline is added to the output:
            newlines are only added between bytes.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.CoderUpperCommaSeparatedList">
            <summary>
            "0x9A,0xD0,0xAB" or "0x0F". A comma separated list of bytes suitable
            for driving creating of C/C# code.
            </summary>
        </member>
        <member name="F:TIDP.HexFormat.a">
            <summary>
            This is to avoid a deserialize problem caused by not having this
            marked serializable and some prefs will have this. We force back to
            CoderUpper in the DeviceExport prefs that was exposed. Will eventually remove.
            </summary>
        </member>
        <member name="T:TIDP.HexParseException">
            <summary>
            Hex parsing routines such as BitUtils.Parse_Hex_Byte will throw this
            exception if the hex string is not in a valid format. May also be thrown
            by other functions when the hex data is not in the expected size.
            </summary>
        </member>
        <member name="T:TIDP.TIException">
            <summary>
            An Exception with an easy to use constructor that accepts format strings like
            new TIException("bad number {:N}", number).
            </summary>
        </member>
        <member name="F:TIDP.Stopwatch._Start_Time">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:TIDP.Stopwatch.#ctor">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:TIDP.Stopwatch.Start">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="P:TIDP.Stopwatch.Start_Time">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="F:StringMacro._Template">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:StringMacro.#ctor">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="M:StringMacro.Replace(System.String,System.Object)">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="P:StringMacro.Template">
            '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
        </member>
        <member name="T:TIDP.UInt32AddressRangeList">
            <summary>
            A list of 32-bit address ranges. The Contains() and Find()
            methods can be used to see if an address is in one of the
            ranges.
            </summary>
        </member>
        <member name="T:TIDP.TIList`1">
            <summary>
            A customized generic List. Some of the more useful features
            include ToString() and Join(), which have customizable string formatting.
            The First and Last properties are simple but useful. Provides
            built-in support for shallow or deep cloding.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the list that is empty and has 
            the specified initial capacity
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            If create_null_elements is true, elements will be created via
            default(T) for each element in the array. 
            </summary>
            <remarks>
            This you could do
            <code>
            TIList&lt;MyClass&gt; list = new TIList&lt;MyClass&gt;(3, true);
            list[0] = new MyClass("a");
            list[1] = new MyClass("b");
            list[2] = new MyClass("c");
            </code>
            See Grow() for how to to do the same thing after construction.
            </remarks>
        </member>
        <member name="M:TIDP.TIList`1.Copy">
            <summary>
            Returns a shallow copy of the list. If you have sub-classed TIList and want to get back the
            same type as your sub-class, you will want to Clone() instead, as it returns an instance of 
            the sub-class vs. this always returns a TIList&lt;T&gt;. 
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Clone(TIDP.CloneMode)">
            <summary>
            Creates a clone of the list. The clones type will be the same as the underlying type
            of your list. For example, if you sub-classed TIList, then a sub-class will be
            created. The return type is IList&lt;T&gt;, allowing easy iteration over the clone
            without casting back to it's native type. Can be a shallow or "deep" clone. The
            meaning of deep depends on all of the nested T.Clone() implementations, as all
            this function does is call IClonable.Clone() on the items in this list when
            mode=Deep. The virtual protected After_Clone() method is called after the clone
            is performed to give a sub-class a channce to do something custom clone-wise, such
            as clone any non-elements properties/fields.
            </summary>
            <param name="mode">
            When Shallow, a reference copy of each item is added to the new list object created. 
            When Deep, a one-level deep clone is done by calling ICloneable.Clone()
            on each item in the list. If the T type that is stored in the list does not support IClonable
            and mode is Deep, an exception is thrown.
            </param>
            <exception cref="T:System.Exception">
            Thrown if there is no default constructor for the list class or mode is Deep but
            T does not implement IClonable.
            </exception>
        </member>
        <member name="M:TIDP.TIList`1.Grow(System.Int32)">
            <summary>
            Adds null (via default(T)) delements to the array
            as necessary to make it the specified size.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Add(`0[])">
            <summary>
            Returns the last item added.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Join(System.String)">
            <summary>
            Joins the ToItemString() version of each element, seperated by sep.
            See ToString(sep, empty_string) and others for an alternative which 
            gives you much more control over formatting, including custom 
            ToItemString() formatting.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Join(System.String,System.String)">
            <summary>
            Joins the ToItemString() version of each element, seperated by standard_sep.
            The last element is seperated by sep_for_last_string. For example,
            Join(", ", " and ") with list {"a", "b", "c"} returns "a, b and c".
            See ToString(sep, empty_string) and others for an alternative which 
            gives you much more control over formatting, including custom 
            ToItemString() formatting.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToString">
            <summary>
            Returns "&lt;empty&gt;" (or whatever EmptyString() returns if sub-classed) if the 
            list is empty. If not empty returns the ToItemString() version of each element separated by
            ", ". For example, "1, 2, 3".
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToString(System.String,System.String,TIDP.TIList{`0}.FormatItemDelegate)">
            <summary>
            If the list is empty, empty_string is returned. Otherwise, format_item_delegate(item) is
            used to format each element. The concatenation is separated by join_string.
            IncludeInToString() is called to determine whether an item should be included
            in the summary. The default implementation includes every element.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToString(System.String,System.String,TIDP.TIList{`0}.FormatItemDelegate,TIDP.TIList{`0}.IncludeItemDelegate)">
            <summary>
            If the list is empty, empty_string is returned. Otherwise, format_item_delegate(item) is
            used to format each element. The concatenation is separated by join_string.
            include_item_delegate(item) is called to determine whether an item should be included
            in the summary.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToString(System.String,System.String)">
            <summary>
            If the list is empty, empty_string is returned. Otherwise, ToItemString() is
            used to format each element. The concatenation is separated by join_string.
            IncludeInToString() is called to determine whether an item should be included
            in the summary. The default implementation includes every element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIList`1.ToHTML">
            <summary>
            Returns "&lt;empty&gt;" (or whatever EmptyHtmlString() returns if sub-classed) if the 
            list is empty. If not empty returns the ToItemHtmlString() version of each element separated by
            ", ". For example, "1, 2, 3".
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToHTML(System.String,System.String)">
            <summary>
            If the list is empty, empty_string is returned. Otherwise, ToItemHtmlString() is
            used to format each element. The concatenation is separated by join_string.
            IncludeInToString() is called to determine whether an item should be included
            in the summary. The default implementation includes every element.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIList`1.ToItemString(System.Int32)">
            <summary>
            Provides a way for a list to provide a custom way to format the text that
            is displayed by ToString(). The default implementation simply
            returns item.ToString().
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.ToItemHTML(System.Int32)">
            <summary>
            Provides a way for a list to provide a custom way to format the text that
            is displayed by ToHTML(). The default implementation returns ToItemString(item).
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.FindIndexByReference(`0)">
            <summary>
            If the passed item can be found in the list, returns it's index. Otherwise,
            returns -1. Uses reference equality (ReferenceEquals).
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.FindIndexByValue(`0)">
            <summary>
            If the passed item can be found in the list, returns it's index. Otherwise,
            returns -1. Uses value equality (Equals).
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Replace(`0,`0)">
            <summary>
            Replaces the old_item with new_item. Returns false if
            old_item can not be found. Uses reference equality to look for
            old_item.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Move_Backward(`0)">
            <summary>
            If item is found, it is moved to the start of the array (0 index). If the item can not be
            found, false is returned. If the item is already at 0, an exception
            is thrown.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Move_Forward(`0)">
            <summary>
            If item is found, it is moved to the end of the array (Count-1). If the item can not be
            found, false is returned. If the item is already at the end of the array, an exception
            is thrown.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes one or more items from the list.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.Remove_First">
            <summary>
            Removes the first item from the list (index 0) and returns it.
            </summary>
            <returns>The item removed.</returns>
            <exception cref="T:System.Exception">Thrown if the list is empty.</exception>
        </member>
        <member name="M:TIDP.TIList`1.Remove_Last">
            <summary>
            Removes the last item from the list (index Count-1) and returns it.
            </summary>
            <returns>The item removed.</returns>
            <exception cref="T:System.Exception">Thrown if the list is empty.</exception>
        </member>
        <member name="M:TIDP.TIList`1.IncludeInToString(System.Int32)">
            <summary>
            Used by ToString() to determine whether an item should be included in the
            ToString() list. Default implementation returns true.
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.EmptyString">
            <summary>
            Used by ToString();
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.EmptyHtmlString">
            <summary>
            Used by ToHtmlString();
            </summary>
        </member>
        <member name="M:TIDP.TIList`1.After_Clone(TIDP.CloneMode,System.Collections.Generic.IList{`0})">
            <summary>
            Called by built-in Clone(CloneMode) function. Gives you an oppurtunity to
            do some after all items have been added to the clone. 
            </summary>
        </member>
        <member name="P:TIDP.TIList`1.Last">
            <summary>
            Get/set the last item in the list. Throws an exception if the
            list is empty.
            </summary>
        </member>
        <member name="P:TIDP.TIList`1.First">
            <summary>
            Get/set the first item in the list. Throws an exception if the
            list is empty. 
            </summary>
            <remarks>
            This is really much less useful than Last, but
            since we did it, this is here for completeness.
            </remarks>
        </member>
        <member name="P:TIDP.TIList`1.Length">
            <summary>
            Returns Count. Provided for easy swap between real [] arrays and
            TIList.
            </summary>
        </member>
        <member name="M:TIDP.UInt32AddressRangeList.#ctor(System.String)">
            <summary>
            Creates an address range list based on a string of the
            form "startaddr-endaddr[,startaddr-endaddr,...]". 
            For example, "0x200-0x2FF,0x400-0x5FF". Throws an
            exception on any parse error.
            </summary>
        </member>
        <member name="M:TIDP.UInt32AddressRangeList.Contains(System.UInt32)">
            <summary>
            Returns true if one of the ranges contains the specified
            address.
            </summary>
        </member>
        <member name="M:TIDP.UInt32AddressRangeList.Find(System.UInt32)">
            <summary>
            Finds the first range that holds the specified address.
            Returns null if there is none.
            </summary>
        </member>
        <member name="T:TIDP.UIThreadEventRaiser">
            <summary>
            Used to fire an event (handler delegate) on the UI thread. You must construct 
            this from within a UI thread -- within a forms event handler for example -- for
            it to work correctly.
            </summary>
        </member>
        <member name="M:TIDP.UIThreadEventRaiser.Define_Context(System.Threading.SynchronizationContext)">
            <summary>
            This must be called from within a form or user control to set
            Context, giving us a way to marshal delegates onto UI thread.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if there is an error getting a UI context. Usually this
            means you called Define_Context() outside of a 
            </exception>
        </member>
        <member name="M:TIDP.UIThreadEventRaiser.Raise``1(System.Object,System.EventHandler{``0},``0)">
            <summary>
            Use this to fire an event. It ensures the event handlers (callbacks) 
            gets fired on the correct thread. Callbacks are fired individually
            so that we can trap an error in any one handler and not cause all
            handlers to be skipped if there is an exception within any one.
            The event will be dispatched synchronously.
            </summary>
        </member>
        <member name="T:TIDP.ValueToMultiTagLookupTable`1">
            <summary>
            A lookup table where integer values (Value) map to something else (Tag). That something
            else might not be a unique value, and its type is T.
            </summary>
            <remarks>
            Useful for a table like the following:
            <example>
            111xx: +9.00%
            11011: +8.25%
            ...
            10001: +0.75%
            10000: +0%
            01111: −0%
            01110: −0.75%
            ...
            00100: −8.25%
            000xx: −9.00%
            </example>
            In above the Value is the binary number and the Tag is the percentage, probably
            represented as a string.
            </remarks>
        </member>
        <member name="F:TIDP.ValueToMultiTagLookupTable`1.Table">
            <summary>
            The underlying table.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Add(System.Int32,`0)">
            <summary>
            Adds an item to the lookup table. 
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Find_Tag(`0)">
            <summary>
            Finds table entries with the specified tag. Returns an empty list if there
            are no matches.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Find_Value(System.Int32)">
            <summary>
            Finds the table entry with the specified integer value. Returns null
            if there is no entry.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.ToDetailedString">
            <summary>
            Returns the every item newline separated in a string.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Write_Table(TIDP.LineOutput,System.Boolean)">
            <summary>
            Write the table's contents to an already opened LineOutput.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Write_Table(TIDP.LineOutput)">
            <summary>
            Write the table's contents to an already opened LineOutput. Includes a header
            describing each column.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Format_Tag(`0)">
            <summary>
            Used by Write_Table(). Override for custom formatting of tag.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.Format_Value(System.Int32)">
            <summary>
            Used by Write_Table(). Override for custom formatting of the integer value.
            The default is just int.ToString().
            </summary>
        </member>
        <member name="P:TIDP.ValueToMultiTagLookupTable`1.Length">
            <summary>
            Number of items in the table.
            </summary>
        </member>
        <member name="P:TIDP.ValueToMultiTagLookupTable`1.Min_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            smallest/lowest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="P:TIDP.ValueToMultiTagLookupTable`1.Max_Value">
            <summary>
            Shortcut for Table.Last.Value. Useful via the INumericLookupTable interface.
            </summary>
        </member>
        <member name="P:TIDP.ValueToMultiTagLookupTable`1.Max_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            largest/highest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="M:TIDP.ValueToMultiTagLookupTable`1.TableItem.CompareTo(TIDP.ValueToMultiTagLookupTable{`0}.TableItem)">
            <summary>
            Compares numerically on Value.
            </summary>
        </member>
        <member name="T:TIDP.ExportData">
            <summary>
            Base class for a save/export XML file. 
            </summary>
        </member>
        <member name="F:TIDP.ExportData.Version">
            <summary>
            File format/schema version number. Provides a way to verify we can
            import a file still. Automatically set in the constructor.
            </summary>
        </member>
        <member name="F:TIDP.ExportData.Timestamp">
            <summary>
            When the file was created. Automatically set in the constructor.
            </summary>
        </member>
        <member name="F:TIDP.ExportData.Creator">
            <summary>
            Usually the program that created the file, including version number.
            </summary>
        </member>
        <member name="P:TIDP.ExportData.Is_Current_Version">
            <summary>
            Returns true if the version in this file matches the latest, which is
            set by overloading Current_Version. 
            </summary>
        </member>
        <member name="P:TIDP.ExportData.Current_Version">
            <summary>
            Overload this in your sub-class and update as formats become
            incompatible.
            </summary>
        </member>
        <member name="T:TIDP.ClientIPServerSinkProvider">
            <summary>
            A SinkProvider that provides access to client IP address. Access the
            IP from your server code via the static IP property provided by this
            class.
            </summary>
            <remarks>
            From http://stackoverflow.com/questions/527676/.
            <example>
            var bp = new BinaryServerFormatterSinkProvider();
            var csp = new ClientIPServerSinkProvider();
            csp.Next = bp;
            var props = new Hashtable();
            props.Add("port", "1234");
            var channel = new TcpChannel(ht, null, csp);
            ChannelServices.RegisterChannel(channel, false);
            ...
            </example>
            </remarks>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.Tools_Dir">
            <summary>
            You can set this to the directory where the diff.exe tool
            is located. If not set, the directory where the invoking EXE
            is will be assumed.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.Memory_Address_Ranges">
            <summary>
            Defines memory address ranges. For example, 0x1000-0x1FFF might map to RAM, 0x2000-0x2FFF might
            map to registers, 0x3000-0x3FFF to data flash, and 0x4000-0x4FFF again to registers. 
            </summary>
            <remarks>
            You should assign a new MemoryAddressRanges instance to this field in your sub-class. The
            default implementation returns "RAM" for all addresses.
            </remarks>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.Cpp_And_Map_Cache_Dir">
            <summary>
            If this is set, an MD5 checksum will be calculated for the combined pp and map input. If a cached
            version of the parsed pp and map data can be found in the cache dir, it will be used. This saves
            considerable startup time for certain large sets of pp files (for example, 100,000 lines). If there
            is no cache hit, the specified cache folder will be created if necessary and the map/pp data will
            be saved to an XML file in this folder. This will be a serialization of a SavedCppAndMap class 
            instance.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.Enable_Diff_Optomized_Mode">
            <summary>
            When true and a diff.exe exists in Tools_Dir, all parsing of pp 
            files will be optomized: a diff will be done between the larges 
            files and all other files. For the other files, only differences 
            between largest and the other file will be parsed, to cut down 
            on duplicates and wasted processing time.
            </summary>
            <remarks>
            NOT 100% RELIABLE. DO NOT USE.
            </remarks>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Read">
            <summary>
            Refreshes reading in memory for all nodes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Write(TIDP.Memory.WriteMode,System.Boolean)">
            <summary>
            Performs a conditional write. See WriteMode enum values for a description of modes. 
            If there are any write errors, an exception is thrown. 
            </summary>
            <param name="clear_byte_to_write">
            When true, the Byte_To_Write field at each address will be cleared
            on successful write.
            </param>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Save_XML(System.String)">
            <summary>
            Saves the memory map to an XML file. This is simply a serialization of this
            class. Note that the Parent property of each node is skipped, as this would be
            recursive.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any I/O error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Save_ASCII_Tree(System.String)">
            <summary>
            Saves the memory map as an ASCII tree. Same as writing ToString() to a file.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any I/O error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Save_Unknown_Variables(TIDP.LineOutputFormat,System.String)">
            <summary>
            Saves a list of the unknown variables to a text file. Simple wrapper for 
            debugging.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any I/O error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Save_Memory_Allocation_Report(TIDP.LineOutputFormat,System.String)">
            <summary>
            Saves an HTML report summarizing mapped / unmapped memory to a file. Only reports
            on those memory types passed. Throws an exception on any I/O error. 
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Addresses(System.Collections.Generic.IList{TIDP.Memory.CMemoryMap.MemoryNode},System.Boolean)">
            <summary>
            Returns a sorted list of unique memory addresses in the 
            supplied MemoryNodeList.
            </summary>
            <param name="memory_nodes">
            Must be flat. We do not recurse into the nodes.
            </param>
            <param name="leaf_nodes_only">
            Given this list contains A, A.B, A.B.C1, A.B.C2, if leaf_nodes_only 
            is true we will only return the addresses for C1 and C2, assuming
            C1 and C2 are a primitive type, enum, or bit field. If false, 
            the memory locations that A and A.B span will also be returned.
            </param>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Memory_Type(System.UInt32)">
            <summary>
            Returns the type of memory the specified address holds. Returns MemoryType.Unknown if the
            adress dies not fall into a known range.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Import(System.String)">
            <summary>
            Imports (writes to device) all non-null memory locations previously
            saved to the specified file. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Ignore_Unknown_Variable(TIDP.Memory.CMemoryMap.UnknownVariable)">
            <summary>
            Allows sub-class to prune the Unknown_Variables list.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Validate_Map">
            <summary>
            Throws an exception if any one leaf node maps to the same memory address.
            For example, a final element in an array overlaps with an adjacent 
            variable. This would indicate an error in parsing of the cpp file.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Union_Sub_Node_Could_Be_Removed(TIDP.Memory.CMemoryMap.MemoryNode)">
            <summary>
            Used when MapMode is SimplifyUnions. This function gets passed
            a non-bitfield node to determine whether it would be OK to
            remove it from the map in favor of a bit field struct. The
            default implementation looks 
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.Include_Address(System.UInt32)">
            <summary>
            Provides a way to filter out certain addresses.
            </summary>
            <returns>Return true to include the address.</returns>
        </member>
        <member name="E:TIDP.Memory.CMemoryMap.MemoryRead">
            <summary>
            Fired when the memory that is behind this node is read. This does 
            not mean an actual change took place. For example,
            the same value may have been read as last time.
            </summary>
        </member>
        <member name="E:TIDP.Memory.CMemoryMap.MemoryWrote">
            <summary>
            Fired when the memory that is behind this node is written. This does 
            not mean an actual change took place. For example,
            the same value may have been written as was previously known to be on
            the device.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Unknown_Variables">
            <summary>
            A list of variables that were not found in the cpp passed
            to the constructor. It is in the .map file, but missing from 
            the .pp file. Sorted by address.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Variables">
            <summary>
            Top-level recursive list of memory nodes: the variables defined in the map file
            that were found in the Cpp file. This is a tree-like data 
            structure that can be traveresed to determine all child
            types defined within these variables. Sorted alphabetically (A-Z, then a-z).
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Variables_By_Address">
            <summary>
            Similar to Variables, but sorted by address. Of course both share the same
            underlying objects, just different sort order of the container list.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Variable_Nodes">
            <summary>
            Flattened list of all variable nodes, sorted alphabetically (A-Z, then a-z).
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Variable_Paths">
            <summary>
            This sorted dictionary maps full node pathname (using the
            Key property of each node) to the associated node. It is 
            sorted by pathname. It only contains known varibles. So it 
            ultimately has the same nodes contained in Variable_Nodes. 
            A shortcut to Map.Variable_Paths["foo.bar[0,0]"] is 
            Map["foo.bar[0,0]"];
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Device_Memory">
            <summary>
            Provides read/write access to memory in nodes. This is optional,
            and would have been passed to the constructor.
            </summary>        
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Item(System.String)">
            <summary>
            Quick access to Variable_Paths[path]. Throws an exception on 
            unknown path.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Lowest_Address">
            <summary>
            Lowest memory address.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Highest_Address">
            <summary>
            Highest memory address.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Has_Comments">
            <summary>
            Whether at least one memory node has a Comment field defined.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Opts">
            <summary>
            The map options passed in when it was constructed.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.Address_Size">
            <summary>
            Number of bytes in the address.
            </summary>
        </member>
        <member name="T:TIDP.TISortedDictionary`2">
            <summary>
            A customized generic SortedDictionary, which is a dictionary sorted on the key. 
            Cloneable and has an indexer,
            Value_Or_Default(key), that will return the default value of TValue if the key does
            not exist. Also serializable as XML, which the standard sorted dictionary is not.
            </summary>
            <remarks>
            IXmlSerializable implementation from Paul Welter @ 
            http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
            </remarks>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Add(`1,`0[])">
            <summary>
            Defines key/value pairs for any number of keys, with the values
            of each set to the passed value.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Value_Or_Default(`0)">
            <summary>
            If the key exists, returns the associated value. If it does not exist,
            returns default(TValue). For a class, this returns null. For a value
            type, returns 0, "", etc.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Value_Or(`0,`1)">
            <summary>
            If the key exists, returns the associated value. If it does not exist,
            returns the supplied fallback.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Copy">
            <summary>
            Makes a shallow clone.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Clone_Keys">
            <summary>
            Makes a shallow clone of the keys, so that you can iterate over them
            and change the underlying hash.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Clone_Values">
            <summary>
            Makes a shallow clone of the values, so that you can iterate over them
            and change the underlying hash.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Find(`1[])">
            <summary>
            Uses reference comparison to return a list of keys that contain the
            specified value(s) passed. No duplicates will be in the list of keys
            returned.
            </summary>
            <param name="values">One or more values. Can be null for reference types.</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Find_First(`1)">
            <summary>
            Returns the key associated with the first value found. Since a value can map to multiple keys,
            only use this if you are sure there is a 1:1 relationship between key and value. Throws an 
            exception if not found.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Set_Keys(`1,`0[])">
            <summary>
            Loops through the keys passed and sets the value for each to the value
            passed.
            </summary>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.Clone(TIDP.CloneMode,TIDP.CloneMode)">
            <summary>
            Creates a clone of the SortedDictionary. The clones type will be the same as the underlying type
            of your dictionary. For example, if you sub-classed TISortedDictionary, then a sub-class will be
            created. The return type is ISortedDictionary&lt;TKey,TValue&gt;, allowing access to the clone's
            memvers without casting back to it's native type. You have control over whether the key or
            value components are shallow or "deep" clones. The meaning of deep depends on all of the 
            nested T.Clone() implementations, as all this function does is call IClonable.Clone() on 
            the items in this list when mode=Deep.
            </summary>
            <remarks>
            When a mode is Shallow, a reference copy of each item is used when creating the dictionary clone. 
            When Deep, a one-level deep clone is done by calling ICloneable.Clone()
            on the key of value. If the T type that is stored in the list does not support IClonable
            and mode is Deep, an exception is thrown. The virtual protected After_Clone() method is called after the clone
            is performed to give a sub-class a channce to do something custom clone-wise, such
            as clone any non-elements properties/fields.
            </remarks>
            <exception cref="T:System.Exception">
            Thrown if there is no default constructor for the list class or mode is Deep but
            T does not implement IClonable.
            </exception>
        </member>
        <member name="M:TIDP.TISortedDictionary`2.After_Clone(TIDP.CloneMode,TIDP.CloneMode,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Called by built-in Clone(CloneMode) function. Gives you an oppurtunity to
            do some after all items have been added to the clone. 
            </summary>
        </member>
        <member name="T:TIDP.Memory.CMemoryMap.MemoryCollision">
            <summary>
            Included in a MemoryCollisionException.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryCollision.Address">
            <summary>
            Memory address the collision is at.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryCollision.Offset">
            <summary>
            Pointer-style offset within an array.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryCollision.ID">
            <summary>
            Variable identifier.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryCollision.ToString">
            <summary>
            Returns something like "Address 0X11223344: foo_bar, offset 1".
            </summary>
            <returns></returns>
        </member>
        <member name="T:TIDP.Memory.CMemoryMap.MemoryCollisionException">
            <summary>
            This exception is thrown if multiple variable nodes map to the same
            memory address. This should normally only occur if the wrong setting
            for XXX is used.
            </summary>
        </member>
        <member name="T:TIDP.Memory.CMemoryMap.MemoryAddressRanges">
            <summary>
            A list of memory address ranges. Each range -- such as 0x0000 to 0x1000 -- is defined 
            as holding a specific type of memory: RAM, register, data flash, etc. CMemoryMap sub-classes 
            normally add to this to reflect target device by calling the Add() method.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryAddressRanges.Find(System.UInt32)">
            <summary>
            Finds an address range with the specified starting address. Returns null
            if it is not in one of the ranges.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryAddressRanges.Find_Type(System.UInt32)">
            <summary>
            Finds an address range with the specified starting address and returns its
            MemoryType enumeration. Returns MemoryType.Unknown if it is not in one of \
            the ranges.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNode.Parent">
            <summary>
            Parent node. Null for top-level variables.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNode.Array_Item">
            <summary>
            If this is an element in an array, this will be non-null and will
            contain information about the position within the parent array.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNode._Memory">
            <summary>
            Access to memory only for our device.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNode.Device_Memory">
            <summary>
            Access to all device memory.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.To_Bytes(System.Nullable{System.UInt32})">
            <summary>
            Creates an array Num_Bytes wide that holds value. Returns null if value is null.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.To_UInt32(System.Byte[])">
            <summary>
            Converts the "encoded" byte[] array to a UInt32.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Set_Memory_Bytes(System.Byte[])">
            <summary>
            Sets the Byte_To_Write in Memory from the supplied byte[] array.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Set_Memory_UInt32(System.UInt32)">
            <summary>
            Sets the Byte_To_Write in Memory from the supplied UInt32. The # bytes
            in memory for this node may be less. If you pass a value that can not
            fit in the # bytes -- or bits for a bit field -- an exception will be
            thrown.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Get_Memory_Bytes(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Converts the underlying memory to an array of bytes.
            You specify what field within MemoryByte to extract via
            field. If a byte has never been read/written, null is 
            returned.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Get_Memory_UInt32(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Converts the underlying memory to a UInt32. You specify 
            what field within MemoryByte to extract via field. 
            If a any one byte has never been read/written, null is 
            returned. An exception will be thrown if the memory
            is > 4 bytes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Get_Memory_UInt32">
            <summary>
            Converts the underlying memory to a UInt32. Returns the "Read"
            field. If a any one byte has never been read/written, null is 
            returned. An exception will be thrown if the memory
            is > 4 bytes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Get_Memory_String(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Returns something like "0xAABBCC" or, if any one byte has never been read, something
            like "0xAA??CC".
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Is_Dirty">
            <summary>
            Uses ToWriteSet DirtyMode: a write is pending if any one 
            Byte_To_Write under the node is non-null.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Is_Dirty(TIDP.Memory.DirtyMode)">
            <summary>
            See DirtyMode enum values for explanation of modes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Read">
            <summary>
            Updates memory with latest value found on the device. If this
            node represents a nested data structure, the read takes place
            accross the entire structure, but in the most efficient
            manner. For example, if this is a 4 element array of bytes,
            a single read of 4 bytes might be done.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any read error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Write(TIDP.Memory.WriteMode)">
            <summary>
            Conditionally writes all memory locations at and below this node.
            If this node represents a low-level entry in a bit field, the
            entire bit field is written. See WriteMode for an explanation.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any read error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Export(System.String)">
            <summary>
            Saves the current read state of this node (and below) nodes to
            an XML file. Does not read nodes. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.ToString">
            <summary>
            Returns a string like cla_gains[3,2].POS_MID_GAIN_MULT [55:50]; 
            addr=0x00019141; last read: 0x8; previous read: 0x?; last written: 
            0x?; to write: 0x?.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.ToString(System.Boolean)">
            <summary>
            Returns a summary of the node's name, address. If 
            include_memory_on_simple_types is true, the memory
            cache state is included. So for example, 
            cla_gains[3,2].POS_MID_GAIN_MULT [55:50]; addr=0x00019141; 
            last read: 0x8; previous read: 0x?; last written: 
            0x?; to write: 0x?.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Dump_Flat">
            <summary>
            Recursively dumps the ToWriteOrLastRead value of this node and below to a mult-line string.
            Any memory that has not been previously read will be read. But cached
            read memory is used when available. The output is similar to the "flat"
            mode of the debugger GUI.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Dump_Tree">
            <summary>
            Recursively dumps the ToWriteOrLastRead value of this node and below to a mult-line string.
            Any memory that has not been previously read will be read. But cached
            read memory is used when available. The output is similar to the "tree"
            mode of the debugger GUI.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Dump(System.Boolean,System.Boolean)">
            <summary>
            Recursively dumps the ToWriteOrLastRead value of this node and below to a mult-line string.
            Unlike Dump_Flat() and Dump_Tree(), exposes options for how to handle
            unread memory and whether to use tree or flat mode.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Dump(TIDP.Memory.DeviceMemory.FieldID,System.Boolean,System.Boolean)">
            <summary>
            Recursively dumps the specified memory field to a mult-line string.
            Unlike Dump_Flat() and Dump_Tree(), exposes options for how to handle
            unread memory and whether to use tree or flat mode.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Decoded(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Returns the decoded version of the specified field. Returns null if the complete memory
            has not been read. Throws an exception for nodes where Decoded state do not make sense
            (array, struct, etc.).
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNode.Decoded_String(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Returns the formatted decoded version of the specified field. Returns "---" if the complete memory
            has not been read. Throws an exception for nodes where Decoded state do not make sense
            (array, struct, etc.).
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Num_Bytes">
            <summary>
            The size of the underlying data structure. For pointers -- Is_Pointer is true -- 
            always returns the pointer address size.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Num_Bytes_String">
            <summary>
            Returns something like "1 byte" or "4 bytes".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Max_Encoded_Value">
            <summary>
            For primitive types, bit fields, and enums, the maximum encoded value supported. For
            a bit field, takes into account the bit length. Throws an exception
            when accessed for arrays, structs, and unions.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Max_Decoded_Value">
            <summary>
            For primitive types, bit fields, and enums, the maximum decoded value supported. For
            a bit field, takes into account the bit length. Takes into account signed primitives
            like Int16. Throws an exception when accessed for arrays, structs, and unions.
            Also takes into account "C" comment hint "[max=value]".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Min_Decoded_Value">
            <summary>
            For primitive types, bit fields, and enums, the minimum decoded value supported. For
            a bit field, takes into account the bit length. Takes into account signed primitives
            like Int16. Throws an exception when accessed for arrays, structs, and unions.
            Also takes into account "C" comment hint "[min=value]".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.End_Address">
            <summary>
            Calculated from Start_Address and Num_Bytes.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.ID">
            <summary>
            A unique identifier for this memory node. These are numbered
            starting at 0 in increasing order in memory.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Name">
            <summary>
            The low-level variable/register name. If an identifier was originally a
            C# reserved keyword such as "byte", it will be converted to upper case
            automatically.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Name_With_Index">
            <summary>
            The ID for this lowest level item, plus optional array indexes. For example,
            "foo[0,0,0]" for the first element in a three demensional array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Name_With_Index_And_Path">
            <summary>
            Full hierachical item name, including parent. For example,
            "my_array[0,0,0].my_struct.my_field". For bit fields, includes
            bit index range. For example, "AdcRegs.ADCCTRL1.ADC_ENA [0:0]".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Key">
            <summary>
            Similar to Name_With_Index_And_Path, but does not include 
            bit field indexes. So for example, this returns
            "AdcRegs.ADCCTRL1.ADC_ENA" instead of "AdcRegs.ADCCTRL1.ADC_ENA [0:0]".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Comment">
            <summary>
            Source code comment for this node. May be empty.
            </summary>            
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Type_String">
            <summary>
            A description of the node's type. For example "Bit Fields",
            "Enum MY_ENUM", and "Array UInt16[10]".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Size_String">
            <summary>
            Returns size as a string. Something like "1 byte", 
            "2 bytes", or "4 bits."
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Children">
            <summary>
            Untyped access to child nodes. Returns null if there can't be any
            children for this type of node, and an empty list if there are
            no children (empty struct or union, for example). Child classes
            have strongly typed versions of this with the name "Children2."
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Data_Type">
            <summary>
            An instance of a DataType class for this node's type, or
            null if not applicable. Child classes may have more specific 
            version called Data_Type2.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Memory">
            <summary>
            Memory for this node. Always a list of DeviceMemory.MemoryByte objects. 
            These objects are always the same for the lifetime of a CMemoryMap instance. 
            At the byte level we keep track of whether an item has been read, at
            what time, etc. Low-level Bit fields -- BitFieldItemNode -- do not have
            bytes since they are just components of an overall BitFieldsNode. In this
            case null is returned.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Memory_Map">
            <summary>
            The memory map that this node is in.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Unread">
            <summary>
            True when any one Byte has not been read yet.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Read_Update">
            <summary>
            True when any one Byte_Read differs from Previous_Byte_Read, and both
            are non-null (ie there have been two reads on the device).
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Encoded_User_Editable">
            <summary>
            Whether the user should be allowed to edit the memory in a debugger GUI.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Decoded_User_Editable">
            <summary>
            Whether there is a way to edit the node in "decoded" form. 
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Memory_Is_Addressable">
            <summary>
            Returns whether we can set memory (encoded values) directly for this item, or
            whether we need to go through the decoded value or through the parent. This
            is true for BitFieldItemNode, since this represents an item in a bit field.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Memory_Type">
            <summary>
            Returns the type of memory this node is: register, RAM, dflash, pflash, or unknown.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Register">
            <summary>
            Returns true if the memory associated with this node
            is in IC register space.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Variable">
            <summary>
            Returns true if the memory associated with this node
            is in RAM or flash variable space.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Pointer">
            <summary>
            Is this actually a pointer to another area in memory?
            </summary>            
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Is_Const">
            <summary>
            Is this a constant and should not be editable?
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNode.Hints">
            <summary>
            Certain nodes -- top-level primitives and struct bitfields -- can
            have additional hints about their makeup/use inside of a "C" comment.
            This will return these hints if available. Will return null if
            hints don't make sense for the specified node or the node did not
            contain any hints. Inside the FieldHints object, individual hints 
            such as "Minumum" can still be null if the user did not specify.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldsNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldsNode.Was_Promoted">
            <summary>
            True if this bit fields parent node was promoted up a level via union
            simplification.
            </summary>            
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.BitFieldItemNode.Offset_From_Address">
            <summary>
            This is the offset from the Address field, not the start of the structure.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.BitFieldItemNode.Offset_From_Parent">
            <summary>
            This is the offset from the parent bit fields node, not the start of the structure.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.BitFieldItemNode.Offset_From_Struct">
            <summary>
            This is the offset from the structure top.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.Get_Memory_UInt32(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Extracts only our bits from overall memory allocated to the bit field group this
            bit field item is in. For example, if the bit field has a:5 and b:3, Get_Memory()
            on b would extract the 3 bits and return as a UInt32.
            </summary>
            <returns>
            Returns null if any one byte in the parent bit fields has not been read yet.
            </returns>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.Get_Memory_Bytes(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            See Get_Memory(). This version returns a byte array that is sized/indexed according to the
            number of bytes THIS bit field can hold, not the parent. 
            </summary>
            <returns>
            Returns null if any one byte in the parent bit fields has not been read yet.
            </returns>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.Get_Memory_String(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Returns the bit field item as a string. If it is null, returns "0x?".
            Otherwise, returns something like "0x7".
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.Set_Memory_Bytes(System.Byte[])">
            <summary>
            See Set_Memory_To_Write(). You pass a byte[] array in this version.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.BitFieldItemNode.Set_Memory_UInt32(System.UInt32)">
            <summary>
            Updates Byte_To_Write in parent bit fields node, inserting into it. If to "to write"
            value has been set for the parent yet, copies the last read value before inserting
            out bits. If no read has occured either, we set parent byte(s) to be 0x00 before
            inserting value.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldItemNode.Num_Bits_String">
            <summary>
            Returns something like "1 bit" or "4 bits".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldItemNode.Hi_Bit_Index">
            <summary>
            This defines the location of the bit field within the overal bit fields group.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldItemNode.Lo_Bit_Index">
            <summary>
            This defines the location of the bit field within the overal bit fields group.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldItemNode.Num_Bytes">
            <summary>
            Returns the number of bytes that that the bit field fits into. But
            this is only useful for editing purposes.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.BitFieldItemNode.Field">
            <summary>
            The original CTypesAndVariables field information.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.ArrayNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.ArrayNode.Length">
            <summary>
            The total array length. This is Array_Dimensions]0] * Array_Dimensions[1] * 
            ... * Array_Dimensions[n-1]. Will be 0 if the field is not an array. Cached.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.ArrayNode.Length1">
            <summary>
            Just the first dimension (length) of an array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.ArrayNode.Length2">
            <summary>
            Just the second dimension (length) of an array. Returns 0 if
            there is no second dimension.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.ArrayNode.Length3">
            <summary>
            Just the third dimension (length) of an array. Returns 0 if
            there is no third dimension.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.ArrayNode.Field">
            <summary>
            The original CTypesAndVariables field information.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryReadWriteEventArgs.Start_Address">
            <summary>
            For the full read/write, what the starting address was.
            A number of nodes may be under this.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryReadWriteEventArgs.Nodes">
            <summary>
            Nodes that were read or written because of this write.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.BitFields">
            <summary>
            BitFieldsNode -> list of BitFieldItemNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.BitFieldItem">
            <summary>
            BitFieldItemNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.Array">
            <summary>
            ArrayNode -> list of MemoryNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.Struct">
            <summary>
            StructOrUnionNode -> list of MemoryNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.Union">
            <summary>
            StructOrUnionNode -> list of MemoryNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.Enum">
            <summary>
            EnumNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.MemoryNodeType.Primitive">
            <summary>
            PrimitiveNode
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.ArrayItemInfo.Indexes">
            <summary>
            The indexes for this array item. For example, if it is
            {1, 2}, this means this is equivalent to being foo[1][2].
            </summary>
        </member>
        <member name="F:TIDP.Memory.CMemoryMap.ArrayItemInfo.Position">
            <summary>
            Given row-major array layout in memory -- which the C standard
            defines -- this is the position of this item in the overal array.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.ArrayItemInfo.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.StructOrUnionNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.PrimitiveNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.PrimitiveNode.Field">
            <summary>
            The original CTypesAndVariables field information.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.EnumNode.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.EnumNode.Find_Value(System.UInt32)">
            <summary>
            Finds an enum information about the enum from its underlying UIn32 value.
            Returns null if no such value in the enum.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.EnumNode.Find_ID(System.String)">
            <summary>
            Finds an enum information about the enum from the enum value id (FOO1, FOO2, etc).
            Returns null if no such value in the enum.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNodeList.To_Flat">
            <summary>
            Creates a new list that has been "flattened": there are no child nodes, and
            all child nodes become peers of all other nodes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNodeList.Read">
            <summary>
            Refreshes reading in memory for all nodes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNodeList.Addresses(System.Boolean)">
            <summary>
            Returns a sorted list of unique memory addresses in the 
            supplied MemoryNodeList.
            </summary>
            <param name="leaf_nodes_only">
            Given this list contains A, A.B, A.B.C1, A.B.C2, if leaf_nodes_only 
            is true we will only return the addresses for C1 and C2, assuming
            C1 and C2 are a primitive type, enum, or bit field. If false, 
            the memory locations that A and A.B span will also be returned.
            </param>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNodeList.Sort_By_Address">
            <summary>
            Permanently sorts the list by address.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CMemoryMap.MemoryNodeList.Sort_By_Name">
            <summary>
            Permanently sorts the list by variable name.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CMemoryMap.MemoryNodeList.Num_Bytes">
            <summary>
            Calculates the number of bytes under each node. Does not double
            count.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DirtyMode.ToWriteSet">
            <summary>
            A memory byte's Byte_To_Write property has been set to a non-null value.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DirtyMode.ToWriteSetAndDiffers">
            <summary>
            A memory byte's Byte_To_Write property has been set to a non-null value and
            it differs from the value read on the device (or the device byte has never been
            read).
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.FlatFolder">
            <summary>
            Only look in the top-level of the passed Source_Files_Dir.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.IndividualMapAndCppFile">
            <summary>
            A single .map and .pp file is specified using the Map_File and
            Cpp_File fields.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.IndividualMapAndCppStrings">
            <summary>
            The map and pp contents are passed as strings using the
            Map_File and Cpp_File fields.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.SavedCppAndMapXmlFile">
            <summary>
            A previous instance of CMemoryMap/CTypesAndVariables has been
            serialized via SavedCppAndMap. This provides a quick way to
            recreate a debugger API: no map/pp files are necessary and
            it is much faster since all C code parsing has already been done.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.SavedCppAndMapXmlString">
            <summary>
            Same as SavedCppAndMapXmlFile mode, but treat Saved_Cpp_And_Map_Xml_File as
            a string buffer containing XML.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.SavedCppAndMapCompressedXmlBytes">
            <summary>
            Similar to SavedCppAndMapXmlFile mode, but the serialized XML has been
            compressed and saved in a byte[] array via Saved_Cpp_And_Map_Compressed_Xml
            </summary>
        </member>
        <member name="F:TIDP.Memory.SourceFilesMode.UseStockMap">
            <summary>
            Some CMemoryMap sub-classes may support stock, embedded map modes
            instead of finding them on the file system. When this mode is
            specified, the sub-class must do something to translate this
            request to real files.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Memory">
            <summary>
            Optional. If not specified, virtual device memory will be created.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Source_Files_Dir">
            <summary>
            Used when Source_Files_Mode is FlatFolder
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Map_File">
            <summary>
            Used when Source_Files_Mode is IndividualMapAndCppFile or IndividualMapAndCppStrings.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Cpp_File">
            <summary>
            Used when Source_Files_Mode is IndividualMapAndCppFile or IndividualMapAndCppStrings.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Saved_Cpp_And_Map_Xml_File">
            <summary>
            Used when Source_Files_Mode is SavedCppAndMapXmlFile or SavedCppAndMapXmlString.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Saved_Cpp_And_Map_Compressed_Xml">
            <summary>
            Used when Source_Files_Mode is SavedCppAndMapCompressedXmlBytes.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Is_Wrapper_API_Mode">
            <summary>
            We support creating a strong typed C# "wrapper" API that mimics the
            layout of a pp/map combo. This is set to true when creating a map
            to drive this.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Include">
            <summary>
            Allows you to filter the map created. By default includes variables
            and registers.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.Filter_Unknown_Addresses">
            <summary>
            Whether to exclude variables in the pp file that lie in a memory
            address that is not in CMemoryMap.Memory_Address_Ranges. The default
            is true.
            </summary>
        </member>
        <member name="F:TIDP.Memory.MapConstructOptions.CPU_And_Tools">
            <summary>
            The compiler tools and devuce CPU. Tweaks are currently applied
            to the data type mapping and parsing of .map file based on this.
            For example, on MSP430 int is 16-bits. On ARM7 it is 32-bits.
            On ARM7, .map file variable names always have an underscore (_)
            in front of the name. On MSP430 they do not.
            </summary>
        </member>
        <member name="P:TIDP.Memory.MapConstructOptions.Map_Identifiers_Start_With_Underscore">
            <summary>
            Whether .map variable entries start with _. For example:
            0001883c   _pmbus_checksum_b
            or
            0001883c   pmbus_checksum_b.
            The default is true.
            </summary>
        </member>
        <member name="F:TIDP.Memory.WriteMode.ToWriteSetAndDiffers">
            <summary>
            Only write if Byte_To_Write has been set to a non-null value and
            it differs from the value read on the device (or the device byte has never been
            read).
            </summary>
        </member>
        <member name="F:TIDP.Memory.WriteMode.ToWriteSet">
            <summary>
            Only write if a memory byte's Byte_To_Write property has been set to a non-null value.
            </summary>
        </member>
        <member name="F:TIDP.Memory.WriteMode.Force">
            <summary>
            Write to device regardless of whether the Byte_To_Write property has been
            set for a byte. If it has never been set, the value last read is written.
            It is an error to use this mode if the byte has never been read.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DeviceDiscoveryMode.Any">
            <summary>
            Uses whatever mode the device is currently in. So if it
            finds a device in ROM mode, it will use this. If it finds
            a device in program mode, it will use this.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DeviceDiscoveryMode.Rom">
            <summary>
            Looks for a ROM. If found, uses this. If a program is found,
            tries to send to ROM. If unsuccessful, throws an exception.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DeviceDiscoveryMode.Program">
            <summary>
            Looks for a program. If found, uses this. If a ROM is found,
            tries to execute the program and validate it is supported by
            the API. If unsuccessful, throws an exception.
            </summary>
        </member>
        <member name="T:TIDP.Memory.FieldHints">
            <summary>
            Currently UI hints that the C developer can provide via comment tokens.
            This can be applied to a struct or a stand-alone extern variable.
            </summary>
        </member>
        <member name="F:TIDP.Memory.FieldHints.Minimum">
            <summary>
            Minimum value for a field. Null if none specified. 
            </summary>
        </member>
        <member name="F:TIDP.Memory.FieldHints.Maximum">
            <summary>
            Maximum value for a field. Null if none specified. 
            </summary>
        </member>
        <member name="F:TIDP.Memory.FieldHints.Step">
            <summary>
            When user clicks up/down arrow, how much to increment/decrement.
            Null if none specified. See Resolution for alternative.
            </summary>
        </member>
        <member name="F:TIDP.Memory.FieldHints.Resolution">
            <summary>
            When the spin is done, instead of blindly incrementing based 
            on Step, we will instead make sure that the new value 
            aligns to this. For example, if Resolution is 0.5 and the 
            current value is 0.4, when the up spin is done, the new value 
            will be 0.5. Then 1.0, then 1.5, etc. Usually Resolution makes 
            more sense than Step.
            <para/>
            If Resolution is greater than 0, Step is ignored. 
            If zero, Resolution is ignored in favor of Step.
            </summary>
        </member>
        <member name="T:TIDP.Memory.CTypesAndVariables">
            <summary>
            This is a parser for a series of C pre-processed .h files via a 
            compiler .cpp output file. The types (primitives like int, structs, 
            and unions) that are defined are available in Types. The variables 
            that are defined are available in Variables. Bit fields (foo:5), 
            nested declarations (a struct within an array within a union),
            nested types (inner structs or unions), and multi-dimensional 
            arrays are supported. 
            </summary>
            <remarks>
            Only tested against Code Composer 3.x output of UCD3000-based firmware
            (UCD92xx, UCD90xx, and Isolated).
            </remarks>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Types">
            <summary>
            All data types found.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Variables">
            <summary>
            All top-level variables found. Does not include fields inside of a 
            struct, nested, etc. But this are available though the Type property
            for each variable, which is therefore recursive.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Enums">
            <summary>
            All enum typedefs found. These will also be in Data_Types, but are
            available here for easy resolution via the Enums.Find(id) method.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.#ctor">
            <summary>
            Do not call. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.ToString">
            <summary>
            Returns a detailed, mulit-line description of the data types and variables found in the .pp input.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Save_ASCII_Tree(System.String)">
            <summary>
            Saves the types and variables as an ASCII tree. Same as writing ToString() to a file.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Match1(System.String)">
            <summary>
            Pass #1. Separate functions so that we can track CPU % in profiler.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Match2(System.String)">
            <summary>
            Pass #2. Separate functions so that we can track CPU % in profiler.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Outer_Typedef_Evaluator(System.Text.RegularExpressions.Match)">
            <summary>
            Handles converting nested types into non-nested, with inner type names
            being converted to a.b.c notation like C#. This is done in two steps
            (see below).
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Lookback(System.String,System.Text.RegularExpressions.Match)">
            <summary>
            Returns only the last 2000 characters of the text before the match in m. Basically the
            last 4000 characters of $`.
            </summary>
        </member>
        <member name="T:TIDP.Memory.CTypesAndVariables.ArrayLengths">
            <summary>
            Represents the dimensionality of an array.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.ArrayLengths.#ctor">
            <summary>
            For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.ArrayLengths.#ctor(TIDP.Memory.CTypesAndVariables,System.String)">
            <summary>
            Construct based on "[3][5]" style array syntax.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.ArrayLengths.ToString">
            <summary>
            Returns array dimensions comma seperated. Example: 2x3x4.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TIDP.Memory.CTypesAndVariables.Field">
            <summary>
            This represents a field in a struct or a stand-alone extern variable.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Type">
            <summary>
            The data type of this variable/field.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Type_Name">
            <summary>
            The original type name used in the declaration.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Comment">
            <summary>
            Any comment that was present in the declaration. Comment characters
            such as // are removed.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Bit_Length">
            <summary>
            For int foo:5 notation, this would be set to 5. This will be null if
            the field is not bit packed.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Is_Const">
            <summary>
            True if this is a constant.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Is_Pointer">
            <summary>
            True if this is a pointer.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Storage">
            <summary>
            Whether this variable is an extern or static (local to file).
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Array_Dimensions">
            <summary>
            For int foo[2][3], this would be set to (2, 3). This will be null if
            the field is not an array.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.Field.Hints">
            <summary>
            Currently UI hints that the C developer can provide via comment tokens.
            Will be null if there are no hints at all.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.Field.#ctor">
            <summary>
            DO NOT USE. For serialization only.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.ID">
            <summary>
            The identifier of this variable/field. For example, my_var1.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Array_Length">
            <summary>
            The total array length. This is Array_Dimensions]0] * Array_Dimensions[1] * ... * Array_Dimensions[n-1].
            Will be 0 if the field is not an array. Cached.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Num_Bits">
            <summary>
            The full length of the variable, including all children. Cached. Bit fields can have
            Num_Bits that is not modulo 8. For pointers, this uses the
            length of the CPU address, not the underlying data structure.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Num_Bits_String">
            <summary>
            Returns something like "1 bit" or "4 bits".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Num_Bytes">
            <summary>
            The number of bytes this field takes up. For bit fields where Num_Bits is
            not modulo 8, returns ceiling(Num_Bits/8). For pointers, this uses the
            length of the CPU address, not the underlying data structure.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Address_Offset">
            <summary>
            This is the offset of this field from it's parent. In a struct, the
            first item in the struct will always have an Address_Offset of 0.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.Field.Num_Bytes_String">
            <summary>
            Returns something like "1 byte" or "4 bytes".
            </summary>
        </member>
        <member name="T:TIDP.Memory.CTypesAndVariables.FieldList">
            <summary>
            A list of Fields. This is used in two places: a list of all top-level
            variables found, and a list of fields within a struct or union.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.FieldList.Find(System.String)">
            <summary>
            Finds a field with the specified name. Returns null if not found.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.DataType.ToString">
            <summary>
            Returns a custom short description of the data type. For example,
            "Enum my_enum, 1 byte" or "Struct my_struct, 4 bytes."
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Num_Bytes">
            <summary>
            The number of bytes of the data type, including all children. 
            If the type is a primitive type such as char or byte, any filler
            bytes caused by compiler memory allocation is not included. This
            is available via 
            Cached.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Num_Bytes_String">
            <summary>
            Returns something like "1 byte" or "4 bytes".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Is_Struct_Or_Union">
            <summary>
            Is this a struct or union?
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Is_Primitive">
            <summary>
            Is this a primitive data type like an int?
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Is_Primitive_And_Signed">
            <summary>
            Is this a signed data type like int16?
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.DataType.Alias">
            <summary>
            The primary alias for this data type. For example "Uint8". 
            Just returns Aliases[0].
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.StructOrUnionType._Num_Bytes">
            <summary>
            This is public so it can be serialized/de-serialized as part of 
            the "save pre-parsed map/type" stuff.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.StructOrUnionType.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.StructOrUnionType.ToString">
            <summary>
            Returns something like "Struct my_struct, 4 bytes". Adds Comment if
            available.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.StructOrUnionType.Finished_Adding_Fields">
            <summary>
            This is called when all fields have been added to the struct/union type. 
            For structs, it determines the address offset of each field based on 16/32 
            alignment rules and also computes the total number of bytes the struct takes up.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.StructOrUnionType.Num_Bytes">
            <summary>
            Total number of bytes the struct/union takes up. This takes into
            account bit/byte alignment rules, such as when there is a
            Uint16 and then a Unint32. This will have 8 bytes, not 6, due
            to alignment gap.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumType.#ctor">
            <summary>
            Do not call. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumType.ToString">
            <summary>
            Returns something like "Enum my_enum, 1 byte".
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumTypeList.Find_Enum(System.String)">
            <summary>
            Find an enum typedef by the enum ID. Returns null
            if no match.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumTypeList.Find_Value(System.String)">
            <summary>
            Find an enum value by the enum value ID. Returns null
            if no match. For example, given enum MY_ENUM { A, B }
            searching for "A" would return the EnumValue info for 
            MY_ENUM.A.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumValueList.Find(System.String)">
            <summary>
            Looks for an enum value by ID. Returns null if not found.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.EnumValueList.Find(System.UInt32)">
            <summary>
            Looks for an enum value by value. Returns null if not found.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.DataTypeID.Float32">
            <summary>
            32-bit floating point: float in C.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.DataTypeID.Float64">
            <summary>
            64-bit floating point: double in C.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.DataTypeID.Int64">
            <summary>
            64-bit signed integer: long long in C.
            </summary>
        </member>
        <member name="F:TIDP.Memory.CTypesAndVariables.DataTypeID.UInt64">
            <summary>
            64-bit unsigned integer.
            </summary>
        </member>
        <member name="M:TIDP.StringList.#ctor(System.Object[])">
            <summary>
            Adds the ToString() values of the objects specified to the list.
            </summary>
        </member>
        <member name="M:TIDP.StringList.#ctor(System.Collections.IEnumerable)">
            <summary>
            Iterates over the IEnumerable passed and adds the ToString() version of
            each item. If an item is null, adds null instead.
            </summary>
        </member>
        <member name="M:TIDP.StringList.AddRange(System.Object[])">
            <summary>
            Adds the ToString() values of the objects specified to the list.
            </summary>
        </member>
        <member name="M:TIDP.StringList.AddRange(System.Collections.IEnumerable)">
            <summary>
            Iterates over the IEnumerable passed and adds the ToString() version of
            each item. If an item is null, adds null instead.
            </summary>
        </member>
        <member name="M:TIDP.StringList.ToString">
            <summary>
            Returns each line in the string concatenated, with a newline
            added to the end of each. There are other ToString() versions
            that offer more control.
            </summary>
        </member>
        <member name="M:TIDP.StringList.ToString(System.Boolean)">
            <summary>
            Returns each string in the array separated by a
            newline.
            </summary>
        </member>
        <member name="M:TIDP.StringList.ToString(System.String,System.Boolean)">
            <summary>
            Returns the concatenation of each string in the array separated by
            the specified sep string.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.PrimitiveType.#ctor">
            <summary>
            Do not use. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.PrimitiveType.ToString">
            <summary>
            Returns something like "Int32, 4 bytes".
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.PrimitiveType.Max_Decoded_Value">
            <summary>
            Maximum decoded value for this primitive type. Throws an exception for float types.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.PrimitiveType.Min_Decoded_Value">
            <summary>
            Minimum decoded value for this primitive type. Throws an exception for float types.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.PrimitiveType.Equivalent_Type">
            <summary>
            Returns the equivalent .NET type that can be used to represent this
            data type. For example, sbyte for UInt8.
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.PrimitiveType.Is_Float">
            <summary>
            Returns true if this is a floating point type (Float32, etc.)
            </summary>
        </member>
        <member name="P:TIDP.Memory.CTypesAndVariables.PrimitiveType.Is_Integer">
            <summary>
            Returns true if this is an integer type (Int32, UInt32, Int16, etc.)
            </summary>
        </member>
        <member name="M:TIDP.Memory.CTypesAndVariables.DataTypeList.Find(System.String)">
            <summary>
            Finds the data type with the specified name/alias. Returns null if not found.
            </summary>
            <param name="type_alias"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Memory.MemoryUtils.Make_Valid_ID(System.String)">
            <summary>
            Adjusts specified id as necessary to be a valid
            C# identifier.
            </summary>
        </member>
        <member name="M:TIDP.Memory.MemoryUtils.Num_Bytes_String(System.UInt32)">
            <summary>
            Returns something like "1 byte" or "4 bytes".
            </summary>
        </member>
        <member name="M:TIDP.Memory.MemoryUtils.Num_Bits_String(System.Int32)">
            <summary>
            Returns something like "1 bit" or "4 bits".
            </summary>
        </member>
        <member name="M:TIDP.Memory.MemoryUtils.Parse_Number(TIDP.Memory.CTypesAndVariables.DataTypeID,System.String)">
            <summary>
            Parses and converts value to specified data_type. If conversion is not supported
            throws an exception. If cannot be parsed throws an exception.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedCppAndMap.#ctor">
            <summary>
            Do not call. For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedCppAndMap.UnknownVariableList.#ctor">
            <summary>
            For serialization only.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedCppAndMap.KnownVariableList.#ctor">
            <summary>
            For serialization only.
            </summary>
        </member>
        <member name="T:TIDP.Memory.SimulatedDeviceMemory">
            <summary>
            Cached access to addressable, simulated read-writable memory. This is a
            simple sub-class of DeviceMemory. A SimulatedMemoryDriver is created for
            you.
            </summary>
        </member>
        <member name="T:TIDP.Memory.DeviceMemory">
            <summary>
            Cached access to addressable, read-writable memory. 
            </summary>
            <remarks>
            Use Byte(address)
            to access an object for a memory byte. Read() updates the Byte_Read
            and Time_Read property in these. To write data, you set the 
            Byte_To_Write property and then call Write_Dirty() or Write_Force().
            <para/>
            To get read/write events, subscribe to the MemoryRead or MemoryWrote
            events. 
            <para/>
            Internally, a hash table is used to map address to MemoryByte objects.
            MemoryByte instances are only created as they are accessed via Byte
            (address). Num_Addresses returns a count of the number of unique
            addresses ever accessed. Lower_Address and Highest_Address track the
            address range, but there may be gaps within since memory access is
            "random" and not required to be sequential.
            </remarks>
        </member>
        <member name="F:TIDP.Memory.DeviceMemory.Memory">
            <summary>
            Device memory, indexed by 32 bit address.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Num_Write_Pending_Bytes(TIDP.Memory.DirtyMode)">
            <summary>
            Number of bytes that have a write pending (dirty).
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Byte(System.UInt32)">
            <summary>
            Returns info about the byte at this address. If we have never read
            or written to this address or called Byte(address) on the same
            address, a new MemoryByte object is created and added to our internal 
            cache. NO MEMORY IS READ by calling this. It just constructs a 
            "byte" object for a specific memory location and caches the object.
            Thus multiple consumers can point to the same location in memory.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Bytes(System.UInt32,System.Int32)">
            <summary>
            Returns info about a range of bytes in memory. If we have never read
            or written to this address, a new MemoryByte object is created
            and added to our internal cache. NO MEMORY IS READ by calling this.
            It just constructs and caches a number of "byte" objects for a memory
            range and caches the resulting MemoryByte objects. Thus multiple 
            consumers can point to the same location in memory.
            </summary>
            <remarks>
            The MemoryByteList itself is not cached. But this is just a simple
            List&lt;&gt; sub-class.
            </remarks>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Read(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Reads a contiguous series of bytes from the device's memory and
            updates the underlying MemoryByte objects on success. If there are 
            any read errors, an exception is thrown. 
            </summary>
            <param name="clear_byte_to_write">
            When true, the Byte_To_Write field at each address will be cleared
            on successful read.
            </param>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Read(TIDP.Memory.DeviceMemory.MemoryByteList,System.Boolean)">
            <summary>
            Reads the memory for the specified memory locations. Useful
            when you have filtered what memory you are showing to a user
            and just want to read select addresses, but want to do the
            read efficiently so you want to read contiguous blocks. This
            will do as few reads as possible.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Read(TIDP.Memory.CMemoryMap.MemoryNodeList,System.Boolean,System.Boolean)">
            <summary>
            Reads the memory for the specified memory locations. Useful
            when you have filtered what memory you are showing to a user
            and just want to read select addresses, but want to do the
            read efficiently so you want to read contiguous blocks. This
            will do as few reads as possible.
            </summary>
            <param name="leaf_nodes_only">
            This function is primarily used to read from a filtered node tree.
            For example, A, A.B, A.B.C1, A.B.C2. We generally only want to
            read C1 and C2, because A and A.B may actually reference much more
            memory, but we have filtered some of it away. So set leaf_nodes_only
            to true in this case.
            </param>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Write(TIDP.Memory.WriteMode,System.Boolean)">
            <summary>
            Performs a conditional write. See WriteMode enum values for a description of modes. 
            If there are any write errors, an exception is thrown. 
            </summary>
            <param name="clear_byte_to_write">
            When true, the Byte_To_Write field at each address will be cleared
            on successful write.
            </param>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Write(TIDP.Memory.WriteMode,System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Inspects the cached data for the given address range and performs a conditional write
            based on the WriteMode passed. See WriteMode enum values for a description of modes. 
            If there are any write errors, an exception is thrown.
            </summary>
            <param name="clear_byte_to_write">
            When true, the Byte_To_Write field at each address will be cleared
            on successful write.
            </param>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Dirty_Bytes(TIDP.Memory.DirtyMode)">
            <summary>
            Returns a list of pending writes, sorted by address.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Dirty_Bytes(TIDP.Memory.DirtyMode,System.UInt32,System.UInt32)">
            <summary>
            Returns a list of pending writes, sorted by address, within the specifed address range.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Set_Pending(System.String,System.UInt32)">
            <summary>
            Sets the Byte_To_Write starting at target_address. nullable_hex_string
            can be something like 0xAABB??DD, in which case the 3rd byte is skipped.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if there is an error parsing nullable_hex_string.
            </exception>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Set_Pending(System.Nullable{System.Byte}[],System.UInt32)">
            <summary>
            Sets the Byte_To_Write starting at target_address. Any null bytes in
            data are skipped.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.Set_Pending(System.Byte[],System.UInt32)">
            <summary>
            Sets the Byte_To_Write starting at target_address.
            </summary>
        </member>
        <member name="E:TIDP.Memory.DeviceMemory.MemoryRead">
            <summary>
            Fired when memory is successfully read.
            </summary>
        </member>
        <member name="E:TIDP.Memory.DeviceMemory.MemoryWrote">
            <summary>
            Fired when memory is successfully written.
            </summary>
        </member>
        <member name="E:TIDP.Memory.DeviceMemory.MemoryWritePending">
            <summary>
            Fired when Byte_To_Write is updated in a memory segment.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.Lowest_Address">
            <summary>
            Lowest address read or written.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.Highest_Address">
            <summary>
            Highest address read or written.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.Num_Bytes_In_Address_Range">
            <summary>
            Length of the Lowest_Address to Highest_Address address range.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.Num_Byte_Objects">
            <summary>
            Number of unique MemoryByte objects created and cached.
            </summary>
        </member>
        <member name="F:TIDP.Memory.DeviceMemory.FieldID.PreviousReadOrRead">
            <summary>
            If Previous is null, return Read instead.
            </summary>
        </member>
        <member name="T:TIDP.Memory.DeviceMemory.MemoryByteList">
            <summary>
            Represents a list of MemoryByte objects. Implements IList,
            but hides most list interfaces to more easily browse the
            most useful custom members.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByteList.Is_Dirty">
            <summary>
            Uses ToWriteSet DirtyMode: a write is pending if any one 
            Byte_To_Write is non-null.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByteList.Is_Dirty(TIDP.Memory.DirtyMode)">
            <summary>
            See DirtyMode enum values for explanation of modes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByteList.To_Nullable_Byte_Array(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Converts this list of MemoryBytes to an array of bytes.
            You specify what field within MemoryByte to extract via
            field. If a byte has never been read/written, it will be
            null.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByteList.To_Byte_Array(TIDP.Memory.DeviceMemory.FieldID)">
            <summary>
            Converts this list of MemoryBytes to an array of bytes.
            You specify what field within MemoryByte to extract via
            field. If a byte has never been read/written, null is 
            returned.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByteList.Set_To_Write(System.Byte[])">
            <summary>
            Sets the Byte_To_Write from the supplied byte[] array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.MemoryByteList.Is_Read_Update">
            <summary>
            True when any one Byte_Read differs from Previous_Byte_Read, and both
            are non-null (ie there have been two reads on the device).
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.MemoryByteList.Is_Unread">
            <summary>
            True when any one Byte has not been read yet.
            </summary>
        </member>
        <member name="T:TIDP.Memory.DeviceMemory.MemoryByte">
            <summary>
            Represents the data byte at a specific location. You do not construct
            yourself. Just call the Byte(address) method on your DeviceMemory
            object to get the instance for the passed address.
            </summary>
            <remarks>
            Sorts based on Address.
            </remarks>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByte.Is_Dirty">
            <summary>
            Uses ToWriteSet DirtyMode: a write is pending if Byte_To_Write is non-null.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByte.Is_Dirty(TIDP.Memory.DirtyMode)">
            <summary>
            See DirtyMode enum values for explanation of modes.
            </summary>
        </member>
        <member name="M:TIDP.Memory.DeviceMemory.MemoryByte.CompareTo(TIDP.Memory.DeviceMemory.MemoryByte)">
            <summary>
            Compares based on Address.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.MemoryByte.Memory">
            <summary>
            The device memort this byte is a part of.
            </summary>
        </member>
        <member name="P:TIDP.Memory.DeviceMemory.MemoryByte.Is_Read_Update">
            <summary>
            True when Byte_Read differs from Previous_Byte_Read, and both
            are non-null (ie there have been two reads on the device).
            </summary>
        </member>
        <member name="T:TIDP.Memory.EasyMemoryMap`1">
            <summary>
            Base class for a custom, strongly type wrapper class around a
            memory map / memory / device combo. Allows you to do simple 
            device read/writes in terms of the memory map, with Intellisense
            for each node in the map. The XXX class creates C# sub-class of
            this and all nested types based on a map file.
            </summary>
        </member>
        <member name="M:TIDP.Memory.EasyMemoryMap`1.Write_Pending">
            <summary>
            Writes all changes you have made. Throws an exception on error.
            Write does a read back of any node written, so Value and
            Encoded properties for any node will be up-to-date after the 
            write.
            </summary>
        </member>
        <member name="M:TIDP.Memory.EasyMemoryMap`1.Import(System.String)">
            <summary>
            Imports (writes to device) all non-null memory locations previously
            saved to the specified file. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedMemory.Export(System.String,System.String,System.String,System.String,System.String,TIDP.Memory.CMemoryMap.MemoryNodeList)">
            <summary>
            Saves the current read state of the nodes in memory_node_list to
            an XML file. Does not read nodes. Throws an exception on error.
            List will be flattened by this function.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedMemory.Export(System.String,System.String,System.String,System.String,System.String,TIDP.Memory.CMemoryMap.MemoryNode)">
            <summary>
            Saves the current read state of memory_node to
            an XML file. Does not read nodes. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.SavedMemory.Restore(System.String)">
            <summary>
            De-serializes an export XML file.
            </summary>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Read_If_Unread">
            <summary>
            Reads memory for this node if unread. Throws an exception on read error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Read">
            <summary>
            Updates memory with latest value found on the device. If this
            node represents a nested data structure, the read takes place
            accross the entire structure, but in the most efficient
            manner. For example, if this is a 4 element array of bytes,
            a single read of 4 bytes might be done.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on any read error.
            </exception>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Export(System.String)">
            <summary>
            Saves the current read state of this node (and below) nodes to
            an XML file. Does not read nodes. Throws an exception on error.
            To Import, call Import() on your WraperAPI instance.
            </summary>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.ToString">
            <summary>
            Recursively dumps the value of this node and below to a mult-line string.
            Any memory that has not been previously read will be read. But cached
            read memory is used when available. The output is similar to the "flat"
            mode of the debugger GUI.
            </summary>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.ToTreeString">
            <summary>
            Recursively dumps the ToWriteOrLastRead value of this node and below to a mult-line string.
            Any memory that has not been previously read will be read. But cached
            read memory is used when available. The output is similar to the "tree"
            mode of the debugger GUI.
            </summary>
        </member>
        <member name="M:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.ToString(System.Boolean,System.Boolean)">
            <summary>
            Recursively dumps the ToWriteOrLastRead value of this node and below to a mult-line string.
            Unlike Dump_Flat() and Dump_Tree(), exposes options for how to handle
            unread memory and whether to use tree or flat mode.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Encoded">
            <summary>
            Provides access to the node's cached value. On read, returns the
            last value read when Read() or Immediate were invoked. If a read
            has never occured, one is performed. On set, defines data to be 
            written to the device the next time a Write() method is called.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Immediate_Encoded">
            <summary>
            Read/write from/to the device immediately, without need to make any calls.
            The getter calls Read() and then returns Value. The setter sets Value and
            then calls Write() to write out the value you set.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on device read or write error.
            </exception>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.MemoryNodeWrapper.Cache_Summary">
            <summary>
            Returns a summary of the node's name, address, and the memory
            cache state is included. So for example, 
            cla_gains[3,2].POS_MID_GAIN_MULT [55:50]; addr=0x00019141; 
            last read: 0x8; previous read: 0x?; last written: 
            0x?; to write: 0x?.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.BitFieldsNodeWrapper.Value">
            <summary>
            Provides access to the node's cached value. On read, returns the
            last value read when Read() or Immediate were invoked. If a read
            has never occured, one is performed. On set, defines data to be 
            written to the device the next time a Write() method is called.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.BitFieldsNodeWrapper.Immediate_Value">
            <summary>
            Read/write from/to the device immediately, without need to make any calls.
            The getter calls Read() and then returns Value. The setter sets Value and
            then calls Write() to write out the value you set.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on device read or write error.
            </exception>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.BitFieldItemNodeWrapper.Immediate_Value">
            <summary>
            Read/write from/to the device immediately, without need to make any calls.
            The getter calls Read() and then returns Value. The setter sets Value and
            then calls Write() to write out the value you set.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on device read or write error.
            </exception>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.BitFieldItemNodeWrapper.Value">
            <summary>
            Provides access to the node's cached value. On read, returns the
            last value read when Read() or Immediate were invoked. If a read
            has never occured, one is performed. On set, defines data to be 
            written to the device the next time a Write() method is called.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.EnumItemNodeWrapper`1.Immediate_Value">
            <summary>
            Read/write from/to the device immediately, without need to make any calls.
            The getter calls Read() and then returns Value. The setter sets Value and
            then calls Write() to write out the value you set.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on device read or write error.
            </exception>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.EnumItemNodeWrapper`1.Value">
            <summary>
            Provides access to the node's cached value. On read, returns the
            last value read when Read() or Immediate were invoked. If a read
            has never occured, one is performed. On set, defines data to be 
            written to the device the next time a Write() method is called.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.OneDimensionalArrayNodeWrapper`1.Length">
            <summary>
            Number of items in the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.OneDimensionalArrayNodeWrapper`1.Item(System.Int32)">
            <summary>
            Access one of the items in the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.TwoDimensionalArrayNodeWrapper`1.Length1">
            <summary>
            Length of dimension 1 of the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.TwoDimensionalArrayNodeWrapper`1.Length2">
            <summary>
            Length of dimension 2 of the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.TwoDimensionalArrayNodeWrapper`1.Item(System.Int32,System.Int32)">
            <summary>
            Access one of the items in the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.ThreeDimensionalArrayNodeWrapper`1.Length1">
            <summary>
            Length of dimension 1 of the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.ThreeDimensionalArrayNodeWrapper`1.Length2">
            <summary>
            Length of dimension 2 of the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.ThreeDimensionalArrayNodeWrapper`1.Length3">
            <summary>
            Length of dimension 3 of the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.ThreeDimensionalArrayNodeWrapper`1.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Access one of the items in the array.
            </summary>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.PrimitiveNodeWrapper`1.Immediate_Value">
            <summary>
            Read/write from/to the device immediately, without need to make any calls.
            The getter calls Read() and then returns Value. The setter sets Value and
            then calls Write() to write out the value you set.
            </summary>
            <exception cref="T:System.Exception">
            Thrown on device read or write error.
            </exception>
        </member>
        <member name="P:TIDP.Memory.WrapperAPI.PrimitiveNodeWrapper`1.Value">
            <summary>
            Provides access to the node's cached value. On read, returns the
            last value read when Read() or Immediate were invoked. If a read
            has never occured, one is performed. On set, defines data to be 
            written to the device the next time a Write() method is called.
            </summary>
        </member>
        <member name="T:TIDP.NetUtils">
            <summary>
            Network/socket oriented utilities.
            </summary>
        </member>
        <member name="M:TIDP.NetUtils.Lookup_IP">
            <summary>
            Returns an IP address for this host. Returns null if there
            is none, which is unlikely.
            </summary>
        </member>
        <member name="M:TIDP.PathUtils.Create_Temp_Directory">
            <summary>
            Creates a random directory within the system's temp folder. Returns the pathname
            created. Throws an exception if the folder can not be created.
            </summary>
        </member>
        <member name="T:TIDP.TextBlockIndentModes">
            <summary>
            Controls how indenting is performed in the TextBlockFormatter class.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockIndentModes.None">
            <summary>
            Regardless of what Indent is set to, it will be ignored and lines will
            not be indented.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockIndentModes.AllLines">
            <summary>
            Indent will be prepended to both original lines and lines that were
            created because of word wrapping.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockIndentModes.OriginalLinesOnly">
            <summary>
            Indent will only be prepended to the begining of lines as 
            they occured in the original input_string. Lines that are created
            via wrapping will be indented to match the amount of whitespace of Indent.
            This is the default.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockIndentModes.FirstLineOnly">
            <summary>
            The Indent will only appear on the first line.
            All other lines, including lines created via wrapping, will be indented 
            to match the amount of whitespace of Indent.
            </summary>
        </member>
        <member name="T:TIDP.TIBitArray8">
            <summary>
            Sub-class of TIBitArray that is always 8 bits-wide and has ToString()
            that appends "b" to it.
            </summary>
        </member>
        <member name="T:TIDP.TIBitArray">
            <summary>
            Adds some very basic but much needed enhancements to 
            System.Collections.BitArray. Unfortunately, BitArray 
            is sealed and can not be inherited from. If you want
            to access the low-level BitArray we create, use the
            Bits property. You can directly access a particular
            bit using the indexer for this class. For example:
            
               // Create a 3 bit wide bit array with value 0
               TIBitArray bits = new TIBitArray(3);
            
               // Set some bits
               bits[0] = true;
               bits[2] = true;
            
               bits.Int ---> 5
               bits.Byte ---> 5
               bits[4]  ---> Exception
               bits.Byte = 8 ---> Exception
            
            </summary>
            <remarks>
            Provides methods to return a color corresponding to a particular
            bit (i.e. to represent the on/off state). The meaning of
            the "use_id" passed to these methods -- Color_Background(i, use_id)
            and Color_Foreground(i, use_id) -- is up to sub-classes to define 
            except for use 0, which is reserved for use by TIBitArrayControl,
            a WinForms control that can be bound to a TIBitArray.
            <para/>
            The default implementation returns Red/Green for Color_Background and 
            Black for Color_Foreground for all use_ids.
            <para/>
            TODO: implement various And, Or, etc bitwise operation methods
            that exist in BitArray proper.
            </remarks>
        </member>
        <member name="M:TIDP.TIBitArray.Shift(System.Int32,System.Boolean)">
            <summary>
            Left shifts the bit array, effectively removing the entry at
            index.
            </summary>
            <param name="maintain_size">
            If true, the size is maintained and a false element will now be 
            the last element.
            </param>
        </member>
        <member name="M:TIDP.TIBitArray.#ctor(System.Int32,System.UInt64)">
            <summary>
            Creates a TIBitArray of the specified size and initial value.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.#ctor(System.Int32,System.Byte)">
            <summary>
            Creates a TIBitArray of the specified size and initial value.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.#ctor(System.Int32)">
            <summary>
            Creates a TIBitArray of the specified size with all bits set 
            to false.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Label(System.Int32)">
            <summary>
            Returns a label for the specified bit position. Returns
            Formatter.Label() if Formatter is non-null and Label(...)
            returns non-null. Otherwise, returns _Label(...), which can
            be sub-classed.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Label(System.Int32,System.Int32,System.String)">
            <summary>
            Change the label string dynamicly
            </summary>
            <param name="bit_index">bit index in this bit array</param>
            <param name="label_id">1 == Description; 2 == Short Label; 3 == Long Label</param>
            <param name="label_string"></param>
        </member>
        <member name="M:TIDP.TIBitArray.Supported(System.Int32,System.Boolean)">
            <summary>
            Whether the specified bit is supported. Default implemention simply
            returns true. Might be used by formatters.
            The SMBALERT_MASK for the register might have different supported bits
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Reserved(System.Int32)">
            <summary>
            Whether the specified bit is reserved and should really never be set. 
            Default implemention simply returns false. Might be used by formatters.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Color_Background(System.Int32,System.Int32)">
            <summary>
            Returns a background color for a specified "use". 
            See the remarks for details. Returns Formatter.Color_Background() 
            if Formatter is non-null and Color_Background(...)
            returns non-null. Otherwise, returns _Color_Background(...),
            which can be sub-classed.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Color_Foreground(System.Int32,System.Int32)">
            <summary>
            Returns a color to use in cell-based applications where the foreground color
            is the text color. Returns Formatter.Color_Foreground() 
            if Formatter is non-null and Color_Foreground(...)
            returns non-null. Otherwise, returns _Color_Foreground(...),
            which can be sub-classed.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.ToString">
            <summary>
            Returns the simple binary format of the bits in proper
            high -> low order. For example, 110 for decimal 6.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.ToString(TIDP.TIBitArray.StringFormat)">
            <summary>
            Calls ToString(format, "&lt;empty&gt;", ""), unless format is 
            StringFormat.Positions, in which case prefix_if_bits_set will
            be set to "#".
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.ToString(TIDP.TIBitArray.StringFormat,System.String,System.String)">
            <summary>
            Gives you some formatting options.
            </summary>
            <param name="no_bits_set_text">
            Used in Indexes and Positions modes, what to return if no bits
            are set.
            </param>
            <param name="prefix_if_bits_set">
            Used in Indexes and Positions modes, something to prefix before the bit/position
            list if at least one bit is set. Mostly useful in StringFormat.Poisitions mode
            and use "#" so you get something like #1,3.
            </param>
        </member>
        <member name="M:TIDP.TIBitArray.Match(System.Boolean)">
            <summary>
            Count the number of items matching the supplied value.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Indexes">
            <summary>
            An array of the index numbers into this bit array. For example, for
            { 0, 1, 2, 4, 5, 6, 7 } for an 8 bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIBitArray.Indexes_That_Are_Set">
            <summary>
            An array of the indexes that have been set to "1" in the bit array.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.Set_All(System.Boolean)">
            <summary>
            Set the value of all bits to true or false.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray._Label(System.Int32,System.Int32)">
            <summary>
            Returns a label for the specified bit position. The default
            implementation returns "Bit n".
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray._Color_Background(System.Int32,System.Int32)">
            <summary>
            Returns a background color for a specified "use". See the remarks for details.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray._Color_Foreground(System.Int32,System.Int32)">
            <summary>
            Returns a color to use in cell-based applications where the foreground color
            is the text color. The default implementation returns black always.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Bits">
            <summary>
            The underying System.Collections.BitArray used to hold the bits.
            For accessing true/false value of a bit, use the indexer of
            this class instead.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Item(System.Int32)">
            <summary>
            Get or set an individual bit.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Num_On">
            <summary>
            Number of entries in the BitArray that are in the "on" (true) state.
            Calculated. Num_On + Num_Off == Length. See Match(value).
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Num_Off">
            <summary>
            Number of entries in the BitArray that are in the "off" (false) state.
            Calculated. Num_On + Num_Off == Length. See Match(value).
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Max">
            <summary>
            The maximum numeric value this bit array can hold.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.UInt64">
            <summary>
            Set the bits based on the specified bitfield. Extra bits will be silently ignored
            but logged via Logger.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.UInt32">
            <summary>
            Set the bits based on the specified bitfield. Extra bits will be silently ignored
            but logged via Logger.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.UInt16">
            <summary>
            Set the bits based on the specified bitfield. Extra bits will be silently ignored
            but logged via Logger.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Byte">
            <summary>
            Our bits as a byte. Will throw an exception if the value is too large to store in 
            a byte. For example, decimal 260.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Length">
            <summary>
            The number of bits represented.
            </summary>
        </member>
        <member name="P:TIDP.TIBitArray.Formatter">
            <summary>
            Provides an alternative method of defining colors and
            labels for a bit array. If Formatter is not null, the
            Color_Foreground(...), Color_Background(...), and Label(...)
            methods are called first to see if the formatter returns
            a non-null value. If so, it is used instead of the equivalent
            method of TIBitArray.
            </summary>
        </member>
        <member name="F:TIDP.TIBitArray.StringFormat.Binary">
            <summary>
            Example: "110b"
            </summary>
        </member>
        <member name="F:TIDP.TIBitArray.StringFormat.Hex">
            <summary>
            Example: 0x5 if bits 2 and 0 are set.
            </summary>
        </member>
        <member name="F:TIDP.TIBitArray.StringFormat.BinaryVerbose">
            <summary>
            Example: "3 bits: 110b"
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:TIDP.TIBitArray.StringFormat.Indexes" -->
        <!-- Badly formed XML comment ignored for member "F:TIDP.TIBitArray.StringFormat.Positions" -->
        <member name="T:TIDP.TIBitArray.BitFormatter">
            <summary>
            See the TIBitArray.Formatter property.
            </summary>
        </member>
        <member name="M:TIDP.TIBitArray.BitFormatter.Label(TIDP.TIBitArray,System.Int32,System.Int32,System.String)">
            <summary>
            Change the label string dynamicly
            </summary>
            <param name="bits">The bit array</param>
            <param name="bit_index">bit index in the bit array</param>
            <param name="label_id">1 == Description; 2 == Short Label; 3 == Long Label</param>
            <param name="label_string"></param>
        </member>
        <member name="M:TIDP.TIBitArray8.ToString">
            <summary>
            Returns something like "10101010b".
            </summary>
        </member>
        <member name="T:TIDP.AutoSeedRandom">
            <summary>
            A random number generator that automatically uses a fairly random seed.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.GenSeed">
            <summary>
            This generates a failry random seed based on our thread ID and the system
            time. There is normally no need to call directly unless you want to create
            a ssee for some other purpose.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextBoolean">
            <summary>
            Returns a random boolean: true or false.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextDouble(System.Double,System.Double)">
            <summary>
            Returns a random double between min_value and max_value.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextDoublePct(System.Double,System.Double)">
            <summary>
            Returns a random double +-pct_threshold of nominal_value.
            For example, if nominal_value is 1.0 and pct_threshold
            is 10.0, then a value from 0.9 thru 1.1 will be returned.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
            Returns a random Int32 between min_value and max_value.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextInt32">
            <summary>
            Generates a random Int32 between Int32.MinValue and Int32.MaxValue.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
            Returns a random Int32 between min_value and max_value.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextUInt32">
            <summary>
            Generates a random UInt32 between 0 and UInt32.MaxValue.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
            Returns a random Int16 between min_value and max_value.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
            Returns a random Int16 between min_value and max_value.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextInt16">
            <summary>
            Generates a random Int16 between Int16.MinValue and Int16.MaxValue.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextUInt16">
            <summary>
            Generates a random UInt16 between 0 and UInt16.MaxValue.
            </summary>
        </member>
        <member name="M:TIDP.AutoSeedRandom.NextByte">
            <summary>
            Returns a byte between 0 and 255.
            </summary>
        </member>
        <member name="T:TIDP.MinMax">
            <summary>
            Represents a minimum and maximum. The default value is NaN for each.
            You can call Add(data) to update Maximum/Minimum based on the data
            passed.
            </summary>
        </member>
        <member name="M:TIDP.ColorV.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            A value defaults to 1 -> opaque
            </summary>
            <param name="r"></param>
            <param name="g"></param>
            <param name="b"></param>
        </member>
        <member name="T:TIDP.MinMaxAverage">
            <summary>
            Represents a minimum, maximum, and average. The default value is NaN for each.
            You can call Add(data) to update Maximum/Minimum based on the data
            passed.
            </summary>
        </member>
        <member name="F:TIDP.EnumSortMode.Numeric">
            <summary>
            Sort by an enum's underlying value.
            </summary>
        </member>
        <member name="F:TIDP.EnumSortMode.Identifier">
            <summary>
            Sort by an enum's identifier (MyEnum.A before MyEnum.B).
            </summary>
        </member>
        <member name="T:TIDP.LogMessageType">
            <summary>
            Used by LoggerGridControl, but can be used anywhere you need to categorize
            a message as warning, error, normal, or success.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Normal">
            <summary>
            No coloring by default.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Warning">
            <summary>
            Colored yellow by default.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Error">
            <summary>
            Colored red by default.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Success">
            <summary>
            Colored green by default.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Activity">
            <summary>
            Begin some type of activity.
            </summary>
        </member>
        <member name="F:TIDP.LogMessageType.Detail">
            <summary>
            A more detailed log message. You might decide to show Normal but
            not Detail.
            </summary>
        </member>
        <member name="T:TIDP.MessageTypeInfo">
            <summary>
            This controls the colors used when formatting warning, error, and success
            messages in the logger grid and the HTML log file.
            </summary>
        </member>
        <member name="F:TIDP.MessageTypeInfo.Info">
            <summary>
            Used to map LogMessageType to MessageTypeInfo. A global 
            static instance of MessageTypeInfoHash.
            </summary>
        </member>
        <member name="T:TIDP.TIDictionary`2">
            <summary>
            A customized generic Dictionary. Cloneable and has an indexer,
            Value_Or_Default(key), that will return the default value of TValue if the key does
            not exist. Also serializable as XML, which the standard dictionary is not.
            </summary>
            <remarks>
            IXmlSerializable implementation from Paul Welter @ 
            http://weblogs.asp.net/pwelter34/archive/2006/05/03/444961.aspx.
            </remarks>
        </member>
        <member name="M:TIDP.TIDictionary`2.Add(`1,`0[])">
            <summary>
            Defines key/value pairs for any number of keys, with the values
            of each set to the passed value.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Value_Or_Default(`0)">
            <summary>
            If the key exists, returns the associated value. If it does not exist,
            returns default(TValue). For a class, this returns null. For a value
            type, returns 0, "", etc.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Value_Or(`0,`1)">
            <summary>
            If the key exists, returns the associated value. If it does not exist,
            returns the supplied fallback.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Copy">
            <summary>
            Makes a shallow clone.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIDictionary`2.Clone_Keys">
            <summary>
            Makes a shallow clone of the keys, so that you can iterate over them
            and change the underlying hash.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Clone_Values">
            <summary>
            Makes a shallow clone of the values, so that you can iterate over them
            and change the underlying hash.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Find(`1[])">
            <summary>
            Uses reference comparison to return a list of keys that contain the
            specified value(s) passed. No duplicates will be in the list of keys
            returned.
            </summary>
            <param name="values">One or more values. Can be null for reference types.</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIDictionary`2.Find_First(`1)">
            <summary>
            Returns the key associated with the first value found. Since a value can map to multiple keys,
            only use this if you are sure there is a 1:1 relationship between key and value. Throws an 
            exception if not found.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Set_Keys(`1,`0[])">
            <summary>
            Loops through the keys passed and sets the value for each to the value
            passed.
            </summary>
        </member>
        <member name="M:TIDP.TIDictionary`2.Clone(TIDP.CloneMode,TIDP.CloneMode)">
            <summary>
            Creates a clone of the Dictionary. The clones type will be the same as the underlying type
            of your dictionary. For example, if you sub-classed TIDictionary, then a sub-class will be
            created. The return type is IDictionary&lt;TKey,TValue&gt;, allowing access to the clone's
            memvers without casting back to it's native type. You have control over whether the key or
            value components are shallow or "deep" clones. The meaning of deep depends on all of the 
            nested T.Clone() implementations, as all this function does is call IClonable.Clone() on 
            the items in this list when mode=Deep.
            </summary>
            <remarks>
            When a mode is Shallow, a reference copy of each item is used when creating the dictionary clone. 
            When Deep, a one-level deep clone is done by calling ICloneable.Clone()
            on the key of value. If the T type that is stored in the list does not support IClonable
            and mode is Deep, an exception is thrown. The virtual protected After_Clone() method is called after the clone
            is performed to give a sub-class a channce to do something custom clone-wise, such
            as clone any non-elements properties/fields.
            </remarks>
            <exception cref="T:System.Exception">
            Thrown if there is no default constructor for the list class or mode is Deep but
            T does not implement IClonable.
            </exception>
        </member>
        <member name="M:TIDP.TIDictionary`2.After_Clone(TIDP.CloneMode,TIDP.CloneMode,System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Called by built-in Clone(CloneMode) function. Gives you an oppurtunity to
            do some after all items have been added to the clone. 
            </summary>
        </member>
        <member name="T:TIDP.LogMessageEventArgs">
            <summary>
            An event arguments class encapsulating a message and message
            clasification.
            </summary>
        </member>
        <member name="T:TIDP.BitFlagArrayMultiFormatter">
            <summary>
            Supports summarizing bit status for multiple BitFlagArrays. Simply call
            the Add() method to define those bits you care about for each array,
            and then use one of the ToString() or ToHTML() methods to get 
            formatted output.
            </summary>
        </member>
        <member name="F:TIDP.BitFlagArrayMultiFormatter.No_Components_Text">
            <summary>
            If Add() has never been called, this text is returned by various
            To*() methods.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArrayMultiFormatter.Add(TIDP.IBitFlagArray)">
            <summary>
            Add a bit flag array, reporting on all bits present in the array. Will be ignored if bit_flag_array is 
            null. 
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArrayMultiFormatter.Add(TIDP.IBitFlagArray,System.Int32[])">
            <summary>
            Add a bit flag array. Will be ignored if bit_flag_array is null. If bit_indexes is
            null, all bits will be reported on in To*() methods.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArrayMultiFormatter.ToString(TIDP.BitFlagTextMode,System.String,System.String)">
            <summary>
            If none of the bits previously defined with Add() are set, will return ok_label.
            Returns No_Components_Text if Add() was never called.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArrayMultiFormatter.ToHTML(TIDP.BitFlagTextMode,System.Int32,System.String,System.String,TIDP.ColorV)">
            <summary>
            If none of the bits previously defined with Add() are set, will return ok_label
            wrapped in ok_color. Returns HTMLized No_Components_Text if Add() was never called.
            </summary>
        </member>
        <member name="T:TIDP.FileUtils">
            <summary>
            This is a port of c.m.FileUtils. Some of this is not pretty and
            was for Framework 1.0 work. So could delete some, cleanup others.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.File_In_Directory(System.String)">
            <summary>
            Returns something like "file.xml in c:\foo" or just 
            "file.xml" if there is no directory component to path_name.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Extension(System.String)">
            <summary>
            Returns the filename extension (txt, xml, etc) WITHOUT the leading dot. In lower case 
            always or "" if none found.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Slurp_Text_File2(System.String)">
            <summary>
            Reads a file, treating it as text. Returns the text and also
            the encoding method that was used on the text.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Delete_If_Exists(System.String,System.Boolean)">
            <summary>
            If the specified file exists, it is deleted. If it exists but
            can not be deleted, an exception is thrown unless Error_OK is set.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Delete_If_Exists(System.String)">
            <summary>
            If the specified file exists, it is deleted. If it exists but
            can not be deleted, an exception is thrown.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.MD5Sum(System.String)">
            <summary>
            Computes the MD5 checksum of the specified file. Throws exception
            on error.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.MD5Sum(System.IO.Stream)">
            <summary>
            Computes the MD5 checksum of the specified stream. Throws exception
            on error.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Stream_To_Stream(System.IO.Stream,System.IO.Stream,System.Boolean)">
             <summary>
             Reads from the input binary stream and writes it's contents to 
             output stream. The number of bytes read is returned by the function.
             By default closes the input and output streams when done.
            
             Throws an exception on error.
             </summary>
        </member>
        <member name="M:TIDP.FileUtils.Stream_To_Tmpfile(System.IO.Stream)">
             <summary>
             Reads from the binary stream and writes to a temporary file. The name of 
             the temp file is returned by the function.
            
             Throws an exception on error.
             </summary>
        </member>
        <member name="M:TIDP.FileUtils.Text_Reader_To_Text_Writer(System.IO.TextReader,System.IO.TextWriter,System.Boolean)">
             <summary>
             Reads from the input text reader and writes it's contents to 
             output text writer. The number of lines read is returned by the function.
             By default closes the input and output streams when done.
            
             Throws an exception on error.
             </summary>
        </member>
        <member name="M:TIDP.FileUtils.Write_To_Tmpfile(System.String)">
            <summary>
            Writes text to a tempfile and returns the tempfile name.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Stream_To_File(System.IO.Stream,System.String)">
            <summary>
            Reads from the binary stream and writes to the named file. The number of
            bytes read is returned by the function. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.File_To_Stream(System.String,System.IO.Stream)">
            <summary>
            Reads from the binary file and writes it's contents to the 
            named file. The number of bytes read is returned by the function.
            Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Slurp_Stream(System.IO.Stream,System.Boolean)">
            <summary>
            Reads from the binary stream and returns as string.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Make_File_Writable(System.String)">
            <summary>
            Throws an exception on error. 
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Create_Text(System.String)">
            <summary>
            File.CreateText(“file”) is supposed to use UTF8 encoding. But at least
            with Framework.NET 2.0, it uses ASCII7. Use this function to allow full
            printing of Windows symbols to a text file.
            </summary>
        </member>
        <member name="M:TIDP.FileUtils.Create_Text(System.String,System.Boolean)">
            <summary>
            File.CreateText(“file”) is supposed to use UTF8 encoding. But at least
            with Framework.NET 2.0, it uses ASCII7. Use this function to allow full
            printing of Windows symbols to a text file.
            </summary>
            <param name="append">
            If true, the file will be appended to instead of creating a brand new file.
            </param>
        </member>
        <member name="M:TIDP.FileUtils.File_Size(System.String)">
            <summary>
            Returns the # bytes in a file. Throws exception on error.
            </summary>
        </member>
        <member name="T:TIDP.CompareUtils">
            <summary>
            Miscellaneous static comparison functions on a list
            of values: Max(...), Min(...), 
            Is_Greater_Than(...), Is_Less_Than(...), and Is_Equal_To(...).
            </summary>
            <remarks>
            Let the author know if there are better ways to do this
            </remarks>
        </member>
        <member name="M:TIDP.CompareUtils.Max``1(``0[])">
            <summary>
            Compute the maximum value in the parameters. Uses generics
            for strong typing. Example:
            <example>
            float max = MathUtils.Max&lt;float&gt;(3, 5, 1);
            </example>
            </summary>
            <typeparam name="T">argument and return type (float,int, etc). 
            Could also be anything that implements IComparable</typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.CompareUtils.Min``1(``0[])">
            <summary>
            Compute the maximum value in the parameters. Uses generics
            for strong typing. Example:
            <example>
            float max = MathUtils.Max&lt;float&gt;(3, 5, 1);
            </example>
            </summary>
            <typeparam name="T">argument and return type (float,int, etc). 
            Could also be anything that implements IComparable</typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.CompareUtils.Max2``1(``0[])">
            <summary>
            Similar to Max(), but returns the index that matched as well
            as the value. See Max().
            </summary>
        </member>
        <member name="M:TIDP.CompareUtils.Min2``1(``0[])">
            <summary>
            Compute the maximum value in the parameters. Uses generics
            for strong typing. Example:
            <example>
            float max = MathUtils.Max&lt;float&gt;(3, 5, 1);
            </example>
            </summary>
            <typeparam name="T">argument and return type (float,int, etc). 
            Could also be anything that implements IComparable</typeparam>
            <param name="items"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.CompareUtils.Is_Less_Than``1(``0,``0)">
            <summary>
            Returns true if a &lt; b (via IComparable)
            </summary>
        </member>
        <member name="M:TIDP.CompareUtils.Is_Greater_Than``1(``0,``0)">
            <summary>
            Returns true if a &gt; b (via IComparable)
            </summary>
        </member>
        <member name="M:TIDP.CompareUtils.Is_Equal_To``1(``0,``0)">
            <summary>
            Returns true if a == b (via IComparable)
            </summary>
        </member>
        <member name="T:TIDP.AppMessenger`1">
            <summary>
            Provides a simple way to send a one way message to an application,
            with the default behavior to send a message to another copy of 
            an EXE.
            </summary>
        </member>
        <member name="E:TIDP.AppMessenger`1.NewMessege">
            <summary>
            Fired when a new message is received.
            </summary>
        </member>
        <member name="E:TIDP.AppMessenger`1.MonitorError">
            <summary>
            Fired when we seem to receive a new message, but it can not
            be read/de-serialized.
            </summary>
        </member>
        <member name="T:TIDP.CommandLineProgram`1">
            <summary>
            A base class for a console application that has command line
            parsing capabilities. See TIDP.ConsoleProgram and 
            TIDP.WinForms.WindowsProgram for two implementations.
            See FusionX0ToHexOpts project for example of basic command line 
            program. FusionParamWriter is an example that sub-classes from
            PMBus versions of these classes to provide built-in ability to 
            handle device scanning and options.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Opt_Parser_Error(System.Exception)">
            <summary>
            Called when the option parsing found an error if could not
            recover from. This is actually lame that the Free.CommandLine
            API throws an exception when trying to parse a numeric but 
            can't, but such is life. The program will exit after this
            is called.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Usage_Error">
            <summary>
            Called when Ignore_Usage_Errors is false and there was one
            or more usage errors. The errors are available in the
            Usage_Errors list.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Usage">
            <summary>
            Call to display the usage information for the program.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Version">
            <summary>
            Call to display the version of the program.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Execute">
            <summary>
            Put your applications main logic here. You must override this.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Gen_Usage_Builder">
            <summary>
            Generates a UsageBuilder for the configured options. Usually no
            need to override. But you may want to override 
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Configure_Opt_Parser(Free.CommandLine.OptParse.Parser)">
            <summary>
            Configures the option parser for UNIXy settings.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.Add_Opt_For_Line_Format(System.String,System.String,System.String,System.String)">
            <summary>
            Add an option to your program that accepts a LineOutputFormat enumeration
            in text and will convert it to the enum. opt_field should be a field/property 
            in your Opts class and decoded_field should be a LineOutputFormat. 
            </summary>
        </member>
        <member name="T:TIDP.CommandLineProgram`1.DynamicParsedOpt">
            <summary>
            Uses to support adding options dynamically (vs. attributes) that
            have a string argument but really are parsed into some other Type.
            You sub-class this and then add an instance of this to to 
            Dynamic_Opt_Parser.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgram`1.DynamicParsedOpt.Argument_Label">
            <summary>
            For options that accept an argument, the argument label.
            Equivalent to the OptArgumentLabel attribute.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgram`1.DynamicParsedOpt.Opt_Field">
            <summary>
            The name of the field or property that holds the string version
            of the option.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgram`1.DynamicParsedOpt.Decoded_Field">
            <summary>
            The name of the field or property that holds the decoded version
            of the option.
            </summary>
        </member>
        <member name="F:TIDP.CommandLineProgram`1.DynamicParsedOpt.Encoded">
            <summary>
            The API will set this to what the user has passed on the command line.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.DynamicParsedOpt.Decode(System.String)">
            <summary>
            Decodes the command line argument. Should throw an exception if there is
            a parse error.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.DynamicParsedOpt.Verify(System.Object)">
            <summary>
            Just verifies that the option class has been setup to support this 
            parsed opt (the two fields Encoded_Field and Decoded_Field) have
            been defined.
            </summary>
        </member>
        <member name="T:TIDP.CommandLineProgram`1.EnumListParsedOpt`1">
            <summary>
            This is a DynamicParsedOpt that will parse a list of enum values back
            into a TIList&lt;&gt; of the enum type. So for example, --foo ValueA,ValueB
            would break the list of enum values into a TIList of them.
            </summary>
            <typeparam name="TEnumType"></typeparam>
        </member>
        <member name="T:TIDP.CommandLineProgram`1.EnumParsedOpt`1">
            <summary>
            This is a DynamicParsedOpt that will parse a single enum value back
            to its enum type. So for example, --foo valuea would match the enum 
            ValueA in Opts.opt_field and save it in Opts.decoded_field.
            </summary>
        </member>
        <member name="T:TIDP.CommandLineProgram`1.DynamicOptParser">
            <summary>
            Used to support adding options dynamically (vs. attributes) that
            have a string argument but really are parsed into some other Type.
            An instance of this class is automatically created in the CommandLineProgram
            and is available via Dynamic_Opt_Parser.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.DynamicOptParser.Add(TIDP.CommandLineProgram{`0}.DynamicParsedOpt)">
            <summary>
            Only adds the parsed_opt. It is assumed that the option already has attributes
            such as [OptDef()] and [OptDescription()] that define it as an option.
            </summary>
        </member>
        <member name="M:TIDP.CommandLineProgram`1.DynamicOptParser.Add_Value_Req(TIDP.CommandLineProgram{`0}.DynamicParsedOpt,System.String)">
            <summary>
            Only adds the parsed_opt. It is assumed that the option already has attributes
            such as [OptDef()] and [OptDescription()] that define it as an option.
            </summary>
        </member>
        <member name="T:TIDP.BitFlagArray`1">
            <summary>
            Access (index) a bit array via an enum. The size will automatically
            be the number of items in the enum. The ToString() method will return
            a comma separated list of enums that are set in the bit array.
            See TIBitArray for more information.
            <para/>
            When defining your enum, do not define values. Instead, create the
            enum from low-bit to high-bit order. See the example below.
            </summary>
            <example>
            	<para><font face="Courier New"><font color="black">public enum
                MyFlag</font></font></para>
            	<para><font face="Courier New" color="black">{</font></para>
            	<para>
            		<font color="black"><font face="Courier New">I0</font><font face="Courier New">, //
                Bit 0</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I1</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I2</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I3</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I4</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I5</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I6</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I7</font><font face="Courier New">,</font></font></para>
            	<para>
            		<font color="black"><font face="Courier New">I8</font><font face="Courier New">, //
                Bit 8</font></font></para>
            	<para><font face="Courier New" color="black">}</font></para>
            	<para><font color="black">...</font></para>
            	<para><font color="white"><font color="black">BitFlagArray&lt;MyFlag&gt; flags =
                new BitFlagArray&lt;MyFlag&gt;();</font></font></para>
            	<para><font color="black">// Set the flag at bit position 1 and 8</font></para>
            	<para><font color="black">flags[MyFlag.I8] = true;</font></para>
            	<para><font color="black">flags[MyFlag.I1] = true;</font></para>
            	<para><font color="black">ConsoleApp.WriteLine(flags); // I1,I8</font></para>
            	<para><font color="black">// Clear all flags</font></para>
            	<para><font color="black">flags.Int = 0;</font></para>
            	<para><font color="black">ConsoleApp.WriteLine(flags); // Empty</font></para>
            	<para><font color="black">// Set flags 0 thru 7</font></para>
            	<para><font color="black">flags.Byte = 0xFF;</font></para>
            	<para><font color="black">ConsoleApp.WriteLine(flags); // <font color="white" size="1"><font color="black">I0,I1,I2,I3,I4,I5,I6,I7</font></font></font></para>
            	<para><font color="black">// Set flag 8</font></para>
            	<para><font color="black">flags.Int = 0x100;</font></para>
            	<para><font color="black">ConsoleApp.WriteLine(flags); // I8</font></para>
            </example>
        </member>
        <member name="M:TIDP.BitFlagArray`1.#ctor(System.UInt64)">
            <summary>
            Creates a BitFlagArray whose bits are set accoding to the
            value of the integer passed. The size will be determined
            by the number of entries in TEnum.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.#ctor(System.Byte)">
            <summary>
            Creates a BitFlagArray whose bits are set accoding to the
            value of the integer passed. The size will be determined
            by the number of entries in TEnum. I.e. it will not
            necessarily have 8 entries.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.#ctor(System.Byte,System.Byte)">
            <summary>
            Creates a BitFlagArray whose bits are set accoding to the
            high byte and low byte passed. The size will be determined
            by the number of entries in TEnum. I.e. it will not necessarily
            have 16 entries.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.#ctor(System.Byte[])">
            <summary>
            Creates a BitFlagArray whose bits are set accoding to the
            byte array passed. The bytes should be ordered hi->lo such
            that bytes[0] is the high byte and bytes[n] is the low byte.
            The size will be determined by the number of entries in TEnum. 
            I.e. it will not necessarily have bytes.Length*8 entries.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.#ctor">
            <summary>
            Creates a BitFlagArray whose size is determined
            by the number of entries in TEnum, unless Manual_Sizing is true.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Name(System.Int32)">
            <summary>
            Returns the enum name for the specified index.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Binary(System.Int32)">
            <summary>
            Returns "0" or "1" depending on the value for the specified index.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Text(System.Int32,TIDP.BitFlagTextMode)">
            <summary>
            Returns either Name(index), Label(index), or Binary(index) depending on the 
            BitFlagTextMode passed.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Enum(System.Int32)">
            <summary>
            Returns the enum for the specified index.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Index(`0)">
            <summary>
            Returns the index associated with the specified enum. Can be overriden if your index
            is not the enum value.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.ToString(TIDP.BitFlagTextMode,System.String,System.String)">
            <summary>
            You can customize what to print out -- enum, label, or bits -- and
            also the seperator. Returns ok_label if no flags are set.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.ToString">
            <summary>
            Returns something like "FLAG0,FLAG2" or "&lt;EMPTY&gt; if no bits are set. 
            See ToString(mode, seperator, ok_label) for more options.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.ToString(System.Int32,TIDP.BitFlagTextMode)">
            <summary>
            A pseudonym for Text(index, mode).
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.ToString(TIDP.BitFlagTextMode,System.String)">
            <summary>
            You can customize what to print out -- enum, label, or bits -- and
            also the seperator. Returns "&lt;empty&gt;" if no flags are set.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Set(`0,System.Boolean)">
            <summary>
            Set a bit, identified by the enum id, to the specified value. This
            is equivalent to this[id] = value.
            </summary>
            <example>
            Set(MyEnum.A, true)
            </example>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Set(System.Int32,System.Boolean)">
            <summary>
            Set a bit, identified by the bit index, to the specified value. This
            is equivalent to this[i] = value.
            </summary>
            <example>
            Set(0, true)
            </example>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Get(`0,System.Boolean)">
            <summary>
            Gets a bit, identified by the bit enum id. This
            is equivalent this[i].
            </summary>
            <example>
            Get(MyEnum.A, true)
            </example>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Get(System.Int32,System.Boolean)">
            <summary>
            Gets a bit, identified by the bit index. This
            is equivalent this[i].
            </summary>
            <example>
            Get(0)
            </example>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Set(System.Byte,System.Byte)">
            <summary>
            Define the mask based on a hi and lo byte (word).
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Set(System.Byte[])">
            <summary>
            Set the mask based on the supplied bytes. You can supply
            1 to 8 bytes. The bytes should be ordered hi->lo such
            that bytes[0] is the high byte and bytes[n] is the low byte.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Make_Html(System.Int32,System.String,TIDP.ColorV)">
            <summary>
            Wraps the specified label in the specified color and makes
            it bold. Override to do your own thing. -1 in index indicates
            the &lt;NONE&gt; condition.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Show_In_Html(System.Int32)">
            <summary>
            Returns whether to show a particular bit in the default ToHTML()
            implementation. The default will return false if Supported(i)
            returns false or Reserved(i) returns true.
            </summary>
        </member>
        <member name="M:TIDP.BitFlagArray`1.Shift(`0,System.Boolean)">
            <summary>
            Left shifts the bit array, effectively removing the entry at
            index.
            </summary>
            <param name="maintain_size">
            If true, the size is maintained and a false element will now be 
            the last element.
            </param>
        </member>
        <member name="P:TIDP.BitFlagArray`1.Item(`0)">
            <summary>
            Get or set an individual bit.
            </summary>
        </member>
        <member name="P:TIDP.BitFlagArray`1.Empty_String">
            <summary>
            What to return in ToString() et all when there are no
            bits set. Default is "&lt;EMPTY&gt;".
            </summary>
        </member>
        <member name="P:TIDP.BitFlagArray`1.Num_Bits">
            <summary>
            Returns the length that the bit array should be sized to a construct
            time. Defaults to the length of TEnum.
            </summary>
        </member>
        <member name="F:TIDP.BitFlagTextMode.LabelLong">
            <summary>
            Return a longer label.
            </summary>
        </member>
        <member name="F:TIDP.BitFlagTextMode.LabelShort">
            <summary>
            Return a very short label.
            </summary>
        </member>
        <member name="F:TIDP.BitFlagTextMode.Name">
            <summary>
            Return Name(), the actual enum value as a string.
            </summary>
        </member>
        <member name="F:TIDP.BitFlagTextMode.Binary">
            <summary>
            Produce a "1" or "0"
            </summary>
        </member>
        <member name="T:TIDP.EasySymetricCryptoStream">
            <summary>
            Create a stream that you can write to in order to encrypt or read from
            to decrypt. DESCryptoServiceProvider is the crypto provider. Also supports 
            automatic compression should the data compress well, since compressing 
            encrypted data does not yield good results. Used by the encryption mode
            of XmlEasySerializer.
            </summary>
            <remarks>
            A 64 byte key is used by DESCryptoServiceProvider. The key you pass will
            be adjusted to conform to this. With compression, the stream chain
            looks like this on Encrypt:
            Compress -> Encrypt -> Save
            and on decript:
            Read -> Decript -> Decompress
            </remarks>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.#ctor(TIDP.EasySymetricCryptoStream.ModeID,System.String,System.String,System.Boolean)">
            <summary>
            Encrypt to/from a file.
            </summary>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.#ctor(TIDP.EasySymetricCryptoStream.ModeID,System.String,System.IO.Stream,System.Boolean)">
            <summary>
            Encrypt to/from a stream.
            </summary>
            <param name="mode"></param>
            <param name="key"></param>
            <param name="stream">Stream to read from or write to. It is closed when done.</param>
            <param name="use_compression"></param>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.Gen_Key(System.Security.Cryptography.SymmetricAlgorithm,System.String)">
            <summary>
            Creates a symetric encryption key.
            </summary>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.Create_Algorithm(System.String)">
            <summary>
            Create a Rijndael symetric crypto algorithm, which is the same as AES.
            </summary>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.Create_Encryptor(System.String)">
            <summary>
            Create a Rijndael symetric encryptor, which is the same as AES.
            </summary>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.Create_Decryptor(System.String)">
            <summary>
            Create a Rijndael symetric decryptor, which is the same as AES.
            </summary>
        </member>
        <member name="M:TIDP.EasySymetricCryptoStream.Get_Legal_Key(System.Security.Cryptography.SymmetricAlgorithm,System.String)">
            <summary>
            Algorithms have key length requirements. This function will truncate or
            * pad keys that do not conform to a specific algorithm's requirements.
            </summary>
            <remarks>
            From "Symmetric Cryptography and Hashing in C#" By Chidi Ezeukwu in
            The Code Project, http://www.codeproject.com/KB/security/chidi_cryptommetric.aspx. 
            </remarks>
        </member>
        <member name="T:TIDP.DeveloperDebug">
            <summary>
            A higher level developer "debug message" log system for really important
            debug messages. Just call the Log() static method. This will both log
            your message to Logger but also fire a Message event. 
            DeveloperDebugLogForm form -- which is available in the GUI's Debug
            menu -- will subscribe to the Message events and provide an easy way
            to view these debug messages.
            </summary>
        </member>
        <member name="E:TIDP.DeveloperDebug.Message">
            <summary>
            Fired when DeveloperDebug.Send() is called.
            </summary>
        </member>
        <member name="T:TIDP.LineInput">
            <summary>
            Simple class to read line-oriented field-based text. For
            example, tab or comma separated input. See LineOutput for
            a class to create these files.
            </summary>
            <example>
            <code>
            </code>
            </example>
        </member>
        <member name="M:TIDP.LineInput.#ctor(TIDP.LineOutputFormat,System.String)">
            <summary>
            Opens infile for read. Throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.LineInput.Slurp_String(TIDP.LineOutputFormat,System.String)">
            <summary>
            Treats the string passed as if it was the contents of a text file. Returns all
            lines broken out. Returns an empty array if the string is empty.
            </summary>
        </member>
        <member name="M:TIDP.LineInput.ReadLine">
            <summary>
            Reads the next line. If at EOF, returns null.
            </summary>
        </member>
        <member name="M:TIDP.LineInput.ReadLines">
            <summary>
            Reads all lines.
            </summary>
        </member>
        <member name="M:TIDP.LineInput.Close">
            <summary>
            Closes the StreamReader. OK to call multiple times. Will also
            Dispose of the reader. 
            </summary>
        </member>
        <member name="F:TIDP.LineInput.Line.Text">
            <summary>
            The original line read from the input.
            </summary>
        </member>
        <member name="F:TIDP.LineInput.Line.Fields">
            <summary>
            The fields broken out into an array.
            </summary>
        </member>
        <member name="P:TIDP.LineInput.Line.Item(System.Int32)">
            <summary>
            Access a field by it's index.
            </summary>
        </member>
        <member name="P:TIDP.LineInput.Line.Length">
            <summary>
            Number of fields.
            </summary>
        </member>
        <member name="T:TIDP.CustomClonableObject">
            <summary>
            A very simple cloning mechanism. Clone() will use reflection to
            create an instance of the same type. But before returning,
            the Clone(original) method is called on the copy to allow it
            to copy properties/etc. So override Clone(), and be sure
            to call base.Clone(original) to give a parent class a chance
            to do it's thing.
            </summary>
            <remarks>
            Lots of limitations since only internal or public information can
            be cloned. But works for certain applications. 
            </remarks>
        </member>
        <member name="T:TIDP.Memory.IMemoryDriver">
            <summary>
            Interface for a driver to read/write memory. Used for memory mapped I/O
            via CMemoryMap.
            </summary>
        </member>
        <member name="M:TIDP.Memory.IMemoryDriver.Write(System.UInt32,System.Byte[])">
            <summary>
            Writes one or more bytes of data. You must throw an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.Memory.IMemoryDriver.Read(System.UInt32,System.UInt32)">
            <summary>
            Reads one or moe bytes of data. You must throw an exception on error.
            </summary>
        </member>
        <member name="E:TIDP.Memory.IMemoryDriver.ReadMemory">
            <summary>
            Fired for each individual low-level read. For example, a read of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="E:TIDP.Memory.IMemoryDriver.WroteMemory">
            <summary>
            Fired for each individual low-level write. For example, a write of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="P:TIDP.Memory.MemoryDriverEventArgsBase.Message">
            <summary>
            Returns a summary of the read/write.
            </summary>
        </member>
        <member name="T:TIDP.Memory.MemoryDriverHelper">
            <summary>
            A class to help read/write bytes along appropriate memory boundaries. 
            For example, if you wanted to read 2 bytes @ address 1 you could not
            just do a two byte read starting at address 1. You instead need to
            read one byte at address 1 and another byte read at address 2. The Read()
            and Write() methods do this.
            </summary>
        </member>
        <member name="E:TIDP.Memory.MemoryDriverHelper.ReadMemory">
            <summary>
            Fired for each individual low-level read. For example, a read of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="E:TIDP.Memory.MemoryDriverHelper.WroteMemory">
            <summary>
            Fired for each individual low-level write. For example, a write of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="T:TIDP.Memory.SimulatedMemoryDriver">
            <summary>
            Simulate reading and writing memory. "Memory" is maintained as a simple
            hash table.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.Read_Mode">
            <summary>
            You *can* change this during the lifetime of an instance.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.Memory">
            <summary>
            Map address to data byte.
            </summary>
        </member>
        <member name="E:TIDP.Memory.SimulatedMemoryDriver.ReadMemory">
            <summary>
            Fired for each individual low-level read. For example, a read of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="E:TIDP.Memory.SimulatedMemoryDriver.WroteMemory">
            <summary>
            Fired for each individual low-level write. For example, a write of 32
            bytes might result in 2 events being fired: one for the first 16 bytes,
            another for the second.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.ReadMode.DefaultOrLastReadOrWrite">
            <summary>
            First read returns a constant for all memory locations, and
            successive reads returns whatever was last wrote or the
            constant value if never wrote.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.ReadMode.RandomDataForFirstReadOnly">
            <summary>
            First read is random, successive reads back what was last read
            or written.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.ReadMode.RandomDataWithConstantPowerOnDefault">
            <summary>
            First read returns a constant for all memory locations, then
            random for successive reads.
            </summary>
        </member>
        <member name="F:TIDP.Memory.SimulatedMemoryDriver.ReadMode.RandomDataAlways">
            <summary>
            Always random data on read.
            </summary>
        </member>
        <member name="T:TIDP.NumberFormatProvider">
            <summary>
            Implements an IFormatProvider that has various ways to format numbers. See
            constructors.
            </summary>
        </member>
        <member name="M:TIDP.NumberFormatProvider.#ctor(System.Double,System.Int32,System.String)">
            <summary>
            Manuall define multiplier and suffix. 
            NumberFormatProvider(1000, 3, "kHz") will convert 5000 to
            "5.000 kHz".
            </summary>
        </member>
        <member name="M:TIDP.NumberFormatProvider.#ctor(System.Int32,TIDP.FormatUtils.UnitID)">
            <summary>
            Automatically select the appropriate multiplier. 
            NumberFormatProvider(3, UnitID.Hertz) will convert 5000 to
            "5.000 kHz".
            </summary>
        </member>
        <member name="M:TIDP.NumberFormatProvider.#ctor(TIDP.FormatUtils.UnitID)">
            <summary>
            Automatically select the appropriate multiplier and force
            3 decimal places. NumberFormatProvider(UnitID.Hertz) 
            will convert 5000 to "5.000 kHz".
            </summary>
        </member>
        <member name="T:TIDP.NumericLookupMode">
            <summary>
            Lookup mode for NumericLookupTable.Find() and similar. See
            the various NumericLookupTable.Find_*() methods for an explanation
            of each mode.
            </summary>
        </member>
        <member name="T:TIDP.INumericLookupTable">
            <summary>
            An untyped interface to NumericLookupTable that does not allow
            access to the TableItem each row in the lookup table holds.
            </summary>
        </member>
        <member name="T:TIDP.NumericLookupTable`1">
            <summary>
            A list that contains numeric values in increasing order and also an
            arbitrary piece of data called a Tag. This might be an object or
            just a value type like a byte. You can "lookup" based on the numeric
            value within the table using a variety of lookup modes such as exact or 
            nearest usisng the Find() method. You can also do an exact lookup for
            the tag. Finally, you can also test whether a given value is within the 
            range of the table using the In_Table() method. 
            </summary>
        </member>
        <member name="F:TIDP.NumericLookupTable`1.Table">
            <summary>
            The underlying table.
            </summary>
        </member>
        <member name="F:TIDP.NumericLookupTable`1.Validate_Adds">
            <summary>
            Whether to validate items that are added via Add(). This checks to
            see that they are added in increasing numeric order. You can turn this
            off if you will instead sort the array when done.
            </summary>
        </member>
        <member name="F:TIDP.NumericLookupTable`1.Round_To_Decimal_Places_On_Add">
            <summary>
            If specified, the number of decimal places to round any items Added to the table to.
            Useful when multiplication/division is used to build the table.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.#ctor(System.Double,System.Double,System.Double,System.Boolean)">
            <summary>
            Adds items to the lookup table. If the start_value + increment loop would not
            result in end_value being hit, always_create_end_value will control whether
            it gets created always or not.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Adds items to the lookup table. If the start_value + increment loop would not
            result in end_value being hit, always_create_end_value will control whether
            it gets created always or not.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Add(System.Double)">
            <summary>
            Adds an item to the lookup table with it's internal Tag set to the default
            for TTag (null for an object, default value for a value type). Verifies that 
            the new item is greater than in value to any previous item in the table.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Add(System.Double,`0)">
            <summary>
            Adds an item to the lookup table. Verifies that the new item is greater
            than in value to any previous item in the table.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find(System.Nullable{System.Double},TIDP.NumericLookupMode)">
            <summary>
            Finds the value using the specified mode. Can return
            null in ExactOnly mode or if the lookup table is empty.
            A null value is only legal when mode is Next or Previous.
            See Find_* for details on how each mode works.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Value(System.Nullable{System.Double},TIDP.NumericLookupMode)">
            <summary>
            Similar to Find(), but returns just the double if found and null if not
            found.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Nearest(System.Double)">
            <summary>
            Finds the value that is closest to find_value, either
            greater than or less than. 
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Exact(System.Double)">
            <summary>
            Finds a table item based on it's double value. If not
            found, returns null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Exact_Or_Under(System.Double)">
            <summary>
            If find_value is in the table, returns the table entry for it.
            If it not, it finds the previous item in the table that is less
            than find_value. If there are none, returns null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Exact_Or_Over(System.Double)">
            <summary>
            If find_value is in the table, returns the table entry for it.
            If it not, it finds the next item in the table that is >
            find_value. If there are none, returns null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Next(System.Nullable{System.Double})">
            <summary>
            Finds the next value in the table that is > current_value. Will
            return null if current_value is already >= the  last row in the 
            table. If current_value is before the start of the table, the 
            first row in the table is returned. If current_value is null,
            the first item is returned.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Next_Or_Last(System.Nullable{System.Double})">
            <summary>
            Similar to Find_Next(), but if we are already >= the
            end of the table, the last row in the table will be returned,
            not null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Previous(System.Nullable{System.Double})">
            <summary>
            Finds the previous value in the table that is less than the current_value. 
            Will return null if current_value is less than the first row in the table.
            If current_value is after the end of the table, the last row in the table 
            is returned. If current_value is null, the last item is returned.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Previous_Or_First(System.Nullable{System.Double})">
            <summary>
            Similar to Find_Previous(), but if we are already less than or equal 
            to the end of the table, the last row in the table will be returned,
            not null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Tag(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains. This is an exact match to that field using the Equals() 
            interface.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Tag(System.Byte[])">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains. This is an exact match to that field using the Equals() 
            interface. tag_as_bytes are converted into the underlying unsigned
            representation TTag.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Tag_Or_NaN(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains and returns the underlying double. If there is no exact match, 
            returns NaN.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Find_Tag_Or_Null(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains and returns the underlying double. If there is no exact match, 
            returns null.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.In_Table(System.Double)">
            <summary>
            Returns true if the speified value is within the range of the
            table. See Find() for an exact match. Throws an exception if the
            table is empty.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.ToDetailedString">
            <summary>
            Returns the every item newline separated in a string.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Sort">
            <summary>
            You do not normally need to call this if calling Add() in order of your doubles. But, if 
            instead you need to add items out of order, you can set Validate_Adds to false, Add()
            your items, and then call Sort().
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Write_Table(TIDP.LineOutput,System.Boolean)">
            <summary>
            Write the table's contents to an already opened LineOutput.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Write_Table(TIDP.LineOutput)">
            <summary>
            Write the table's contents to an already opened LineOutput. Includes a header
            describing each column.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Format_Tag(`0)">
            <summary>
            Used by Write_Table(). Override for custom formatting of tag.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Format_Value(System.Double)">
            <summary>
            Used by Write_Table(). Override for custom formatting of the decimal value.
            The default is just double.ToString().
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.Round(System.Double)">
            <summary>
            Rounds to get rid of floating point innacuracy like 2.499999999999 instead of
            2.5.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Length">
            <summary>
            Number of items in the table.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Min_Value">
            <summary>
            Shortcut for Table[0].Value. Useful via the INumericLookupTable interface.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Min_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            smallest/lowest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Max_Value">
            <summary>
            Shortcut for Table.Last.Value. Useful via the INumericLookupTable interface.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Max_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            largest/highest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="P:TIDP.NumericLookupTable`1.Decimal_Places">
            <summary>
            Returns the number of decimal places required to show all entries in
            lookup table to maximum precision. Recalculated each time you call, so
            cache as necessary.
            </summary>
        </member>
        <member name="M:TIDP.NumericLookupTable`1.TableItem.CompareTo(TIDP.NumericLookupTable{`0}.TableItem)">
            <summary>
            Compares numerically on Value.
            </summary>
        </member>
        <member name="M:TIDP.NumericByteLookupTable.Add_Next(System.Double)">
            <summary>
            If you call this in order and your table starts by byte 0,
            you can save some typing by calling this.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TIDP.NumericByteLookupTable.Add_Binary(System.Double,System.String)">
            <summary>
            Adds a double/tag via binary encoded tag, such as "1001b" or "1001".
            </summary>
        </member>
        <member name="M:TIDP.NumericByteLookupTable.Add_Binary(System.String,System.Double)">
            <summary>
            Adds a double/tag via binary encoded tag, such as "1001b" or "1001".
            </summary>
        </member>
        <member name="M:TIDP.NumericByteLookupTable.Add_Bit_Table(System.Double[])">
            <summary>
            Define a table where the arguments define values if a given bit is
            set. For example, Add_Non_Linear_Table(0.7, 1.3) will define a 
            table where 0x0 = 0, 0x1 = 0.7, 0x2 = 1.3, and 0x3 = 2.0 (0.7 + 1.3).
            The length of bit_pos_to_double will be equal to the number of
            bits in the table.
            </summary>
        </member>
        <member name="M:TIDP.NumericByteLookupTable.Add_Sign_And_Magnitude(TIDP.NumericByteLookupTable.SignMode,System.Int32,System.Double)">
            <summary>
            Define a table assuming sign and magnitude encoding, with the hi bit
            containing the sign bit. For example, 
            Add_Sign_And_Magnitude(SignMode.ZeroIsNegative, 3, 2.5) would have a table 
            (-7.5, -5.0, -2.5, 0, 2.5, 5.0, 7.5). One encoding will be skipped
            </summary>
        </member>
        <member name="F:TIDP.NumericByteLookupTable.SignMode.OneIsNegative">
            <summary>
            Standard sign-and-magnitude encoding, where 10001 means -1.
            </summary>
        </member>
        <member name="F:TIDP.NumericByteLookupTable.SignMode.OneIsPositive">
            <summary>
            Non-standard sign-and-magnitude encoding, where 10001 means 1.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:TIDP.IntNumericLookupTable`1" -->
        <member name="F:TIDP.IntNumericLookupTable`1.Table">
            <summary>
            The underlying table.
            </summary>
        </member>
        <member name="F:TIDP.IntNumericLookupTable`1.Validate_Adds">
            <summary>
            Whether to validate items that are added via Add(). This checks to
            see that they are added in increasing numeric order. You can turn this
            off if you will instead sort the array when done.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Adds items to the lookup table. If the start_value + increment loop would not
            result in end_value being hit, always_create_end_value will control whether
            it gets created always or not.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Adds items to the lookup table. If the start_value + increment loop would not
            result in end_value being hit, always_create_end_value will control whether
            it gets created always or not.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Add(System.Int32)">
            <summary>
            Adds an item to the lookup table with it's internal Tag set to the default
            for TTag (null for an object, default value for a value type). Verifies that 
            the new item is greater than in value to any previous item in the table.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Add(System.Int32,`0)">
            <summary>
            Adds an item to the lookup table. Verifies that the new item is greater
            than in value to any previous item in the table.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find(System.Nullable{System.Int32},TIDP.NumericLookupMode)">
            <summary>
            Finds the value using the specified mode. Can return
            null in ExactOnly mode or if the lookup table is empty.
            A null value is only legal when mode is Next or Previous.
            See Find_* for details on how each mode works.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Value(System.Nullable{System.Int32},TIDP.NumericLookupMode)">
            <summary>
            Similar to Find(), but returns just the double if found and null if not
            found.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Nearest(System.Int32)">
            <summary>
            Finds the value that is closest to find_value, either
            greater than or less than. 
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Exact(System.Int32)">
            <summary>
            Finds a table item based on it's double value. If not
            found, returns null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Exact_Or_Under(System.Int32)">
            <summary>
            If find_value is in the table, returns the table entry for it.
            If it not, it finds the previous item in the table that is less
            than find_value. If there are none, returns null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Exact_Or_Over(System.Int32)">
            <summary>
            If find_value is in the table, returns the table entry for it.
            If it not, it finds the next item in the table that is >
            find_value. If there are none, returns null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Next(System.Nullable{System.Int32})">
            <summary>
            Finds the next value in the table that is > current_value. Will
            return null if current_value is already >= the  last row in the 
            table. If current_value is before the start of the table, the 
            first row in the table is returned. If current_value is null,
            the first item is returned.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Next_Or_Last(System.Nullable{System.Int32})">
            <summary>
            Similar to Find_Next(), but if we are already >= the
            end of the table, the last row in the table will be returned,
            not null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Previous(System.Nullable{System.Int32})">
            <summary>
            Finds the previous value in the table that is less than the current_value. 
            Will return null if current_value is less than the first row in the table.
            If current_value is after the end of the table, the last row in the table 
            is returned. If current_value is null, the last item is returned.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Previous_Or_First(System.Nullable{System.Int32})">
            <summary>
            Similar to Find_Previous(), but if we are already less than or equal 
            to the end of the table, the last row in the table will be returned,
            not null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Tag(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains. This is an exact match to that field using the Equals() 
            interface.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Tag(System.Byte[])">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains. This is an exact match to that field using the Equals() 
            interface. tag_as_bytes are converted into the underlying unsigned
            representation TTag.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Tag_Or_Zero(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains and returns the underlying double. If there is no exact match, 
            returns NaN.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Find_Tag_Or_Null(`0)">
            <summary>
            Finds an entry in the lookup table based on the optional Tag field it
            contains and returns the underlying double. If there is no exact match, 
            returns null.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.In_Table(System.Int32)">
            <summary>
            Returns true if the speified value is within the range of the
            table. See Find() for an exact match. Throws an exception if the
            table is empty.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.ToDetailedString">
            <summary>
            Returns the every item newline separated in a string.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Sort">
            <summary>
            You do not normally need to call this if calling Add() in order of your doubles. But, if 
            instead you need to add items out of order, you can set Validate_Adds to false, Add()
            your items, and then call Sort().
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Write_Table(TIDP.LineOutput,System.Boolean)">
            <summary>
            Write the table's contents to an already opened LineOutput.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Write_Table(TIDP.LineOutput)">
            <summary>
            Write the table's contents to an already opened LineOutput. Includes a header
            describing each column.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Format_Tag(`0)">
            <summary>
            Used by Write_Table(). Override for custom formatting of tag.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.Format_Value(System.Int32)">
            <summary>
            Used by Write_Table(). Override for custom formatting of the decimal value.
            The default is just double.ToString().
            </summary>
        </member>
        <member name="P:TIDP.IntNumericLookupTable`1.Length">
            <summary>
            Number of items in the table.
            </summary>
        </member>
        <member name="P:TIDP.IntNumericLookupTable`1.Min_Value">
            <summary>
            Shortcut for Table[0].Value. Useful via the INumericLookupTable interface.
            </summary>
        </member>
        <member name="P:TIDP.IntNumericLookupTable`1.Min_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            smallest/lowest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="P:TIDP.IntNumericLookupTable`1.Max_Value">
            <summary>
            Shortcut for Table.Last.Value. Useful via the INumericLookupTable interface.
            </summary>
        </member>
        <member name="P:TIDP.IntNumericLookupTable`1.Max_Tag">
            <summary>
            If Tag implements IComparable, this will return the 
            largest/highest sorted item. Min_Tag and Max_Tag are calculated once, and then
            cached.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericLookupTable`1.TableItem.CompareTo(TIDP.IntNumericLookupTable{`0}.TableItem)">
            <summary>
            Compares numerically on Value.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericByteLookupTable.Add_Next(System.Int32)">
            <summary>
            If you call this in order and your table starts by byte 0,
            you can save some typing by calling this.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TIDP.IntNumericByteLookupTable.Add_Binary(System.Int32,System.String)">
            <summary>
            Adds a double/tag via binary encoded tag, such as "1001b" or "1001".
            </summary>
        </member>
        <member name="M:TIDP.IntNumericByteLookupTable.Add_Binary(System.String,System.Int32)">
            <summary>
            Adds a double/tag via binary encoded tag, such as "1001b" or "1001".
            </summary>
        </member>
        <member name="M:TIDP.IntNumericByteLookupTable.Add_Bit_Table(System.Int32[])">
            <summary>
            Define a table where the arguments define values if a given bit is
            set. For example, Add_Non_Linear_Table(1, 3) will define a 
            table where 0x0 = 0, 0x1 = 1, 0x2 = 3, and 0x3 = 4 (1 + 3).
            The length of bit_pos_to_double will be equal to the number of
            bits in the table.
            </summary>
        </member>
        <member name="M:TIDP.IntNumericByteLookupTable.Add_Sign_And_Magnitude(TIDP.IntNumericByteLookupTable.SignMode,System.Int32,System.Int32)">
            <summary>
            Define a table assuming sign and magnitude encoding, with the hi bit
            containing the sign bit. For example, 
            Add_Sign_And_Magnitude(SignMode.ZeroIsNegative, 3, 2.5) would have a table 
            (-7.5, -5.0, -2.5, 0, 2.5, 5.0, 7.5). One encoding will be skipped
            </summary>
        </member>
        <member name="F:TIDP.IntNumericByteLookupTable.SignMode.OneIsNegative">
            <summary>
            Standard sign-and-magnitude encoding, where 10001 means -1.
            </summary>
        </member>
        <member name="F:TIDP.IntNumericByteLookupTable.SignMode.OneIsPositive">
            <summary>
            Non-standard sign-and-magnitude encoding, where 10001 means 1.
            </summary>
        </member>
        <member name="T:TIDP.NullableDoubles">
            <summary>
            Used to get basic metrics (sum, average) on a list of nullable
            doubles (double?). Static methods are really what are useful.
            </summary>
        </member>
        <member name="M:TIDP.NullableDoubles.Add(System.Nullable{System.Double})">
            <summary>
            Does not really store the double. Just updates the properties
            based on it's value.
            </summary>
        </member>
        <member name="T:TIDP.ConsoleProgram`1">
            <summary>
            A base class for a console application that has command line
            parsing capabilities. See WindowsProgram if you want to add
            command line processing to a WinForms application.
            </summary>
        </member>
        <member name="M:TIDP.ConsoleProgram`1.Die_Bad_Usage(System.String,System.Object[])">
            <summary>
            Prints to stderr three lines: the specified message, then a note about how to 
            get command line help, and then message saying the tool is exiting.
            </summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:TIDP.ConsoleProgram`1.Parse_Enum_Opt``1(System.String,System.String)">
            <summary>
            Parses --arg_name arg_value, where arg_value maps to an enum value. If 
            arg_value is null, empty, or not a known value, exits with an error 
            </summary>
        </member>
        <member name="T:TIDP.LineOutputFormat">
            <summary>
            Output format for LineOutput.Format() et all.
            </summary>
        </member>
        <member name="T:TIDP.LineOutput">
            <summary>
            Simple class to produce line-oriented field-based text. For
            example, tab or comma separated output. Has both static 
            functions to return formated strings as well as instance
            methods to write to a file. Also supports HTML table format.
            </summary>
            <remarks>
            Any consecutive newlines present in a field get converted to 
            "; " in CSV and tab formats. Trailing newlines are always
            purged.
            </remarks>
        </member>
        <member name="F:TIDP.LineOutput.Auto_Flush">
            <summary>
            Whether to automatically flush the file buffer ti disk each
            time WriteLine() is called. Default is false. Setting to true
            can slow down your application's responsiveness, but may be
            necessary to monirot 100% in real time or if your app is
            crash prone.
            </summary>
        </member>
        <member name="F:TIDP.LineOutput.Html_Nobreak_Columns">
            <summary>
            Lets you define column indexes to add a nobr tag in each TD
            in an HTML report. For example, "Html_Nobreak_Columns = new int[] { 0 }" 
            will cause every cell in column 0 to have nobr. You must set this before
            the first call to Write*().
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(TIDP.LineOutputFormat)">
            <summary>
            Can not actually Write in this mode. But useful if you just 
            want to use the formatting methods.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(System.String,TIDP.LineOutputFormat,System.Boolean)">
            <summary>
            Creates an ASCII StreamWriter that can be accesse via Writer.
            Throws various exceptions if the file can not be opened
            for write. outfile can be "-" for stdout.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(System.String,TIDP.LineOutputFormat,System.Text.Encoding)">
            <summary>
            Creates an StreamWriter that can be accesse via Writer.
            Throws various exceptions if the file can not be opened
            for write. outfile can be "-" for stdout.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(System.String,TIDP.LineOutputFormat,System.Text.Encoding,System.Boolean)">
            <summary>
            Creates an StreamWriter that can be accesse via Writer.
            Throws various exceptions if the file can not be opened
            for write. outfile can be "-" for stdout.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(System.String,TIDP.LineOutputFormat)">
            <summary>
            Creates an ASCII StreamWriter that can be accesse via Writer.
            Overwrites file if it already exists. Throws various exceptions 
            if the file can not be opened for write.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.#ctor(TIDP.LineOutput.OtherMode,TIDP.LineOutputFormat)">
            <summary>
            Instead of outputing to a file, send output to either
            standard output (console), standard error, or an internal
            StringBuilder (a buffer). The buffer can be access via 
            the String_Builder property to via ToString().
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Create_CSV(System.String)">
            <summary>
            Opens a CSV file for write and returns the LineOutput object.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Create_HTML(System.String)">
            <summary>
            Opens an HTML file for write and returns the LineOutput object.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Create_Tab(System.String)">
            <summary>
            Opens a tab delimited file for write and returns the LineOutput object.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Write_Header(System.Collections.IList)">
            <summary>
            On output formats that support formatting, will format specially
            and treat as the header in the file. For example, make bold in
            HTML.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Write_List(TIDP.LogMessageType,System.Collections.IList)">
            <summary>
            In HTML mode, applies formatting to the row based on msg_type.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Write_Span(System.String)">
            <summary>
            In HTML mode, creates a span row across all cells. In non-HTML mode, just
            adds a single data column. Assumes span is Num_Cols wide.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Write(System.String,System.Object[])">
            <summary>
            Basically the same as WriteLine in a normal StreamWriter. Gives you
            the oppurtunity to bypass field encoding and write raw text. CR-LF
            is added.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Transform(TIDP.LineOutputFormat,System.Int32,System.String)">
            <summary>
            Provides a way for a sub-class to modify a field before it is outputed.
            The default implementation converts consecutive newlines in the field
            to "; " in CSV/Tab mode and also removes any trailing newlines in CSV/Tab
            mode.
            </summary>
            <param name="field_index">A 0-based index defining the position withing
            the line of this field. 0, 1, 2, etc.</param>
            <param name="field">The field as text.</param>
        </member>
        <member name="M:TIDP.LineOutput.Close">
            <summary>
            Closes the StreamWriter. OK to call multiple times. Will also
            Dispose of the writer. Ignored if we are not actually writing
            to a file, stdout, or stderr.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Flush">
            <summary>
            Forces any unwritten output in system buffers to be written to
            disk. Ignored if we are not actually writing to a file, stdout, or stderr.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Parse_Format_Arg(System.String)">
            <summary>
            Parses an argument such as "tab", "Tab", "CSV", "CsV", etc.
            and returns the corresponding LineOutputFormat. Throws
            an exception "'xxx' is not a known output format" on no match. 
            Useful for command line program parsing.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Sep(TIDP.LineOutputFormat)">
            <summary>
            Returns the seperation character: tab or comma.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Parse_Format_Arg_With_Die(System.String)">
            <summary>
            Similar to Parse_Format_Arg, but instead of throwing an exception, will
            print an error message to stderr and then exit the program on error. Even
            more useful for console applications.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Format(System.Object[])">
            <summary>
            Each field passed is sent to Transform() before finally
            being output in the appropriate format.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.Format(System.Collections.IList)">
            <summary>
            Each field passed is sent to Transform() before finally
            being output in the appropriate format.
            </summary>
        </member>
        <member name="M:TIDP.LineOutput.ToString">
            <summary>
            In StringBuilder mode, returns the buffer. Otherwise,
            returns something like "Writing to Stdout" or 
            "Writing to C:\TEMP\foo.txt".
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.LineOutput.Format2Ext(TIDP.LineOutputFormat)">
            <summary>
            Returns a file extension for the supplied LineOutputFormat.
            </summary>
        </member>
        <member name="P:TIDP.LineOutput.String_Builder">
            <summary>
            If you created the LineOutput in string builder mode,
            this gives you access to it.
            </summary>
        </member>
        <member name="P:TIDP.LineOutput.Num_Cols">
            <summary>
            Returns the number of columns based on the last call to Write*().
            </summary>
        </member>
        <member name="T:TIDP.Delegates">
            <summary>
            Holds some standard delegates that are often used to create
            anonymous functions.
            </summary>
        </member>
        <member name="T:TIDP.MathUtils2">
            <summary>
            A collection of math utilities. Will merge c.m.MathUtils into
            here and rename.
            </summary>
        </member>
        <member name="M:TIDP.MathUtils2.Log10_Distributed_Via_Step_Multiplier(System.Double,System.Double,System.Double)">
            <summary>
            Returns a list of numbers from start to end that increase in a
            logrithmic fashion via the specified multiplier. Always includes
            elemements at each decade (see example).
            </summary>
            <example>
            <code>
            Start: 100, End: 1050, Step Mult: 1.75x
            0 100.00
            1 175.00
            2 306.25
            3 535.94
            4 937.89
            5 1,000.00
            6 1,050.00
            </code>
            </example>
            <remarks>
            If the same start and end are passed, an array of size 1
            is always returned.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if any arguments are invalid.
            </exception>
        </member>
        <member name="M:TIDP.MathUtils2.Log10_Distributed_Via_Size(System.Double,System.Double,System.Int32)">
            <summary>
            Returns a list of numbers from start to end that increase in a
            logrithmic fashion such that there are num_elements in the returned
            array. Unlike Log10_Distributed_Via_Step_Multiplier, log10 decades --
            100, 1000, 10000, etc. -- are not automatically included as data points.
            See example.
            </summary>
            <example>
            <code>
            Start: 100, End: 1050, # Elements: 7
            0 100.00
            1 147.98
            2 218.98
            3 324.04
            4 479.50
            5 709.56
            6 1,050.00
            </code>
            </example>
            <remarks>
            If the same start and end are passed, an array of size 1
            is always returned.
            </remarks>
            <exception cref="T:System.ArgumentException">
            Thrown if any arguments are invalid.
            </exception>
        </member>
        <member name="M:TIDP.MathUtils2.Next_Log10_Decade(System.Double)">
            <summary>
            Returns a number at the next log decade greater than the
            passed number. See examples.
            </summary>
            <example>
            <code>
            999.99 -> 1,000
            1,000 -> 10,000
            1,001 -> 10,000
            </code>
            </example>
        </member>
        <member name="M:TIDP.MathUtils2.Max(System.Double[])">
            <summary>
            Returns NaN if no values are passed.
            </summary>
        </member>
        <member name="M:TIDP.MathUtils2.Parallel_Sum(System.Double[])">
            <summary>
            returns 1/(1/values[0] + 1/values[1] ...). If any one value is
            infinity, it is skipped.
            </summary>
        </member>
        <member name="M:TIDP.MathUtils2.Series_Sum(System.Double[])">
            <summary>
            returns values[0] + values[1] ....
            </summary>
        </member>
        <member name="T:TIDP.EepromData">
            <summary>
            Read and write a variety of EEPROM data files. EEPROM files
            contain a series of address/data segments. This class sits on top
            of a 3rd party tool, SRecord, to handle a variety of formats
            including Motorola SREC and Intel hex formats.
            </summary>
            <remarks>
            To create a binary file, construct a new EepromFile instance and
            then simply add data to it via Add(). You do not need to add data
            in sequential order. When done adding, call Write(). The data you
            previously supplied will then be checked to ensure that there were
            no duplicate entries for a given address, and ordered by address.
            An exception will be thrown on any error.
            <para/>
            The SRecord tool can be downloaded from http://srecord.sourceforge.net/.
            It is licensed under the GPL. It is OK to redistribute binaries. This
            library avoids GPL contamination by invoking the srec_dump program,
            not linking to the library itself.
            <para/>
            This API uses the SRecord tool's Cosmac hex file format as an intermediate 
            file format. When writing binary data, we write to this format and let
            the SRecord tool convert to the appropriate file format. When reading
            a file, we let the SRecord tool convert the input file into Cosmac
            format, which we can easily parse.
            </remarks>
        </member>
        <member name="M:TIDP.EepromData.Parse_Format_Arg(System.String)">
            <summary>
            Parses an argument such as "SREC", "TektronixExtendedBroken", etc.
            and returns the corresponding Format. Throws
            an exception "'xxx' is not a known EEPROM file format" on no match. 
            Useful for command line program parsing. Also maps x0 into
            TektronixExtendedBroken.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if could not lookup the format.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Parse_Format_From_Filename(System.String)">
            <summary>
            Uses the extension component of the filename passed as input to Parse_Format_Arg().
            So foo.x0 -&gt; TektronixExtendedBroken and foo.srec -&gt; SREC.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if could map the extension into a known format.
            </exception>
        </member>
        <member name="F:TIDP.EepromData.Format_If_Read">
            <summary>
            The original format of the file. Useful since one of the constructors
            supports automatically determining the file type by looking inside.
            Will be null if the data did not come from parsing an input file.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.Tools_Dir">
            <summary>
            You can set this to the directory where the srec_cat.exe tool
            is located. If not set, the directory where the invoking EXE
            is will be assumed.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.Label">
            <summary>
            Optional. Used in Compare.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.#ctor(TIDP.EepromData.Block[])">
            <summary>
            Creates a new EepromData and adds the specified block(s) to it.
            </summary>
            <param name="block"></param>
        </member>
        <member name="M:TIDP.EepromData.#ctor(System.Nullable{TIDP.EepromData.Format},System.String)">
            <summary>
            Parses the specified file and caches it's data. Regardless of the order of data
            blocks with the file -- for example, a block for address 0xFF listed before
            address 0x0 -- the resulting EepromData will be ordered low address to high
            address. Also, consecutive blocks will always be compacted together into a
            single block.
            </summary>
            <param name="format">
            One of our standard formats. You can also specify any format that the 
            srec_cat tool understands via the alternative constructor. If you pass
            null, the first line of the file will be inspected to determine the format.
            This is not perfect. Any x0 looking file will map to TektronixExtendedBroken.
            </param>
            <exception cref="T:System.Exception">
            Thrown on any error.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.#ctor(System.String)">
            <summary>
            See EepromData(format, infile). This version will automatically determine the
            format by looking at the first line in the file.
            </summary>
            <exception cref="!:">
            Thrown if the format can not be determined.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Add(System.UInt32,System.UInt32,System.Byte)">
            <summary>
            Creates a new segment filled with the specified byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Add(System.UInt32,System.Byte[],System.UInt32)">
            <summary>
            Limit the bytes in data to add to the EEpromData.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Add(TIDP.EepromData[])">
            <summary>
            Add all segments in the eeprom(s) passed.
            </summary>
            <param name="eeprom"></param>
        </member>
        <member name="M:TIDP.EepromData.Write(System.String,System.String,System.Action)">
            <summary>
            Writes the previous added blocks to an output file in the specified
            binary file format. format is one of the formats understood by 
            srec_cat. For example, "Motorola" or "Tektronix_Extended". Be sure 
            to call Add() first. 
            </summary>
            <remarks>
            Writes to a temporary file first to ensure that any output in outfile
            is not deleted on error. Checks to ensure that the output was really
            generated by seeing if the temp file really exists. Only then will
            Write() move this temporary output to the path specified by outfile.
            </remarks>
            <param name="format">A format string that the srec_cat tool understands.</param>
            <param name="outfile">Specify - to write to stdout.</param>
            <exception cref="T:System.Exception">
            Throws an exception on any error.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Write(TIDP.EepromData.Format,System.String,System.Action)">
            <summary>
            Writes the previous added blocks to an output file in the specified
            binary file format. Accepts a well-known format. See Write(string format, outfile)
            for a version that works with any srec_cat supported format.
            </summary>
            <param name="format"></param>
            <param name="outfile">Specify - to write to stdout</param>
        </member>
        <member name="M:TIDP.EepromData.ToLongString">
            <summary>
            See ToLongString(mode). Uses StringMode=Blocks. 
            </summary>
        </member>
        <member name="M:TIDP.EepromData.ToLongString(TIDP.EepromData.StringMode)">
            <summary>
            Formats the blocks to text a certain way.
            </summary>
            <remarks>
            <list type="">
            <item>
            When mode is Blocks, returns something like "0x000: 0x012345 [5 bytes]\n0x100: 0xABC [3 bytes]". I.e. a 
            line for each "block." Addresses are formated such that all
            will have the same length in the text.
            </item>
            <item>
            When mode is Bytes, returns something like "0x000: 0x01\n0x001: 0x23" etc. 
            Each byte will be listed on a separate line.
            </item>
            </list>
            </remarks>
        </member>
        <member name="M:TIDP.EepromData.Byte_At_Address(System.UInt32)">
            <summary>
            Returns the byte stored at the specified address. Returns null if
            there is none. Not too slow: just have to look at each block to
            see if the address could be there.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block_At_Address(System.UInt32,System.Int32,System.Nullable{System.Byte})">
            <summary>
            Returns an arbitrarily sized block present in the EEPROM. If a byte is
            not present and fill_empty_with is not null, it will be filled in with 
            fill_empty_with. But, if fill_empty_with is null, then an exception
            will be thrown.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if a non-existent byte is accessed and fill_empty_with is null.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Block_Range(System.UInt32,System.UInt32,System.Nullable{System.Byte})">
            <summary>
            Returns an arbitrarily sized block present in the EEPROM. If a byte is
            not present and fill_empty_with is not null, it will be filled in with 
            fill_empty_with. But, if fill_empty_with is null, then an exception
            will be thrown.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if a non-existent byte is accessed and fill_empty_with is null.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Sum_Bytes(System.Byte)">
            <summary>
            Adds all of the bytes in all blocks together and returns the sum. 
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Sum_Bytes(System.UInt32,System.UInt32)">
            <summary>
            Adds all of the bytes together and returns the sum. Skips any
            addresses that are not in the data.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Sum_Words(System.Boolean,System.UInt32,System.Byte,System.UInt32,System.UInt32)">
            <summary>
            Adds all of the bytes together and returns the sum as 64 bits, this version
            starts adding from the starting index and ignores values from addresses before the starting index.
             Checksum is calculated by adding Uint32 value, not by adding a byte
            For example, if the pFlash[0][1][2][3] = 0x01, 0x02, 0x03, 0x04 respectfully
            
            If reserved_bytes == false
                => checksum is added with 0x01020304 value, not added with 0x0A value (0x01 + 0x02 + 0x03 + 0x04) 
            If reserved_bytes == true
                => checksum is added with 0x04030201 value, not added with 0x0A value (0x01 + 0x02 + 0x03 + 0x04)      
            </summary>
            <param name="reverse_bytes">reverse the bytes before adding</param>
            <param name="starting_index_to_start_from"></param>
            <param name="end_index_to_end_at"></param>
            <param name="num_checksum_byte">is it a 4 bytes checksum or 8 bytes checksum</param>
            <param name="missing_byte_value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.EepromData.Update(System.UInt32,System.Byte)">
            <summary>
            Updates an existing byte.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if the address was not previously read into this EepromData.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Relocate(System.Int64)">
            <summary>
            Adds or removes the specified value to the starting address of each
            segment.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Compare(TIDP.EepromData,TIDP.EepromData,System.Boolean)">
             <summary>
             Compares two EepromData instances. Returns a summary and detail of the
             differences.
             </summary>
             <remarks>
             We always do a byte-by-byte comparison for the 
             entire range of addresses that both data1 and data2 span.
             For example, if data1 is {0xAA, 0xBB} at address 0
             and data2 is {0xBB, 0xEE, 0xFF} at address 1, Num_Match will be
             1 (address 1, byte 0xBB), Num_Match_Address_But_Not_Data
             will be 1 (address 2 has 0xCC in data1 and 0xEE in data2),
             and Num_Address_Mismatch will be 2 (data2 has address
             2 and 3 but data1 does not).
             <example>
             <code>
             Setup:
                 EepromData data1 = new EepromData();
                 data1.Add((UInt32)0, "0xAABB");
                 EepromData data2 = new EepromData();
                 data2.Add((UInt32)1, "0xBBEEFF");
                 var compare = EepromData.Compare(data1, data2);
            
             EepromData.CompareResult (compare):
                 Are_Equal: false
                 Num_Address_Mismatch: 2
                 Num_Match: 1
                 Num_Match_Address_But_Not_Data: 1
                 Error_Summary:
                    [0]: "starting addresses are not equal: 0x0 and 0x1"
                    [1]: "ending addresses are not equal: 0x0 and 0x1"
                    [2]: "1 bytes matched"
                    [3]: "1 bytes had same address, but different data"
                    [4]: "2 addresses were not common"
                 Differences: a list of differences
             </code>
             </example>
             </remarks>
             <param name="ok_if_missing_data">
             This is useful when doing flash programming read back. In many cases full flash file is
             not downloaded, and instead flash erase defaults are left (0xFF for each byte). To ignore
             missing bytes between data1 and data1, set this to true.
             </param>
        </member>
        <member name="M:TIDP.EepromData.Compare(TIDP.EepromData,System.Boolean)">
            <summary>
            See Compare(data1, data2).
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Create_Sample1(System.UInt32,System.UInt32,System.Byte)">
            <summary>
            Creates an Eeprom filled with the specified byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Create_Sample2(System.UInt32,System.UInt32)">
            <summary>
            Creates an Eeprom filled with bytes progressing from 0x00 through 0xFF.
            The bytes roll over to 0x00 after 0xFF.
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Ending_Address">
            <summary>
            This is the highest address accross all blocks. Not the
            highest block start address, but the highest address of
            actual data. CALCULATED.
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Num_Bytes">
            <summary>
            Returns the total number of bytes contained within. Calculated.
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Is_All_FFs">
            <summary>
            Returns true if the block contains nothing but
            0xFF bytes. In an EEPROM download scenario, this
            would mean you could skip this block because
            writing it would not change the EEPROM, since the
            only state change that is supported is 1 -> 0.
            This is also true if there are no bytes at all (zero length).
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Is_All_Nulls">
            <summary>
            Returns true if all addresses actually have null bytes. This
            is also true if there are no bytes at all (zero length).
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.#ctor(System.UInt32,System.Byte[],System.UInt32)">
            <summary>
            Limit the number of bytes in data to add to the block.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.#ctor(System.UInt32,System.Nullable{System.Byte}[],System.UInt32)">
            <summary>
            Limit the number of bytes in data to add to the block.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.#ctor(System.UInt32,System.UInt32,System.Byte)">
            <summary>
            The block will be filled with the specified byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Byte_At_Address(System.UInt32)">
            <summary>
            Returns the byte stored at the specified address. Returns null if
            there is none.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Update(System.UInt32,System.Byte)">
            <summary>
            Updates an existing byte.
            </summary>
            <exception cref="T:System.Exception">
            Thrown if the address was not previously read into this EepromData.
            </exception>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment(System.Int32,System.Int32)">
            <summary>
            Returns a segment of the overall block. Uses index, not adddress.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment(System.Int32,System.Int32,System.Byte)">
            <summary>
            Returns a segment of the overall block. Uses index, not adddress. If
            a byte is not defined in the segment, it is replaced by 
            null_replacement_byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment2(System.UInt32,System.Int32)">
            <summary>
            Returns a segment of the overall block. Uses adddress, not index.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment2(System.UInt32,System.Int32,System.Byte)">
            <summary>
            Returns a segment of the overall block. Uses adddress, not index . If
            a byte is not defined in the segment, it is replaced by 
            null_replacement_byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment3(System.UInt32,System.UInt32)">
            <summary>
            Returns a segment of the overall block. Uses adddress, not index.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Segment3(System.UInt32,System.UInt32,System.Byte)">
            <summary>
            Returns a segment of the overall block. Uses adddress, not index . If
            a byte is not defined in the segment, it is replaced by 
            null_replacement_byte.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Relocate(System.Int64)">
            <summary>
            Adds or removes the specified value to the starting address.
            Basically the same as doing Starting_Address += address_delta.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Sum_Words(System.Byte)">
            <summary>
            sum program flash and takes into consideration teh program flash check sum size and the way it should be added based on IC.
            set sum_bytes 
            </summary>
            <param name="missing_byte_value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.EepromData.Block.Sum_Bytes(System.Byte)">
            <summary>
            Adds all of the bytes together and returns the sum. Including last 4 bytes...
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Sum_Bytes(System.Byte,System.Int32,System.Int32)">
            <summary>
            Adds all of the bytes together and returns the sum, this version
            starts adding from the starting index and ignores values from addresses before the starting index.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.Sum_Words(System.Byte,System.Int32,System.Int32)">
            <summary>
            Adds all of the bytes together and returns the sum as 64 bits, this version
            starts adding from the starting index and ignores values from addresses before the starting index.
            
             Checksum is calculated by adding Uint32 value, not by adding a byte
            For example, if the pFlash[0][1][2][3] = 0x01, 0x02, 0x03, 0x04 respectfully
            => checksum is added with 0x01020304 value, not added with 0x0A value (0x01 + 0x02 + 0x03 + 0x04)
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Block.ToString">
            <summary>
            Returns something like "0x0: 0xABCD" for bytes ABCD at address 0.
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Block.Is_All_FFs">
            <summary>
            Returns true if the block contains nothing but
            0xFF bytes. In an EEPROM download scenario, this
            would mean you could skip this block because
            writing it would not change the EEPROM, since the
            only state change that is supported is 1 -> 0.
            This is also true if there are no bytes at all (zero length).
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Block.Is_All_FFs_Or_Null">
            <summary>
            Returns true if the block contains nothing but
            0xFF or null bytes. In an EEPROM download scenario, this
            would mean you could skip this block because
            writing it would not change the EEPROM, since the
            only state change that is supported is 1 -> 0.
            This is also true if there are no bytes at all (zero length).
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Block.Is_All_Nulls">
            <summary>
            Returns true if all addresses actually have null bytes. This
            is also true if there are no bytes at all (zero length).
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Block.Item(System.UInt32)">
            <summary>
            Indexed by data offset, not by address. See Byte_At_Address(address)
            for this.
            </summary>
        </member>
        <member name="P:TIDP.EepromData.Block.Item(System.Int32)">
            <summary>
            Indexed by data offset, not by address. See Byte_At_Address(address)
            for this.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.Format.TektronixExtendedBroken">
            <summary>
            The TektronixExtended files produced by the UCD92XX compiler tools are broken.
            Both the length and checksum fields are invalid. This form will parse these files
            directly, bypassing the srec_cat tool. Obviously length and checksum will be ignored.
            On any output, the srec_cat tool will still be used and valid TektronixExtended format
            will be produced.
            </summary>
        </member>
        <member name="T:TIDP.EepromData.Parser">
            <summary>
            A way to define a custom EepromData parser. Just implement the Parse
            method. See CosmacParser for example.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.Parser.Parse(System.String,System.Int32,TIDP.EepromData.ReadCache)">
            <summary>
            A line string and number are passed. On fatal error, you should
            throw an exception, but with a simple message without line number
            or line text. If you see data that allows you to add to the current
            ReadCache, invoke read_cache.Add().
            </summary>
        </member>
        <member name="T:TIDP.EepromData.CosmacParser">
            <summary>
            Used to parse a "Cosmac" format EEPROM file. This is the generic, low-level
            format that we convert other formats to via srec_cat.
            </summary>
        </member>
        <member name="T:TIDP.EepromData.TektronixExtendedBrokenParser">
            <summary>
            Used to parse an x0 firmware image produced by UCD92XX compiler, which is horribly
            broken: bad count and checksum bytes on each line, so we ignore those fields.
            </summary>
            <remarks>
            From the srec_tektronix_extended man page:
            
            Lines always start with a percent (%) character. Each line consists of 5 fields. 
            These are the length field, the type field, the checksum, the address field (including 
            address length), and the data field.
            
            Record Length
                The record length field is a 2 character (1 byte) field that specifies the number of 
                characters (not bytes) in the record, excluding the percent, the length field, the type 
                field and the checksum. 
            Type
                The type field is a 1 character field that specifies whether the record is data (6) 
                or termination (8).
            Checksum
                The checksum is an 2 character (1 byte) field that represents the sum of all the 
                nibbles on the line, excluding the checksum. 
            Address
                This is a 9 character field. The first character is the address size; it is always 8. 
                The remaining 8 chgaracters are the 4-byte address that specifies where the data 
                is to be loaded into memory.
            Data
                The data field contains the executable code, memory-loadable data or descriptive 
                information to be transferred.
            </remarks>
        </member>
        <member name="T:TIDP.EepromData.CompareResult">
            <summary>
            Returned by Compare(data1, data2).
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Are_Equal">
            <summary>
            True if the two EepromDatas are equal.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Num_Match">
            <summary>
            For common addresses, the number of matches.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Num_Match_Address_But_Not_Data">
            <summary>
            For common addresses, the number of differences.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Num_Address_Mismatch">
            <summary>
            Number of unique addresses that the two EEpromDatas do
            not share in common.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Low_Address">
            <summary>
            Lowest address in both inputs.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.High_Address">
            <summary>
            Highest address in both inputs.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Error_Summary">
            <summary>
            A list of the general errors. Will be an empty list if there
            were no errors. Will also summarize Num_Match_Address_But_Not_Data
            and Num_Address_Mismatch if there were errors.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Differences">
            <summary>
            A breakdown of all differences found.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Difference.Address">
            <summary>
            The address the difference is for.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Difference.Byte1">
            <summary>
            Returns null if the address is not present in data1.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Difference.Byte2">
            <summary>
            Returns null if the address is not present in data2.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.CompareResult.Difference.Summary">
            <summary>
            A summary of the differemce. Something like "Address 0x0: 0xFF in data1, 0xAA in data2",
            </summary>
        </member>
        <member name="T:TIDP.EepromData.ReadCache">
            <summary>
            Used to temporarily store the contents of a binary file that
            was read and then populate an EEpromData instance. Generally
            not used unless you create your own parser.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.ReadCache.Next_Addr">
            <summary>
            The next address if the "," continuation character
            is used.
            </summary>
        </member>
        <member name="M:TIDP.EepromData.ReadCache.Populate(TIDP.EepromData)">
            <summary>
            Create action EepromData block(s) based on whatever was in the
            input file we parsed.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.StringMode.Blocks">
            <summary>
            Just reports on blocks.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.StringMode.Bytes">
            <summary>
            Reports on each byte seperately.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.StringMode.HexDump">
            <summary>
            Dumps both the byte values and ASCII interpretation of
            a byte. If a byte is missing, just leaves a slot empty.
            </summary>
        </member>
        <member name="F:TIDP.EepromData.StringMode.Summary">
            <summary>
            Summarize the EEPROM data.
            </summary>
        </member>
        <member name="T:TIDP.RegexUtils">
            <summary>
            Regular expression (Regex) utilities. The two Named_Groups() methods are the
            most useful methods, and provide an easy way to get at named groups.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TIDP.RegexUtils.Named_Groups(System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Match)" -->
        <!-- Badly formed XML comment ignored for member "M:TIDP.RegexUtils.Named_Groups``1(System.Text.RegularExpressions.Regex,System.Text.RegularExpressions.Match)" -->
        <member name="T:TIDP.RegexUtils.NamedCapturesCache">
            <summary>
            Maps capture class type to the NamedCaptures for it.
            </summary>
        </member>
        <member name="T:TIDP.RegexUtils.NamedCaptures">
            <summary>
            Given class FooBar { public string Cap1; public int Cap2; } that
            is used to wrap a Regex grouping (capture), this would have an
            entry for Cap1 and an entry for Cap2.
            </summary>
        </member>
        <member name="P:Runtime.OS">
            <summary>
            Determine OS type. Result is cached after first computation. May be a better
            way to do this but we'll see how this goes.
            </summary>
        </member>
        <member name="T:TIDP.StringMacro2">
            <summary>
            Replaces custom macros like {FOO} and {BAR} inside of a string.
            Also supports more standard macros like file date/time. 
            </summary>
        </member>
        <member name="M:TIDP.StringMacro2.Add_Macro(System.String,System.Object)">
            <summary>
            Replaces a macro with the ToString() value of the replace object. If
            replace is null, adds "---".
            </summary>
        </member>
        <member name="M:TIDP.StringMacro2.Replace_Macros(System.String,System.Boolean)">
            <summary>
            Perform the macro replacement.
            </summary>
            <param name="template">Something like "Log-{T}.txt".</param>
            <param name="pass_unknown">
            If true, it is OK to have an unknown macro. If false, an 
            exception will be thrown in this case.
            </param>
            <exception cref="T:System.Exception">
            Thrown when pass_unknown is true and the template contains an
            unknown macro.
            </exception>
        </member>
        <member name="T:TIDP.ReflectionUtils">
            <summary>
            Some reflection utilities. Get() and Set() are useful to get/set 
            a field or property in an object.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Loaded_Assemblies_Info">
            <summary>
            Returns a multi-line string describing the assemblies that are loaded
            into the .NET runtime.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Member_Type(System.Object,System.String)">
            <summary>
            For properties and fields, returns the type of the specified member. For
            functions, returns the return type of the function. If neither of these 
            conditions is true or the member can not be found, returns null.
            </summary>
            <param name="obj"></param>
            <param name="member_name"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.ReflectionUtils.Method_Info(System.Object,System.String)">
            <summary>
            Returns the FieldInfo for a specified member. Returns null if it
            is not defined or is not a field.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Field_Or_Property_Info(System.Object,System.String)">
            <summary>
            Returns the MemberInfo for the field or property named member_name 
            defined in the passed object. Returns null if there is none.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Field_Info(System.Object,System.String)">
            <summary>
            Returns the FieldInfo for a specified member. Returns null if it
            is not defined or is not a field.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Property_Info(System.Object,System.String)">
            <summary>
            Returns the FieldInfo for a specified member. Returns null if it
            is not defined or is not a field.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Field_Or_Property_Type(System.Object,System.String)">
            <summary>
            Returns the type of a field or property.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Set(System.Object,System.String,System.Object)">
            <summary>
            Set a field or property. Throws an exception if obj does not contain a field 
            or property member_name.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Get(System.Object,System.String)">
            <summary>
            Throws an exception if obj does not contain a field or property member_name.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Enum_Members(System.Type)">
            <summary>
            Returns all of the enumeration values for an enum as a 
            list of their MemberInfo.
            </summary>
        </member>
        <member name="M:TIDP.ReflectionUtils.Debug_Fields_And_Properties(System.String,System.Object,System.String[])">
            <summary>
            Generates a simple debug string for each field or property name
            passed. Something like "Foobar: 1.2345\n   ABC:xyz\n" where the
            format is name: value for each field/property name passed. You can
            pass a null or empty string to print an empty line (line break).
            </summary>
            <param name="indent">Indent each line by the specified string.</param>
            <param name="o"></param>
            <param name="field_or_property_names"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.SortItemList.Sorted">
            <summary>
            Sorts the items that have been added and returns the sorted list.
            </summary>
        </member>
        <member name="M:TIDP.SortItemList`1.Sorted">
            <summary>
            Sorts the items that have been added and returns the sorted list.
            </summary>
        </member>
        <member name="T:TIDP.StringUtils">
            <summary>
            A collection of string utilities. Format() is the most useful method.
            It accepts un-numbered placeholders like StringUtils.Format("{} {}", "hello", "world")
            or StringUtils.Format("{:X2}", some_byte).
            </summary>
            <remarks>
            A port to C# of c.m.StringUtils.
            </remarks>
        </member>
        <member name="M:TIDP.StringUtils.Format_Std(System.String,System.Object[])">
            <summary>
            Format using the "InvariantCulture", which is mostly US-centric formatting.
            Key is that numbers will use dot (.) as the decimal separator.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Format_Std(System.String,System.Collections.ArrayList)">
            <summary>
            Format using the "InvariantCulture", which is mostly US-centric formatting.
            Key is that numbers will use dot (.) as the decimal separator.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Gen_Random(System.Int32)">
             <summary>
            Creates a random string of characters of length Num_Chars. Chars 
             a-zA-Z0-9 are used. If Word_Size is supplied the string will be broken
             down into words of the stated length, with a possible partial length
             word at the end of the string or a trailing space at the end.
             </summary>
             <param name="Num_Chars"></param>
             <returns></returns>
        </member>
        <member name="M:TIDP.StringUtils.Multiply(System.String,System.Int32)">
            <summary>
            Equivalent to Base_String x Num_Times in Perl. Returns a String
            with Base_String repeated Num_Times times.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Indent(System.Object,System.String)">
            <summary>
            Inserts indent_text at the start of every line in orig_text.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Pluralize(System.Double,System.String,System.Boolean)">
            <summary>
            Pluralize(1, "new alert", False) => "new alert"
            Pluralize(0, "new alert", True) => "0 new alerts"
            Pluralize(1, "new alert", True) => "1 new alert"
            Pluralize(2, "new alert", True) => "2 new alerts"
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.MD5Sum(System.String)">
            <summary>
            Computes the MD5 checksum of the specified string. The checksum is returned as
            a 0xAA.. formatted hex string.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Trim_Extra_Whitespace(System.String)">
            <summary>
            Trims leading and trailing whitespace from a string.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Is_Empty_Or_Whitespace(System.String)">
            <summary>
            Returns true if the string passed is null, "", or only contains
            whitespace (newline, tab, space).
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Join(System.String,System.String,System.Collections.IList)">
            <summary>
            Joins the ToString() version of each element, seperated by standard_sep.
            The last element is seperated by sep_for_last_string. For example,
            Join(", ", " and ", { "a", "b", "c"}) returns "a, b and c".
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Join_Comma_And(System.Collections.IList)">
            <summary>
            Join_Comma_And({ "a", "b", "c"}) returns "a, b and c". See
            Join(string standard_sep, string sep_for_last_string, IList list)
            for different string separators.
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.Mixed_Case(System.String)">
            <summary>
            Converts "hello_word" to "Hello_World" and "hello world" to "Hello World".
            </summary>
        </member>
        <member name="M:TIDP.StringUtils.CSharp_Literal_String(System.String)">
            <summary>
            Returns some C# code that is a legal string literal to represent the
            text that was passed. For example, passing "a" + Environment.Newline + "b"
            will return 
            </summary>
        </member>
        <member name="T:TIDP.TextBlockFormatter">
            <summary>
            Can automatically perform word wrapping and/or smart indendting on 
            an input string. Handles either MS-DOS or UN*X style newlines in
            input and can output either style as well.
            </summary>
            <example>
            The following VB.NET code:
            <code>
            Dim str_ex As String = "This is paragraph #1. It should wrap some." + _
               vbCrLf + "This is another para." + vbCrLf + vbCrLf + _
               "And above was an empty line."
            Dim formatter As New TextBlockFormatter()
            formatter.Max_Line_Length = 30
            formatter.Indent = "+ "
            Console.WriteLine(formatter.Format(str_ex))
            </code>
            will output the following (| shows start of line):
            <code>
            + This is paragraph #1. It 
              should wrap some.
            + This is another para.
            
            + And above was an empty line.
            </code>
            </example>
            <remarks>
            Donated to TI by Mike Muegel.
            </remarks>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Split_Expr">
            <summary>
            Word wrap will be done on characters matching this expression. Basically
            whitespace and punctuation (-,.).
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Max_Line_Length">
            <summary>
            The maximum length of each line. Lines will be wrapped after this
            many characters. Default is 72.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Word_Wrap">
            <summary>
            Whether to do word wrap at all. You might disable word wrap if 
            you want to indent each line but do not want to wrap. Default is true.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Indent">
            <summary>
            This is prepended before each separate line of text. Default is
            to not add anything ("").
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Indent_Mode">
            <summary>
            How to interpret the Indent string. Value should be an enumeration
            from TextBlockIndentModes. Default is TextBlockIndentModes.OriginalLinesOnly.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Indent_Empty">
            <summary>
            If true, empty lines will have Indent pre-pended to them. Otherwise, 
            they will still empty. Default is false. Only used when Indent_Mode is 
            set to OriginalLinesOnly or AllLines.
            </summary>
        </member>
        <member name="F:TIDP.TextBlockFormatter.Newline">
            <summary>
            The newline character to use in the result. It does not matter whether
            \n (UN*X) or \n\r (MS-DOS) is used in input. Either is accepted and
            handled regardless of what Newline is set to. But \n and \n\r are
            normalized to whatever Newline is set to. So, for example, you might
            pass text with UN*X-like newline sequence (\n) and get back text with
            all MS-DOS sequences (\n\r). Default is the Environment.NewLine
            setting, which should do the right thing depending on the system you
            are on.
            </summary>
        </member>
        <member name="M:TIDP.TextBlockFormatter.#ctor">
            <summary>
            Constructor accepts no arguments. Simply set the public fields before 
            calling Format.
            </summary>
        </member>
        <member name="M:TIDP.TextBlockFormatter.Format(System.String)">
            <summary>
            Applies word-wrap and indent rules to format the input string.
            </summary>
            <param name="input_string">The String to format.</param>
        </member>
        <member name="T:TIDP.Misc.TextWrapper">
            <summary>
            A port of Christopher J. Madsen's Perl Text::Wrapper
            module. http://cpan.uwinnipeg.ca/htdocs/Text-Wrapper/Text/Wrapper.html
            </summary>
            <remarks>
            Donated to TI by Mike Muegel.
            </remarks>
        </member>
        <member name="F:TIDP.Misc.TextWrapper.Body_Prefix">
            <summary>
            The text that begins the second and following lines of
            a paragraph. Default is "".
            </summary>
        </member>
        <member name="F:TIDP.Misc.TextWrapper.Paragraph_Prefix">
            <summary>
            The text that begins the first line of each paragraph.
            Default is "".
            </summary>
        </member>
        <member name="F:TIDP.Misc.TextWrapper.Columns">
            <summary>
            The number of columns to use.  This includes any text
            in body_start or par_start.
            </summary>
        </member>
        <member name="F:TIDP.Misc.TextWrapper.Line_Seperator">
            <summary>
            What to insert when text is broken into lines. Default is CRLF 
            (\r\n) on Windows and LF (\n) on UN*X-like systems.
            </summary>
        </member>
        <member name="T:TIDP.TIArgumentException">
            <summary>
            An ArgumentException with an easy to use constructor that accepts format strings.
            </summary>
        </member>
        <member name="T:TIDP.NeverException">
            <summary>
            Simply for debugging. Useful within a code block when you want to
            temporarily stop catching exceptions. By doing a "catch (NeverException)"
            and ensuring you never throw this exception, your exception handler will
            never be invoked.
            </summary>
        </member>
        <member name="T:TIDP.IEasySerializer`1">
            <summary>
            A common interface for serializing and object to/from a file.
            XmlEasySerializer implements this.
            </summary>
        </member>
        <member name="M:TIDP.IEasySerializer`1.Save(`0,System.String)">
            <summary>
            Serialize to the named filename or, if not supplied, yje
            Default_Filename property.
            </summary>
            <param name="obj"></param>
            <param name="filename"></param>
        </member>
        <member name="M:TIDP.IEasySerializer`1.Save(`0,System.IO.Stream)">
            <summary>
            Serializes obj to Stream. Does not close Stream when done.
            </summary>
            <param name="obj"></param>
            <param name="stream"></param>
        </member>
        <member name="M:TIDP.IEasySerializer`1.Restore(System.String)">
            <summary>
            De-Serializes from the named filename or, if not supplied, the
            Default_Filename property.
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.IEasySerializer`1.New">
            <summary>
            Creates a new T object and returns it.
            </summary>
        </member>
        <member name="M:TIDP.IEasySerializer`1.Restore(System.IO.Stream)">
            <summary>
            De-Serializes from a Stream. Does not close the Stream when done.
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.IEasySerializer`1.Default_Filename">
            <summary>
            The default filename to use for Save and Restore methods when no
            filename is supplied.
            </summary>
        </member>
        <member name="P:TIDP.IEasySerializer`1.Description">
            <summary>
            A short description of what is being serialized to add to the errors
            that can be thrown.
            </summary>
        </member>
        <member name="T:TIDP.IEasySerializerContainer">
            <summary>
            
            </summary>
        </member>
        <member name="T:TIDP.EasyHtml">
            <summary>
            A simple way to build up an HTML fragment. Call ToString()
            to get the HTML.
            </summary>
            <remarks>
            TODO: add support for a full HEAD-BODY fragment as well via
            an enumeration.
            </remarks>
        </member>
        <member name="F:TIDP.EasyHtml.Auto_Escape">
            <summary>
            Whether to automatically escape (encode) the use of &lt; and
            &gt; characters in various methods. Default is false.
            </summary>
        </member>
        <member name="F:TIDP.EasyHtml.Break_On_Punctuation">
            <summary>
            If true and Auto_Escape is true, text added via Add_* containing [/\-] 
            characters will be given hints so that a break can occur there. The 
            default is true.
            </summary>
        </member>
        <member name="M:TIDP.EasyHtml.Clear">
            <summary>
            Clear all existing markup.
            </summary>
        </member>
        <member name="M:TIDP.EasyHtml.Add(System.String)">
            <summary>
            Add some text and escape HTML markup if Auto_Escape is true.
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:TIDP.EasyHtml.Add_Markup(System.String)">
            <summary>
            Add some text and don't do any escaping of HTML markup, regardless
            of the setting of Auto_Escape.
            </summary>
        </member>
        <member name="M:TIDP.EasyHtml.Encode(System.String)">
            <summary>
            Escape &lt; and &gt; in a string and add character split
            hints.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.EasyHtml.Add_Element(System.String,System.String)">
            <summary>
            Adds a generic element. Example: Add_Element("CODE", "my text")
            will add &lt;CODE&gt;my text&lt;/CODE&gt;.
            </summary>
            <param name="tag"></param>
            <param name="text_or_html"></param>
        </member>
        <member name="M:TIDP.EasyHtml.Add_Element(System.String,System.String,System.String)">
            <summary>
            Adds a generic element. Example: Add_Element("CODE", "class='foo'", "my text")
            will add &lt;CODE class='foo'&gt;my text&lt;/CODE&gt;.
            </summary>
            <param name="tag"></param>
            <param name="tag_attributes"></param>
            <param name="text_or_html"></param>
        </member>
        <member name="M:TIDP.EasyHtml.Add_Element(System.String,System.String,System.String,System.Object[])">
            <summary>
            Adds a generic element with support for StringUtils.Format formatting.
            </summary>
            <param name="tag"></param>
            <param name="tag_attributes"></param>
            <param name="text_or_html"></param>
        </member>
        <member name="M:TIDP.EasyHtml.Begin_List">
            <summary>
            Start a new list. Supports nested lists. While you don't have to,
            you probably should call End_List() to have somewhat decent looking
            HTML.
            </summary>
        </member>
        <member name="M:TIDP.EasyHtml.ToString">
            <summary>
            Returns the full HTML markup so far.
            </summary>
        </member>
        <member name="T:TIDP.ConvertUtils">
            <summary>
            Data type conversion utilities. ConvertUtils.To&lt;T&gt;(object value)
            is a quick way to convert to the passed type. if conversion via
            IConvertible is possible, it is used. Otherwise, simple casting is
            done. Either way a runtime exception will occur if the conversion is
            not possible.
            </summary>
        </member>
        <member name="M:TIDP.ConvertUtils.From_IConvertible``1(System.IConvertible)">
            <summary>
            Returns the argument, a number, typed to the specified 
            type. Useful when within a generics class when you don't
            know the type you want to convert to, but you know the
            conversion is possible.
            </summary>
            <example>
            int x = 1.1;
            // Know TValue is something like float, double, etc.
            TValue value = ConvertUtils.Convert&lt;TValue&gt;(x);
            </example>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.ConvertUtils.To``1(System.Object)">
            <summary>
            A quick way to convert to the passed type. If conversion via
            IConvertible is possible, it is used. Otherwise, simple casting is
            done. Either way a runtime exception will occur if the conversion is
            not possible.
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.ConvertUtils.To(System.Object,System.Type)">
            <summary>
            Converts value to the specified numeric return type 
            (sbyte, UInt32, etc). If conversion via
            IConvertible is possible, it is used. Otherwise, simple casting is
            done. Either way a runtime exception will occur if the conversion is
            not possible.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TIDP.FormatUtils">
            <summary>
            Miscellaneous numeric/object format utils. Many methods provide shortcuts to
            format numbers as strings using by 1) automatically determining multiplier 
            such as u, k, m, M, etc and 2) allowing you to
            specify units and decimal places. Also has pre-canned format rules for common
            items we work with (Hz, for example). All also handle formatting null/NaN as "---"
            and +- infinity.
            </summary>
            <remarks>
            See NumberFormatProviderWithAutoUnits
            for an IFormatProvider inteface to this functionality (useful for modifying how
            a control formats, such as a column in a grid).
            </remarks>
        </member>
        <member name="F:TIDP.FormatUtils.Null_String">
            <summary>
            What to use for a number when it is null. 
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Precision2Format(System.Int32,System.Int32,System.Double)">
            <summary>
            Returns a standard .NET format string to format a number
            to the supplied number of decimal places: you specify minimum
            Precision2Format(0, 3, 3.66666) would format to "3.667",
            Precision2Format(0, 3, 3.3) would format to "3.3", and
            Precision2Format(3, 3, 3.3) would format to "3.300".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Precision2Format(System.Int32,System.Double)">
            <summary>
            Returns a standard .NET format string to format a number
            to the supplied number of decimal places. But can also
            be -1, in which case only the decimal places needed to show
            the full precision will be used.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Precision2Format(System.Int32)">
            <summary>
            Returns a standard .NET format string to format a number
            to the supplied number of decimal places.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.String(System.String)">
            <summary>
            if the string is empty or null, returns "---". Otherwise, returns the
            string.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Number(System.Nullable{System.Double})">
            <summary>
            Uses precision -1: show as many decimal places as needed. Can also return ∞, -∞, or
            Undef (for null), or NaN (divide by zero).
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scientific(System.Double)">
            <summary>
            A simpler format string than the .NET built-in E/e modes that will
            show 1 digit precision or as many digits as required to show the
            available precision (up to 10). Examples:
            
            Normal              You Get
            ------              -------
            E  1.000000E-003    1.0E-3
            E4 1.0001E+003      1.0001E+3
            E4 1.0100E+003      1.001E+3
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scientific(System.Double,System.Int32)">
            <summary>
            Shows the specified number of decimal places always. If -1,
            shows the maximum number available. See Scientific(number).
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scientific(System.Double,System.Int32,System.Boolean)">
            <summary>
            Shows at maximum the specified number of decimal places. But shows less
            decimal places if possible. For example, Scientific(0.1001, 5, true)
            will return "1.001E-1". But Scientific(0.1001, 5, false) will return
            "1.00100E01".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Timespan(System.TimeSpan,System.Int32)">
            <summary>
            Formats the timestring to the specified number of millisecond
            precision digits. Uses similar formatting syntax as TimeSpan.ToString():
            [d+]hh:mm:yy[.sssssss] where s is optional milliseconds and "d+" 
            represents days if > 24 hours.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Is_Real_Number(System.Nullable{System.Double})">
            <summary>
            Returns false if a number is +- infinity, null, or NaN.
            </summary>
            <param name="number"></param>
        </member>
        <member name="M:TIDP.FormatUtils.Scale(System.Nullable{System.Double},System.Int32,System.String)">
            <summary>
            Automatically adds "k", "m", etc prefix to base_unit and converts 
            number using appropriate multiplier. For example, 
            Number(1000, 3, "Hz") becomes "1.000 kHz".
            </summary>
            <param name="decimal_places">
            Pass -1 to show only the minimum number of decimal places present in the
            number.
            </param>
        </member>
        <member name="M:TIDP.FormatUtils.Scale(System.Nullable{System.Double},System.Int32,TIDP.FormatUtils.UnitID)">
            <summary>
            Automatically adds "k", "m", etc to the unit and converts 
            number using appropriate multiplier. For example, 
            Number(1000, 3, UnitID.Hertz) becomes "1.000 kHz". Some
            UnitIDs will never be scalled.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scale(System.Nullable{System.Double},System.Int32,System.Int32,System.String)">
            <summary>
            Automatically adds "k", "m", etc prefix to base_unit and converts 
            number using appropriate multiplier. For example, 
            Number(1000, 0, 3, "Hz") becomes "1 kHz".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scale(System.Nullable{System.Double},System.Int32,System.Int32,TIDP.FormatUtils.UnitID)">
            <summary>
            Automatically adds "k", "m", etc to the unit and converts 
            number using appropriate multiplier. For example, 
            Number(1000, 0, 3, UnitID.Hertz) becomes "1 kHz". Some
            UnitIDs will never be scalled.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Scale(System.Nullable{System.Double},TIDP.FormatUtils.UnitID)">
            <summary>
            Automatically adds "k", "m", etc to base_unit and converts 
            number using appropriate multiplier. Uses a decimal precision 
            that is pre-defined for the units. For example, Scale(1000, 
            UnitID.Hertz) becomes "1.000 kHz" while Scale(2000, UnitID.RPM)
            becomes "2,000 RPM".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Volt(System.Nullable{System.Double},System.Int32)">
            <summary>
            Volt(.005, 3) returns "5.000 mV". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Volt(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Volt(.005) returns "5.000 mV".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Amp(System.Nullable{System.Double},System.Int32)">
            <summary>
            Amp(.005, 3) returns "5.000 mA". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Amp(System.Nullable{System.Double})">
            <summary>
            Uses 2 decimal place formatting, and Amp(.005) returns "5.00 mA".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Celcius(System.Nullable{System.Double},System.Int32)">
            <summary>
            Celcius(30, 3) returns "30.000 °C". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Celcius(System.Nullable{System.Double})">
            <summary>
            Uses 1 decimal place formatting, and Celcius(30) returns "30.0 °C".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Celcius_Per_Volt(System.Nullable{System.Double},System.Int32)">
            <summary>
            Celcius(30, 3) returns "30.000 °C/V". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Celcius_Per_Volt(System.Nullable{System.Double})">
            <summary>
            Uses 1 decimal place formatting, and CelciusPerVolt(30) returns "30.0 °C/V".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Farad(System.Nullable{System.Double},System.Int32)">
            <summary>
            Farad(5e-6, 3) returns "5.000 μF". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Farad(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Farad(5e-6) returns "5.000 μF".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Henry(System.Nullable{System.Double},System.Int32)">
            <summary>
            Henry(5e-3, 3) returns "5.000 mH". If decimal places is -1, then 
            only the needed number of places will be shown. If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Henry(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Henry(5e-3) returns "5.000 mH".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Hertz(System.Nullable{System.Double},System.Int32)">
            <summary>
            Hertz(5e3, 3) returns "5.000 kHz". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Hertz(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Hertz(5e3) returns "5.000 kHz".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Ohm(System.Nullable{System.Double},System.Int32)">
            <summary>
            Ohm(5e-3, 3) returns "5.000 mΩ". If decimal places -1, then 
            only the needed number of places will be shown, up to a maximum 
            of 3 decimal places shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Ohm(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Ohm(5e-3) returns "5.000 mΩ".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Watt(System.Nullable{System.Double},System.Int32)">
            <summary>
            Watt(5e3, 3) returns "5.000 kW". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Watt(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Watt(5e3) returns "5.000 kW".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Millimeter_Squared(System.Nullable{System.Double},System.Int32)">
            <summary>
            Millimeter_Squared(50, 3) returns "50.000 mm²". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Millimeter_Squared(System.Nullable{System.Double})">
            <summary>
            Millimeter_Squared(50) returns "50.000 mm²".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Millimeter(System.Nullable{System.Double},System.Int32)">
            <summary>
            Millimeter(20, 3) returns "20.000 mm". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Millimeter(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Millimeter(20) returns "20.000 mm".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Percent(System.Nullable{System.Double},System.Int32)">
            <summary>
            Percent(20, 3) returns "20.000 %". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Percent(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Percent(20) returns "20.000 %".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Charge(System.Nullable{System.Double},System.Int32)">
            <summary>
            Charge(20, 3) returns "20.000 C". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Charge(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Charge(20) returns "20.000 C".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Thermal_Resistance(System.Nullable{System.Double},System.Int32)">
            <summary>
            Thermal_Resistance(20, 3) returns "20.000 °C/W". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Thermal_Resistance(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Thermal_Resistance(20) returns "20.000 °C/W".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Siemens(System.Nullable{System.Double},System.Int32)">
            <summary>
            Siemens(20, 3) returns "20.000 S". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Siemens(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Siemens(20) returns "20.000 S".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.RPM(System.Nullable{System.Double},System.Int32)">
            <summary>
            RPM(200, 1) returns "200.1 RPM". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.RPM(System.Nullable{System.Double})">
            <summary>
            Uses 0 decimal place formatting and does not scale. RPM(2000) returns "2,000 RPM".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Volt_Per_Celcius(System.Nullable{System.Double},System.Int32)">
            <summary>
            Volt_Per_Celcius(.005, 3) returns "5.000 mV". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Volt_Per_Celcius(System.Nullable{System.Double})">
            <summary>
            Uses 3 decimal place formatting, and Volt_Per_Celcius(.005) returns "5.000 mV".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Gain(System.Nullable{System.Double},System.Int32)">
            <summary>
            Gain(5, 1) returns "5.0 V/V". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Gain(System.Nullable{System.Double})">
            <summary>
            Only shows decimal places when needed. For example, Gain(5) 
            returns "5 V/V".
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Seconds(System.Nullable{System.Double},System.Int32)">
            <summary>
            Seconds(5, 1) returns "5.0 s". If decimal places is -1, then 
            only the needed number of places will be shown.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.Seconds(System.Nullable{System.Double})">
            <summary>
            Only shows decimal places when needed. For example, Seconds(5) 
            returns "5 s".
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.UnitID.Gain">
            <summary>
            "5x" etc.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.UnitID.Millimeter">
            <summary>
            Force millimeter.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.UnitID.None">
            <summary>
            Special: do not add any unit.
            </summary>
        </member>
        <member name="T:TIDP.FormatUtils.UnitHash">
            <summary>
            Information about known units we support. A hash indexed by the
            Unit enum. A pre-defined instance of this is available in the static 
            FormatUtils.Units field.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.UnitHash.Find_Short_Label(System.String)">
            <summary>
            Maps a units short label like "Ω" or "V" back into it's 
            Unit info. Returns null if no match.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.Prefix.Multiplier">
            <summary>
            Killo is 1000. Milli is 1e-3. Etc.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.Prefix.Prefix_Short_Unicode">
            <summary>
            µ etc. A unicode single character string.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.Prefix.Prefix_Short_ASCII">
            <summary>
            u etc. An ASCII single character string.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.Prefix.Prefix_Long">
            <summary>
            Micro, Kilo, etc.
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Pico">
            <summary>
            1e-12
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Nano">
            <summary>
            1e-9
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Micro">
            <summary>
            1e-6
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Milli">
            <summary>
            1e-3
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.None">
            <summary>
            1
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Kilo">
            <summary>
            1e3
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Mega">
            <summary>
            1e6
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Giga">
            <summary>
            1e9
            </summary>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixID.Tera">
            <summary>
            1e12
            </summary>
        </member>
        <member name="T:TIDP.FormatUtils.PrefixHash">
            <summary>
            Information about SI prefixes/multiplies such as nano, deci, etc. A hash indexed by the
            Unit enum. A pre-defined instance of this is available in the static 
            FormatUtils.Prefixes field. Also, a list of prefixes sorted from high (Giga)
            down to small (Pico) is available in Sorted.
            </summary>
            <remarks>
            The Find() method can be used to find the best prefix for a number.
            </remarks>
        </member>
        <member name="F:TIDP.FormatUtils.PrefixHash.None">
            <summary>
            The Prefix info when there is multiplier. Used to format
            0.0 value.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.PrefixHash.Find(System.Double)">
            <summary>
            Finds the best prefix to use for the specified value. Returns it
            the converted number.
            </summary>
        </member>
        <member name="M:TIDP.FormatUtils.PrefixHash.Find(System.String)">
            <summary>
            Looks up the prefix info if passed "μ", "u", "p", "M", etc.
            Allows "k" or "K" for kilo. Returns null if no match is found.
            </summary>
        </member>
        <member name="P:TIDP.TIProgramEngine.Aux_Items_Dir">
            <summary>
            The directory where miscellaneous files and directories can be
            found. Maps to something like C:\Program Files\Texas Instruments Fusion Digital Power Studio
            when the app has been installed and 
            C:\snapshot\DotNet\Apps\Desktop\...\Source\ToInstall when running from
            the source tree. Files in ToInstall get packaged up and added to
            the installer.
            </summary>
        </member>
        <member name="P:TIDP.TIProgramEngine.Running_In_Source_Dir">
            <summary>
            True if the application is running out of a source tree. Determined
            by seeing if the directory contains "\Apps\Desktop\", which all 
            non-installed applications and test programs should be under.
            </summary>
        </member>
        <member name="P:TIDP.TIProgramEngine.Short_Version">
            <summary>
            Just 1.0.8 or for 1.0.8.0. But 1.0.8.1 if there is a non-zero .xxx revision
            component.
            </summary>
        </member>
        <member name="T:TIDP.TIUtils">
            <summary>
            General purpose utility functions.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Is_Nullable(System.Type)">
            <summary>
            Returns true if the type passed is either a nullable reference type or
            a class, which is inherently nullable.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Type2String(System.Type)">
            <summary>
            Returns a string version of the type, but with suitable for use in
            code auto-generation. For example, if the type is bool?, "System.Boolean?"
            instead of "System.Nullable`1[System.Boolean]".
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Num_Delegate_Targets(System.Boolean,System.Delegate[])">
            <summary>
            Returns the number of targets ("listeners") bound to the specified delegate
            (often an event). If you want to ensure that each target object is only
            reported once, set unique_only to true.
            </summary>
            <param name="unique_only"></param>
            <param name="delegates"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Find_Event_Delegate(System.Type,System.String,System.Object)">
            <summary>
            Returns the delegate for the specified event. If your event is static,
            pass null in class_instance. Throws an exception if the event can not
            be found and null if there are currently no subscribers attached to 
            the event.
            </summary>
            <remarks>
            Normally the event delegates are private, internal beasts that you
            can not get at, especially outside of the class that defined the
            event. This method lets you retrieve the delegate so you can invoke
            it from anywhere. While normally this is not a great idea, I found
            it useful where I have very standardized events in an interface and 
            did not want to have to have every implementor of interface deal with 
            firing the events.
            </remarks>
            <param name="class_type"></param>
            <param name="event_name"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Is_Equal_Via_Compare_To(System.Object,System.Object)">
            <summary>
            Uses IComparable to test if obj1 is equal to obj2, but first
            does basic null tests. I.e. if obj1 is null and obj2 is not,
            they must not be equal. If both are null, they are equal.
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Is_Equal(System.Object,System.Object)">
            <summary>
            Uses Object.Equal() to test if obj1 is equal to obj2, but first
            does basic null tests. I.e. if obj1 is null and obj2 is not,
            they must not be equal. If both are null, they are equal.
            </summary>
            <param name="obj1"></param>
            <param name="obj2"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Are_Lists_Equal(System.Collections.IList,System.Collections.IList)">
            <summary>
            Returns true if both lists are null. Otherwise, verifies that length
            and contents are equal. .Equals() is used to compare each element.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Timezone_String">
            <summary>
            Returns CDT, CST, etc for current timezone and current time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Timezone_String(System.DateTime)">
            <summary>
            Returns CDT, CST, etc for current timezone and specified time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Timezone_String(System.TimeZone)">
            <summary>
            Returns CDT, CST, etc for timezone passed and current time.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Timezone_String(System.TimeZone,System.DateTime)">
            <summary>
            Returns CDT, CST, etc for timezone/time passed.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Double(System.String)">
            <summary>
            Similar to Double.Parse(), but does not throw an exception on failure:
            returns null. Accepts integer, decimal, and scientific notation
            input formats. The user's localization settings are used. So, for example,
            if the user is on a French PC than "1.234,56" will yield 1234.56.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Std_Double(System.String)">
            <summary>
            Similar to Double.Parse(NumberStyles.Any, CultureInfo.InvariantCulture.NumberFormat), but does 
            not throw an exception on failure: returns null. Accepts integer, decimal, and 
            scientific notation input formats. Forces "United States" style number parsing to be used. 
            So, for example, even if the user is on a French PC, "1,234.56" will 
            yield 1234.56. Also accepts unit specified. So for example, "1.23 p" for 1.23e-
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Bool(System.String)">
            <summary>
            Accepts yes|true or no|false, in any CASE and with any whitespace around
            the text. Returns null if no match.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Int64(System.String)">
            <summary>
            Parses for an Int64. Can be in scientific notation, 0xFF
            hex notation, or
            even X,XXX notation. Will return null if there is any
            fractional compent or it can not be parsed. Uses 
            internationalization settings on user's PC to do conversion. 
            Thus works for French user who can use 1.234.567 formatting 
            for numbers.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_UInt64(System.String)">
            <summary>
            Parses for a UInt64. Can be in scientific notation, 0xFF
            hex notation, or even X,XXX notation. Will return null if there is any
            fractional compent or it can not be parsed. Uses 
            internationalization settings on user's PC to do conversion. 
            Thus works for French user who can use 1.234.567 formatting 
            for numbers.es
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Numeric(System.String)">
            <summary>
            Parses the supplied string, which can be in either
            scientific notation or standard decimal notation.
            Really mostly just uses Double.Parse, but does support
            truncated formats like "0E", "0" and other formats like
            "1.0+10" and "1.0-10". Uses internationalization settings
            on user's PC to do conversion. Thus works for French
            user who uses 1.2345,67 formatting for numbers.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Round(System.Double)">
            <summary>
            A standard .5 rounds to 1 type of round.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Round(System.Double,System.Int32)">
            <summary>
            A standard .5, .05, etc round.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Round_Scientific(System.Double,System.Int32)">
            <summary>
            Rounds so given x.yEz, y will be rounded so that y contains the specified
            number of decimal places. See FormatUtils.Scientific() for text
            formatting only.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Round_Away_From_Zero(System.Double,System.Int32)">
            <summary>
            Rounds numbers up or down so that they are a modulo / step 
            of step.
            <example>
            Round_Away_From_Zero(value = 20, step = 10) -> 20
            Round_Away_From_Zero(value = 24.2, step = 10 -> 30
            Round_Away_From_Zero(value = -22.1, step = 10 -> -30
            </example>
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Round_To_Zero(System.Double,System.Int32)">
            <summary>
            Rounds numbers up or down so that they are a modulo / step 
            of step.
            <list type="">
            <item>Round_To_Zero(value = 20, step = 10) -> 20</item>
            <item>Round_To_Zero(value = 24.2, step = 10 -> 20</item>
            <item>Round_To_Zero(value = -22.1, step = 10 -> -20</item>
            </list>
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Round_Min_Max_To_Step(System.Double,System.Double,System.Int32)">
            <summary>
            Useful to calculate a stepped min/max around a real min/max for charting
            and other applications. The min/max returned will always contain the
            supplied min/max but be a modulo of step.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Are_Numbers(System.Nullable{System.Double}[])">
            <summary>
            Returns true only if all of the specified values are non-null,
            non-NaN, and non-Infinity.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Step_To_Resolution(System.Double,System.Double,TIDP.StepDirection)">
            <summary>
            Steup a value up or down around the precision it supports. Examples:
            <item>Step_To_Resolution(value=0.5, precision=0.5, direction=Up) -> 1.0</item>
            </summary>
            <remarks>
            There is a unit test for this function.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Step_To_Resolution(System.Double,System.Double,System.Boolean)">
            <summary>
            See Step_To_Resolution(double, double, StepDirection).
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Is_Whole_Number(System.Double)">
            <summary>
            Returns true if the ToString() value does not contain any decimal places.
            I.e. it is an integer.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Is_Whole_Number(System.Double,System.Int32)">
            <summary>
            Returns true if value rounded to the specified decimal_places is a whole number.
            I.e. is it an integer in this case.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Modulus_Db(System.Numerics.Complex)">
            <summary>
            returns modulus db of complex number;
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Is_Undef(System.Numerics.Complex)">
            <summary>
            For complex numbers if real or imaginary part has NaN for either of their values will return true for undefined.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Round_To_Resolution(System.Double,System.Double)">
            <summary>
            Round based on the resolution/precision supported. Basically a "fit to 
            precision" function. Some examples:
            <code>
            0.8 rounded by precision 0.4 => 0.8
            0.9 rounded by precision 0.4 => 0.8
            0.99 rounded by precision 0.4 => 0.8
            1 rounded by precision 0.4 => 1.2
            1.01 rounded by precision 0.4 => 1.2
            </code>
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Decimal_Places(System.Double)">
            <summary>
            Returns the number of significant decimal places in the value. For example,
            if passed 0.12345, 5 will be returned.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Decimal_Places(System.String)">
            <summary>
            Returns the number of significant decimal places in the value. For example,
            if passed 0.1234500, 7 will be returned.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Is_Number(System.Double)">
            <summary>
            Returns true only if the specified value is not NaN and not
            Infinity.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Scientific_Notation_Exponent(System.Double)">
            <summary>
            Given input of 0.002, returns -3 because the value is 2.0E-3 in
            scientific notation.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.TIUtils.Enum_Values``1">
            <summary>
            Returns a list of all the possible enum values for TEnum.
            The list is sorted by the enum's underlying numeric value.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Enum_Values``1(``0)">
            <summary>
            Returns a list of the enum values in TEnum that are set in
            the specified enum value. 
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Enum``1(System.String)">
            <summary>
            Converts the string representation of an enum to a typed version.
            Will throw an exception if it can not be converted. Case
            sensitive!
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Enum``1(System.Boolean,System.String)">
            <summary>
            Converts the string representation of an enum to a typed version.
            Will throw an exception if it can not be converted. Can be 
            case insensitive or case sensitive. I.e. in case insensitive
            mode, "mymode1" will match MyEnum.MyMode1.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Enum_List``1(System.Boolean,System.String)">
            <summary>
            Parses a list of enums that are separated by a comma. Throws an exception if
            an unknown value is found.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Enum_To_Text(System.Object)">
            <summary>
            Converts something like MyEnum.HelloWorld to "Hello World".
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Compact_Version(System.Version)">
            <summary>
            Just 1.0.8 or for 1.0.8.0. But 1.0.8.1 if there is a non-zero .xxx revision
            component.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Compact_Version_And_Timestamp(System.Version,System.Nullable{System.DateTime},System.String)">
            <summary>
            Returns 1.1.1, 1.1.1 [2007-01-01], 2007-01-01, or empty string depending on which
            of the arguments passed is not null. Uses Compact_Version to return
            1.1.1.1 or 1.1.1 depending on last piece of version being non-zero. If
            ver_prefix is specified, the version number -- if defined -- will have this
            prefixed before it. For example, passing "v" will yield v1.1.1 etc.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Place_Suffix(System.Int32)">
            <summary>
            Returns one of "st", "nd", "rd", or "th" depending on number passed
            to help build strings like "1st". There is no error checking. If you
            pass -1, you will be back "th", the default.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Place_Number(System.Int32)">
            <summary>
            With input 1 returns "1st", with 2 "2nd", etc.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Shallow_Copy``1(``0)">
            <summary>
            Creates a shallow copy of the passed object via reflection. All public
            fields and properties will be copied.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Shallow_Copy(System.Object,System.Object)">
            <summary>
            Creates a shallow copy of the orig into clone via reflection. clone must has been
            previously created. All public fields and properties will be copied.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Clone``1(TIDP.CloneMode,``0)">
            <summary>
            If obj is null, returns null in all cases. If clone_mode is Deep, 
            calls Clone() on the object passed or throws an exception if
            object does not implement IClonable. If clone_mode is Shallow, just
            returns the object passed.
            </summary>
            <remarks>
            Useful in Clone()-like functions that have configurable shallow/deep
            mode. TIList and TIDictionary use this.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Truncate(System.String,System.Int32)">
            <summary>
            Truncate("Now is the time for all good men", 10) returns 
            "Now is ...". So what is returned will always be max_chars
            or less in length.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Yes_No(System.Boolean)">
            <summary>
            Returns "Yes" or "No".
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.yes_no(System.Boolean)">
            <summary>
            Returns "yes" or "no".
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.High_Low(System.Boolean)">
            <summary>
            Returns "High" or "Low".
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.To_List(System.Object[])">
            <summary>
            Creates an untyped list from the items passed in the
            function arguments.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Compare_String_Via_Numeric_Suffix(System.String,System.String)">
            <summary>
            FAN_COMMAND_1 sorts before FAN_COMMAND_10 when using this comparer function.
            Normally FAN_COMMAND_10 sorts first, which is not what you want in most
            situations.
            </summary>
            <remarks>
            Internally has to parse the string to determine prefix/numeric suffix. Caches
            and re-uses this result so that heavy use does not impact performance.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Multi_Array_Indexes(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns array indexes in row major order for the specified array
            dimensions.
            </summary>
            <example>
            If dimensions is { 2, 2, 2} then the following will be returned:
            <code>
            0,0,0
            0,0,1
            0,1,0
            0,1,1
            1,0,0
            1,0,1
            1,1,0
            1,1,1
            </code>
            </example>
        </member>
        <member name="M:TIDP.TIUtils.Find_Files(System.String,System.String)">
            <summary>
            Find file recursively by matching each filename under folder_name against 
            filename_regex_match. The match is done as-is against just the leaf filename.
            So for example, you might want to match for "^foo.*\..*" to find all files
            named foo*.*. Uses LINQ, so you can start enumerating over matches quickly and 
            won't have to wait for full search to complete.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Find_Files(System.String,TIDP.TIUtils.FindMatchDelegate)">
            <summary>
            Find file recursively using a custom "match" delegate. Uses LINQ, so you can start
            enumerating over matches quickly and won't have to wait for full search to complete.
            </summary>
            <remarks>
            See the other version of Find_Files() for an example of using an inline anonymous
            delegate to define the match criteria function.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Get_Directory_Files_Info(System.String)">
            <summary>
            Get a list of files in the specified directory, but return FileInfo for
            each one instead of only the filename.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Embedded_File_Stream(System.String)">
            <summary>
            Returns a Stream for a file embedded in the caller's assembly. 
            Use '." as the directory separator. 
            Example: Embedded_File_Stream("Debugger.ucd30xx.map")
            to access Resources/Debugger/ucd30xx.map.
            </summary>
            <exception cref="T:System.Exception">
            An exception is thrown if the resource/file is not present.
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TIDP.TIUtils.Save_Embedded_File(System.String,System.String)" -->
        <member name="M:TIDP.TIUtils.Save_Embedded_File(System.Reflection.Assembly,System.String,System.String)">
            <summary>
            Saves a file that is in the specified assembly to the user's PC.\
            Use '." as the directory separator. 
            Example: Embedded_File_Stream(assembly, "Debugger.ucd30xx.map")
            to access Resources/Debugger/ucd30xx.map.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Excel_Column_Name_To_Number(System.String)">
            <summary>
            Converts a column string like 'A' to 1, 'AA' to 27, etc.
            </summary>
            <remarks>
            Code from http://stackoverflow.com/questions/667802/what-is-the-algorithm-to-convert-an-excel-column-letter-into-its-number.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Excel_Column_Number_To_Name(System.Int32)">
            <summary>
            Converts 1 to 'A', 27 to 'AA', etc.
            </summary>
            <remarks>
            From http://stackoverflow.com/questions/181596/how-to-convert-a-column-number-eg-127-into-an-excel-column-eg-aa.
            </remarks>
        </member>
        <member name="M:TIDP.TIUtils.Method_Signature(System.Diagnostics.StackFrame,System.Boolean,System.Boolean,System.Object[])">
            <summary>
            Returns the method signature for the frame. Unfortunately, because this is
            via Reflection namespace, you can not get function argument values.
            Examples are "Test_Func1()", "Test_Func2(String a, Int32 b)", 
            "Test_Func3(a, b, c)" and "Test_Func4(a = hello, b = 123)" when 
            func_args is passed.
            </summary>
            <param name="func_args">
            This is optional. If supplied, the arguments will be listed in the signature.
            </param>
        </member>
        <member name="M:TIDP.TIUtils.Parse_Number_List(System.String)">
            <summary>
            Parses input string like "1", "1,3", or "1-3,6-8". Returns
            an array of integers representing the complete number list.
            Extra whitespace is allowed anywhere. Returns null if no
            numbers were specified. Throws exception if input was in 
            bad format, such as "1,a" or "1," or "50-10" (illegal range).
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Underlying_Type(System.Type)">
            <summary>
            If the type passed is Nullable&lt;T&gt;, returns T. Otherwise just
            returns the type passed in.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Is_Numeric_Type(System.Object)">
            <summary>
            Returns true if the passed object's type is numeric (byte, int, decimal, etc.).
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Is_Numeric_Type(System.Type)">
            <summary>
            Returns true if the passed type is numeric (byte, int, decimal, etc.).
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Complex_To_Long_String(System.Numerics.Complex)">
            <summary>
            Returns something like "60 - 47j, 37.64101 dB, -38.07278 deg". 0.##### is used to format the numbers.
            </summary>
        </member>
        <member name="M:TIDP.TIUtils.Radians_To_Degrees(System.Double)">
            <summary>
            Radians to Degrees -> Degrees = Radians * 180/pi
            since 180/pi = degree/rad
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.TIUtils.Fusion_Tools_Top_Dir">
            <summary>
            This is the absolute pathname of the Fusion Tools source code
            top-level directory for the currently executing program. Will be ""
            if the application is not running inside the source tree. For
            example, "C:\Documents and Settings\a0271759\My Documents\TI\Workspaces\FusionTools1\Main"
            or "C:\Documents and Settings\a0271759\My Documents\TI\Workspaces\FusionTools2\Branches\UCD92XX".
            </summary>
        </member>
        <member name="P:TIDP.TIUtils.Complex_Undef">
            <summary>
            returns a complex number with it's real and imaginary part undefined.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TIDP.NotifyPropertyChanged">
            <summary>
            Implements INotifyPropertyChanged, to provide a .NET-standard
            way to notify a consumer of an instance of this class that
            a property has been changed. Just call OnPropertyChanged("prop-name")
            from your property.
            </summary>
        </member>
        <member name="T:TIDP.BitUtils">
            <summary>
            Miscellaenous methods to deal with bits, bytes, words, blocks, etc.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Are_Equal(System.Byte[],System.Byte[])">
            <summary>
            Returns true if both are null. Otherwise, verifies that length
            and contents are equal.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract_Bit(System.Byte,System.Int32)">
            <summary>
            Same as Is_Bit_Set(...)
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract_Bit(System.Byte[],System.Int32)">
            <summary>
            Same as Is_Bit_Set(...)
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract_Bit(System.UInt64,System.Int32)">
            <summary>
            Same as Is_Bit_Set(...)
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.UInt64)">
            <summary>
            Inserts the specified unsigned 64 bit value to the block started at index to_start_i.
            Bytes are extracted from uint64 with block offset 0 = hi byte and 
            offset 7 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Int64)">
            <summary>
            Inserts the specified signed 64 bit value to the block started at index to_start_i.
            Bytes are extracted from int64 with block offset 0 = hi byte and 
            offset 7 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.UInt32)">
            <summary>
            Inserts the specified unsigned 32 bit value to the block started at index to_start_i.
            Bytes are extracted from uint32 with block offset 0 = hi byte and 
            offset 3 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inserts the specified signed 32 bit value to the block started at index to_start_i.
            Bytes are extracted from int32 with block offset 0 = hi byte and 
            offset 3 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.UInt16)">
            <summary>
            Inserts the specified unsigned 16 bit value to the block started at index to_start_i.
            Bytes are extracted from uint32 with block offset 0 = hi byte and 
            offset 1 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Int16)">
            <summary>
            Inserts the specified signed 16 bit value to the block started at index to_start_i.
            Bytes are extracted from uint32 with block offset 0 = hi byte and 
            offset 1 = lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Set a bit in the supplied block. Bit numbers are from 0 up through
            to_bytes.Length*8-1. Insert_Into_Block() does the same thing.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract(System.UInt32,System.Int32)">
            <summary>
            Extracts a byte from a 32 bit value. Bytes are indexed 0=hi byte,
            3=low byte.
            </summary>
            <param name="from_uint32"></param>
            <param name="byte_index"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Inserts a series of whole bytes at the specified position into
            a byte array to_bytes that has been preallocated. Will throw an exception
            if it can not fit or index is invalid. OK to pass an empty
            from_bytes array, which will be ignored.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Inserts bits from one block of bytes into another. Bit ordering is hi to
            lo and spans bytes.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Insert(System.Nullable{System.Byte}[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Inserts bits from one block of bytes into another. Bit ordering is hi to
            lo and spans bytes.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Extract a series of bytes from the byte array and return as an 
            array of bytes. Will throw an exception if arguments are
            inavlid.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract_Byte(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Extract a byte value from 0x00 to 0xFF.
            If end_bit_index - start_bit_index >= 8 => end_bit_index is set to (start_bit_index+7)
            </summary>
            <param name="bytes">the array of bytes where bytes[0] is msb</param>
            <param name="start_bit_index"></param>
            <param name="end_bit_index"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.BitUtils.Gen_Mask(System.Int32,System.Int32)">
            <summary>
            Create a mask with 1s in the specified bit range and 0s everywhere else.
            For example, Gen_Mask(3, 2) returns 0000 1100.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Gen_Mask(System.Int32)">
            <summary>
            Create a mask for one bit with 1 in the bit position and zero elsewhere. For example,
            Gen_Mask(7, 7) returns 1000 0000.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Decode_Q(System.Int32,System.UInt64)">
            <summary>
            To decode 11,800 Q10,6 encoded value, pass Decoded_Q(6, 11800).
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Decode_Twos_Compliment(System.Byte,System.Int32,System.Int32)">
            <summary>
            Decodes the twos complement signed number stored at the specified
            location within the byte (i.e. all other bits are ignored).
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Decode_Twos_Compliment(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Extracts the twos compliment integer from a block of bytes. Bits are numbered hi 
            starting to the left. The sign bit is in position hi_bit_index. For byte[] { x80, x00}, 
            hi_bit_index 15 is the leftmost bit.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Encode_Twos_Compliment(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes a signed integer into hex using twos compliment notation. Can insert the
            encoded value anywhere within a block of bytes via the specified start and stop
            bit positions. Bits are numbered hi starting to the left. The sign bit is in position 
            hi_bit_index. For byte[] { x80, x00}, hi_bit_index 15 is the leftmost bit. Bits
            outside of the range are left alone.
            <para/>
            Throws an exception if the value can not fit in the number of bits specified.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Encode_Twos_Compliment(System.Int32,System.Byte@,System.Int32,System.Int32)">
            <summary>
            Encodes a signed integer using twos compliment notation. Can insert the
            encoded value anywhere within the byte that is passed via the specified start and stop
            bit positions. The sign bit will be in position hi_bit_index. Bits outside of the 
            range are left alone.
            <para/>
            Throws an exception if the value can not fit in the number of bits specified.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Can_Encode_Twos_Compliment(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns true if the specified bit range can hold the value in twos compliment
            notation.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Can_Encode_Twos_Compliment(System.Int32,System.Int32)">
            <summary>
            Returns true if the specified value can be encoded into num_bits (including
            sign bit).
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Max_Twos_Compliment(System.Int32)">
            <summary>
            Returns the maximum postive integer that can be reprsented using
            twos compliment encoding in the specified number of bits.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Min_Twos_Compliment(System.Int32)">
            <summary>
            Returns the minimum negative integer that can be reprsented using
            twos compliment encoding in the specified number of bits.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Max_Unsigned_Integer(System.Int32)">
            <summary>
            Returns the maximum unsigned integer that can be stored in the
            specified number of bits (2^num_bits - 1).
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Num_Bytes_Needed_For_UInt(System.UInt64)">
            <summary>
            Returns the number of bytes that are required to store the specified
            number. 255 returns 1. 0 returns 0. 256 returns 2. And so on.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Decode_Unsigned_Integer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Extracts the unsigned integer from a block of bytes at specific positions, allowing
            a value that spans a byte boundry to be easily extracted. Bits are numbered hi 
            starting to the left. For byte[] { x80, x00}, hi_bit_index 15 is the leftmost bit.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Encode_Unsigned_Integer(System.UInt64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encodes an unsigned integer anywhere within a block, not just at byte boundries. You 
            specify start and stop bit positions. Bits are numbered hi starting to the left. 
            For byte[] { x80, x00}, hi_bit_index 15 is the leftmost bit. Bits outside of the 
            range are left alone.
            <para/>
            Throws an exception if the value can not fit in the number of bits specified.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Extract_From_Block(System.Byte[],System.Int32)">
            <summary>
            For byte[] { x80, x00}, bit_index 15 maps to the leftmost
            bit which would return 1. No range checking is done.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Parse_Hex_Bytes(System.String,System.Boolean,System.Boolean)">
            <summary>
            Parses the supplied string to find a series of bytes which will be split
            up and returned as a byte[] array. If empty_ok is true, null will be returned
            if an empty or whotespace string is passed. Normally an exception will be
            thrown otherwise unless null_on_error is true, in which case null will be
            returned.
            </summary>
            <param name="hex"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.BitUtils.Parse_Nullable_Hex_Bytes(System.String,System.Boolean,System.Boolean)">
            <summary>
            Parses the supplied string to find a series of bytes which will be split
            up and returned as a byte[] array. A "??" byte will map to a null element.
            If empty_ok is true, null will be returned
            if an empty or whotespace string is passed. Normally an exception will be
            thrown otherwise unless null_on_error is true, in which case null will be
            returned.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Normalize_Hex(System.String,System.Boolean,System.Boolean)">
            <summary>
            Takes various hex input formats and returns a string with all extra junk 
            removed. For example, "0x123" becomes "123". The pair option specifies
            whether "123h" becomes "0123", so that there are always "full bytes."
            ?? bytes are passed through, representing a null byte.
            <para/>
            Supported formats include "0F-DE", "0FDE", "0F DE", "0x0fDE", and 
            "Fh". Partial bytes are supported. For example, 0xa (0A) or A0F (0A0F).
            <para/>
            If empty_ok is true, "" or "&lt;empty&gt;" will be accepted and ""
            will be returned. Otherwise, an exception is thrown in this case.
            </summary>
            <exception cref="T:System.Exception">Throws an exception when the string is
            in a bad format.</exception>
        </member>
        <member name="M:TIDP.BitUtils.Normalize_Hex(System.String)">
            <summary>
            Calls Normalize_Hex(hex) with pair set to false and empty_ok set to false.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Parse_Hex_Byte(System.String)">
            <summary>
            Expects to find a single byte. The same input formats described in
            Parse_Hex_Bytes are supported. So for example, "A" and "0xDE" are 
            both supported. Throws an exception if the value can not be parsed.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Byte(System.String)">
            <summary>
            Equivalent to Parse_Hex_Byte(). Returns the byte on success and
            throws an exception on error.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Binary(System.UInt64,System.Int32)">
            <summary>
            Formats an unsigned integer in binary format. For example,
            Format_Binary(0x2, 3) returns "010".
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Binary(System.Byte)">
            <summary>
            Formats byte in binary format. For example,
            Format_Binary(0x2) returns "00000010".
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Byte[])">
            <summary>
            Formats a series a bytes using the specified canned format.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Nullable{System.Byte}[])">
            <summary>
            Formats a series a bytes using the specified canned format.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Int32,System.Byte[])">
            <summary>
            Formats a series a bytes using the specified canned format. Only 
            length number of bytes will be added to the formated string.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Int32,System.Nullable{System.Byte}[])">
            <summary>
            Formats a series a bytes using the specified canned format. Only 
            length number of bytes will be added to the formated string.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Int32,System.Int32,System.Byte[])">
            <summary>
            Formats a series a bytes using the specified canned format. Only the
            bytes from start_i through end_i will be included in the formated string.
            Returns "&lt;empty&gt;" if the bytes passed are null or 0 length.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(TIDP.HexFormat,System.Int32,System.Int32,System.Nullable{System.Byte}[])">
            <summary>
            Formats a series a bytes using the specified canned format. Only the
            bytes from start_i through end_i will be included in the formated string.
            Returns "&lt;empty&gt;" if the bytes passed are null or 0 length. null
            byte maps to "??".
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(System.Byte[])">
            <summary>
            Formats a series a bytes in 0xAABB coder style.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(System.Nullable{System.Byte}[])">
            <summary>
            Formats a series a bytes in 0xAABB coder style.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(System.Int32,System.Byte[])">
            <summary>
            Formats a series a bytes in 0xAABB coder style. Only 
            length number of bytes will be added to the formated string.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Format_Hex(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Formats a series a bytes in 0xAABB coder style. Only the
            bytes from start_i through end_i will be included in the formated string.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt64(System.Byte[])">
            <summary>
            Accepts a byte array of length 0 to 8 bytes and returns an
            unsigned integer representing what was passed. 0x01, 0x01 
            returns 257, for example. Null or zero length array returns
            0. Throws an exception if more than 8 bytes are passed.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt64(System.String)">
            <summary>
            Converts the hex string to an unsigned 64 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 64 bits in the supplied array to a UInt64.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt32(System.Byte[])">
            <summary>
            Accepts a byte array of length 0 to 4 bytes and returns an
            unsigned integer representing what was passed. 
            For examples:
            0x01, 0x02 returns 0x00000102 (258d);  
            0x01, 0x02, 0x03, 0x04 return 0x01020304 
            bytes[0] = 0x01, bytes[1] = 0x02 return 0x00000102 (258d);  
            bytes[0] = 0x01, bytes[1] = 0x02, bytes[2] = 0x03,bytes[4] = 0x04 return 0x01020304
            Null or zero length array returns
            0. Throws an exception if more than 4 bytes are passed.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt32(System.Byte[],System.Int32)">
            <summary>
            Accepts a byte array with at least 4 bytes. The 32 bit (4 byte)
            unisgned integer we want to extract must start at start_i. 
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt32(System.String)">
            <summary>
            Converts the hex string to an unsigned 32 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 32 bits in the supplied array to a UInt32.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt16(System.Byte[])">
            <summary>
            Accepts a byte array of length 0 to 2 bytes and returns an
            unsigned integer representing what was passed. 0x01, 0x01 
            returns 257, for example. Null or zero length array returns
            0. Throws an exception if more than 2 bytes are passed.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt16(System.Byte[],System.Int32)">
            <summary>
            Converts to UInt16 2 bytes in the supplied array, where start_i is the hi byte and 
            start_i+1 is the lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 16 bits in the supplied array to a UInt16.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt16(System.Byte,System.Byte)">
            <summary>
            Accepts a high byte and low byte and converts to an unsigned 16 bit integer.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt16(System.String)">
            <summary>
            Converts the hex string to an unsigned 16 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_UInt8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 8 bits in the supplied array to a byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int8(System.Byte)">
            <summary>
            Converts to int8 a byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int8(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 8 bits in the supplied array to a sbyte. The sign bit is at
            hi_bit_index, and any bits higher than hi_bit_index and lower than 
            lo_bit_index are ignored.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int16(System.Byte,System.Byte)">
            <summary>
            Converts to int16 a hi/lo byte pair.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int16(System.Byte[])">
            <summary>
            Converts to int16 an array where index 0 is the hi byte and 1 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int16(System.Byte[],System.Int32)">
            <summary>
            Converts to int16 2 bytes in the supplied array, where start_i is the hi byte and 
            start_i+1 is the lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int16(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 16 bits in the supplied array to an Int16. The sign bit is at
            hi_bit_index, and any bits higher than hi_bit_index and lower than 
            lo_bit_index are ignored.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int16(System.String)">
            <summary>
            Converts the hex string to a signed 16 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Int8(System.SByte)">
            <summary>
            Converts an int8 (signed byte) to an unsigned byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Int16(System.Int16)">
            <summary>
            Converts an int16 to an array where index 0 is the hi byte and 1 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_UInt16(System.UInt16)">
            <summary>
            Converts an uint16 to an array where index 0 is the hi byte and 1 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_UInt24(System.UInt32)">
            <summary>
            Converts only 24 bits of a uint32 into a byte array. index 0 is the hi byte and 2 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Int32(System.Int32)">
            <summary>
            Converts an int32 to an array where index 0 is the hi byte and 3 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_UInt32(System.UInt32)">
            <summary>
            Converts a uint32 to an array where index 0 is the hi byte and index 3 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Int64(System.Int64)">
            <summary>
            Converts an int64 to an array where index 0 is the hi byte and 7 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_UInt64(System.UInt64)">
            <summary>
            Converts a uint64 to an array where index 0 is the hi byte and index 7 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int32(System.String)">
            <summary>
            Converts the hex string to a signed 32 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int32(System.Byte[])">
            <summary>
            Converts to int32 an array where index 0 is the hi byte and 3 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int32(System.Byte[],System.Int32)">
            <summary>
            Converts to int32 4 bytes in the supplied array, where start_i is the hi 
            byte and start_i+3 is the lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int32(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 32 bits in the supplied array to an Int32. The sign bit is at
            hi_bit_index, and any bits higher than hi_bit_index and lower than 
            lo_bit_index are ignored.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int64(System.Byte[])">
            <summary>
            Converts to int64 an array where index 0 is the hi byte and 7 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int64(System.Byte[],System.Int32)">
            <summary>
            Converts to int64 8 bytes in the supplied array, where start_i is the hi 
            byte and start_i+7 is the lo byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int64(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Converts up to 64 bits in the supplied array to an Int64. The sign bit is at
            hi_bit_index, and any bits higher than hi_bit_index and lower than 
            lo_bit_index are ignored. This is the same as Decode_Twos_Compliment().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Int64(System.String)">
            <summary>
            Converts the hex string to a signed 64 bit integer. Throws an 
            exception on error. Supports formats described in Normalize_Hex().
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Float32(System.Byte[])">
            <summary>
            Converts to 32-bit floating point an array where index 0 is the hi byte and 3 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Float64(System.Byte[])">
            <summary>
            Converts to 64-bit floating point an array where index 0 is the hi byte and 7 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Float32(System.Single)">
            <summary>
            Converts a 32-bit floating point number to an array where index 0 is the hi byte and index 3 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.From_Float64(System.Double)">
            <summary>
            Converts a 64-bit floating point number to an array where index 0 is the hi byte and index 7 is the lo
            byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Is_Flag_Set(System.Object,System.Object)">
            <summary>
            Returns true if the value in [Flags()] enum flags_value has the
            bit flag_bit set. Your enum must be defined like so 
            to use this helper function:
            <example>
            [Flags()]
            public enum MyEnum : byte // int also works
            {
                None = 0x0,
                A = 0x1,
                B = 0x2
            }
            
            MyEnum val = MyEnum.A;
            BitUtils.Is_Flag_Set(val, MyEnum.A) -> true
            BitUtils.Is_Flag_Set(val, MyEnum.B) -> false
            </example>
            <remarks>
            This should not be used where execution speed is important (i.e.
            tight loops).
            </remarks>
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Is_Bit_Set(System.Byte,System.Int32)">
            <summary>
            Returns true if the specified bit is 1 (set).
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Is_Bit_Set(System.Byte[],System.Int32)">
            <summary>
            Returns true if the specified bit is 1 (set). OK if bytes is
            undersized: false will be returned.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Is_Bit_Set(System.UInt64,System.Int32)">
            <summary>
            Returns true if the specified bit is 1 (set). OK if uint64 is
            undersized: false will be returned.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Reverse(System.Byte[])">
            <summary>
            Reverses the byte order of the supplied byte elements. Does not touch the 
            actual bytes themselves. So {0x01, 0x02, 0x03} returns {0x03, 0x02, 0x01}
            </summary>
            <param name="bytes"></param>
        </member>
        <member name="M:TIDP.BitUtils.Different_Bytes(System.Byte,System.Int32,System.Byte[])">
            <summary>
            Given a list of bytes, returns the same number of bytes 
            but with each returned byte being different from any
            one byte passed in. Also, each byte returned will also
            be unique. If these conditions are not possible -- unlikely
            except for a large byte array passed -- an exception will
            be thrown. Bytes are generated starting at start_byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Different_Bytes(System.Byte[])">
            <summary>
            Invokes Different_Bytes(0x0, 0, bytes), so that the unique byte
            search starts at 0x00.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Sum_Bytes(System.Collections.Generic.IList{System.Byte},System.Int32)">
            <summary>
            Adds all of the bytes in data together and returns the sum. Stops at 
            data[len - 1].
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Sum_Bytes(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Adds all of the bytes in data together and returns the sum. 
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.SMBus_CRC8(System.Collections.Generic.IList{System.Byte},System.Int32)">
            <summary>
            Computes the SMBus 8 bit Cyclic Redundancy Check (CRC) for a series of bytes.
            C(x) = 1 0000 0111
            </summary>
            <param name="length">
            Limit the calculation to the first len bytes.
            </param>
        </member>
        <member name="M:TIDP.BitUtils.SMBus_CRC8(System.Collections.Generic.IList{System.Byte})">
            <summary>
            Computes the SMBus 8 bit Cyclic Redundancy Check (CRC) for a series of bytes.
            C(x) = 1 0000 0111
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.ASCII_Dump(System.Byte[])">
            <summary>
            Converts the passed bytes to ASCII text. If a character is not printable,
            substitutes the "." character.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.ASCII_Dump(System.Nullable{System.Byte}[])">
            <summary>
            Similar to ASCII_Dump(byte[]), but if an entry is null "-" is
            used in it's place.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Random_Block(System.Int32)">
            <summary>
            Returns a random byte array of the specified length.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Standard_Byte_Array(System.Nullable{System.Byte}[],System.Byte)">
            <summary>
            Turns a nullable byte array into a standard byte array, replacing any
            null bytes found with replace_byte.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.To_Nullable_Byte_Array(System.Byte[])">
            <summary>
            Turns a standard byte array into a nullable byte array.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.Num_Bytes_For_Bits(System.Int32)">
            <summary>
            Returns the number of bytes required to hold the specified number of
            bits. Rounds up. So 1 -> 8, 8 -> 8, and 9 -> 2.
            </summary>
        </member>
        <member name="F:TIDP.BitUtils.BlockBit.Block">
            <summary>
            Byte index, with lo byte = 0.
            </summary>
        </member>
        <member name="F:TIDP.BitUtils.BlockBit.Bit">
            <summary>
            Index of a bit within a byte. So always 7 - 0.
            </summary>
        </member>
        <member name="M:TIDP.BitUtils.BlockBit.#ctor(System.Int32,System.Int32)">
            <summary>
            Define how to access bit_index given the specified number
            of bytes. For example, BlockBit(2, 10) yields block index
            of 0 and bit index of 2.
            </summary>
            <param name="bytes"></param>
            <param name="bit_index"></param>
        </member>
        <member name="T:TIDP.TIStringBuilder">
            <summary>
            StringBuilder is sealed (who knows why!). But I prefer
            StringUtils.Format() style appending. Hence this class.
            </summary>
        </member>
        <member name="M:TIDP.TIStringBuilder.Trim(System.Int32)">
            <summary>
            Removes the specified number of characters from the end of the
            string.
            </summary>
        </member>
        <member name="M:TIDP.TIStringBuilder.Save_To_File(System.String)">
            <summary>
            Saves the buffer to a file. Throws an exception on any 
            error.
            </summary>
        </member>
        <member name="T:TIDP.UInt32AddressRange">
            <summary>
            Represents an address start and end range. Usually a base class for somthing
            I2C-ish. There are static factory methods to created based on either
            start/end or start/size.
            </summary>
        </member>
        <member name="F:TIDP.UInt32AddressRange.Start_Address">
            <summary>
            Starting address. (ROM address)
            </summary>
        </member>
        <member name="F:TIDP.UInt32AddressRange.End_Address">
            <summary>
            Ending/last address. (ROM address)
            </summary>
        </member>
        <member name="M:TIDP.UInt32AddressRange.#ctor(System.String)">
            <summary>
            Creates an address range based on a string of the form 
            "startaddr-endaddr". For example, "0x200-0x2FF". Throws an
            exception on any parse error.
            </summary>
        </member>
        <member name="M:TIDP.UInt32AddressRange.ToString">
            <summary>
            Returns somethung like Start:0x00000000, End:0x000000FF, Size:256 bytes.
            </summary>
        </member>
        <member name="P:TIDP.UInt32AddressRange.Size">
            <summary>
            Number of bytes in this memory range. (end-start +1)
            </summary>
        </member>
        <member name="T:TIDP.XmlEasySerializer`1">
            <summary>
            A wrapper around XmlSerializer to make it much easier to serialize (save)
            and de-serialize (restore/load) a class instance to/from an XML file.
            </summary>
            <typeparam name="T">Type class type you want to serialize.</typeparam>
        </member>
        <member name="F:TIDP.XmlEasySerializer`1.Ignore_Restore_Xml_Error">
            <summary>
            If Restore() encounters an XML error whether to Log the error and
            skip the restore, creating a new instance instead. One such example
            of where this might occur is if the classname that is serialized
            has been changed and you want to revert to the class default instance.
            </summary>
        </member>
        <member name="F:TIDP.XmlEasySerializer`1.Encryption_Key">
            <summary>
            If specified, the XML will be encryped/decrypted using the specified 
            key. The key can be any size, but only 32 characters will be used.
            The XML file will be compressed before being encrypted to save space,
            since the encrypted file will not compress.
            </summary>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.New_Or_Restore">
            <summary>
            If there is a file at the specified filename or the default_filename
            property then it is restored and a new instance is returned. Otherwise
            a new "default" instance -- empty constructor -- is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Save(`0)">
            <summary>
            Serialize to the named filename or, if not supplied, the
            Default_Filename property.
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Save(`0,System.IO.Stream)">
            <summary>
            Serializes obj to Stream. Does not close Stream.
            </summary>
            <param name="obj"></param>
            <param name="Stream"></param>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Save(`0,System.IO.TextWriter)">
            <summary>
            Serializes obj to a TextWriter. Does not close the TextWriter.
            </summary>
            <param name="obj"></param>
            <param name="TextWriter"></param>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Restore">
            <summary>
            De-Serializes from the named filename or, if not supplied, the
            Default_Filename property.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Restore(System.IO.Stream)">
            <summary>
            De-Serializes from a Stream. Does not close the Stream when done.
            </summary>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Restore(System.IO.TextReader)">
            <summary>
            De-Serializes from a TextReader. Does not close the TextReader
            when done.
            </summary>
            <param name="text_reader"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.XmlEasySerializer`1.Restore_Buffer(System.String)">
            <summary>
            The XML to de-serialize is stored in the string passed. Since strings
            are a reference type there is no performance penalty for this.
            </summary>
        </member>
        <member name="P:TIDP.XmlEasySerializer`1.Default_Filename">
            <summary>
            The default filename to use for Save and Restore methods when no
            filename is supplied.
            </summary>
        </member>
        <member name="T:TIDP.XmlEasySerializer`1.FileFormat">
            <summary>
            Someday I plan on adding built-in support for encryption of Xml files
            or at least rot13 or something simple to obfuscate data files.
            </summary>
        </member>
        <member name="T:TIDP.XmlEasySerializerContainer`1">
            <summary>
            A simple wrapper around the serialization facilities of EasySerializer.
            Provides a simple field called DB which will be serialized and restored
            when Save and Restore are called.
            </summary>
        </member>
        <member name="M:TIDP.XmlEasySerializerContainer`1.New">
            <summary>
            Create and return a new, default instance of T.
            </summary>
            <returns></returns>
        </member>
    </members>
</doc>
