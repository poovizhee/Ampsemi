<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TIDP.Factory.Core</name>
    </assembly>
    <members>
        <member name="M:TIDP.Factory.Core.AssemblyRenamesUpdates.Find_Rename_Update(System.String)">
            <summary>
            If the type has been renamed that will be returned otherwise name passed.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.Compiler.Is_NeverEx_Mode">
            <summary>
            Returns true if the NEVEREX compile macro is set and some exceptions
            will not be trapped like they normally are.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.BasicFactoryInstrumentation">
            <summary>
            This class is meant to handle non-instrumented directions to the user.  Any call that has a message component will be used to send to the user.
            If Plugin.Instrumentation hasn't been set then this will be used.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Measure_Temperature(System.Int32,System.Int32,System.Boolean,TIDP.Factory.Core.NonInstrumentedGetDoubleDialog)">
            <summary>
            this function will call a specific implementation and pass the parameters of the rail number and phase index.
            That should be sufficient information for the implementor to know which temperature sensor is required.
            The unit of the temperature returned is the responsibility of the caller who initialized the instrumentation.
            
            Also if you are not using instrumentation then set that field to false and provide the information for obtaining it 
            from the user such as a string for the title of a box, string for prompt and a string for the unit.
            
            Implementers of this funciton can set it up such that the first three arguements of the params are related to the dialog.
            And perhaps the rest of the arguements such as rail_num and phase_index can be ignored.
            </summary>
            <param name="rail_num"></param>
            <param name="phase_index"></param>
            <param name="instrumentation"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Measure_Output_Current(System.Int32,System.Boolean,TIDP.Factory.Core.NonInstrumentedGetDoubleDialog)">
            <summary>
            should throw exception if not there.
            </summary>
            <param name="rail_num"></param>
            <param name="phase_num"></param>
            <param name="instrumentation"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Initialize_Device(TIDP.Factory.Core.FactoryInstrumentationType.FactoryInstrumentationUnitType,System.Int32)">
            <summary>
            initialize equipment for a particular type of calibration.  This function is different from a general initialize in which everything is prepared
            As you may or may not be using all of a set up... A backdoor basically.
            </summary>
            <param name="initialization_type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Test">
            <summary>
            GPIB SCPI type of test... not intended to ask the user to test anything as they can visually tell if everything is working.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Initialize(System.Object[])">
            <summary>
            another backdoor.  More for instrumentation initialization so nothing really to tell the user in a manual mode.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Shutdown">
            <summary>
            Shuts down all the equipment via instrumentation... not intended for manual as the user can manually shut everything down.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Activate_Load(System.Int32,System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            /// will select the channel or the scpi related to the load setting the current for that rail and turn it on.
            </summary>
            <param name="device_type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.GPIB_TALK(System.String,System.String)">
            <summary>
            the back door of all backdoors.
            </summary>
            <param name="p"></param>
            <param name="p_2"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Deactivate_Load(System.Int32,System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            will select the channel  related to the load setting the current for that rail and turn it off.
            </summary>
            <param name="rail"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Configure_Load(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            This assumes that you will be configuring the load for ConstantCurrent and configuring both static low and high.
            </summary>
            <param name="CCLow"></param>
            <param name="CCHigh"></param>
            <param name="rail"></param>
            <param name="rise_time"></param>
            <param name="fall_time"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Set_Load_Current(System.Boolean,System.Double,System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            assumes that you have already configured the load for CCL,CCH,CCDL,CCDH (static or dynamic) via Configure_Device.
            In this function you specify the level there is always 1 or 2.
            </summary>
            <param name="high"></param>
            <param name="dynamic"></param>
            <param name="level"></param>
            <param name="current_value"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IFactoryInstrumentation.Set_Load_Current_Mode(System.Boolean,System.Boolean)">
            <summary>
            Set "low" to true for CCL. Set "low" to false for CCH.
            Set "dynamic" to true for dynamic.  Set "dynamic" to false for static.
            (Examples: CCL would be (true,false)  CCDH would be (false,true))
            </summary>
            <param name="low"></param>
            <param name="dynamic"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TIDP.Factory.Core.FactoryGUIHeadless.#ctor(TIDP.Factory.Core.FactoryMessaging)" -->
        <member name="M:TIDP.Factory.Core.FactoryGUIHeadless.#ctor">
            <summary>
            uses default messaging with the console.  To provide your own communication for inputs implement IFactoryMessaging
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryGUIHeadless.Start(TIDP.Factory.Core.FactoryGUIHeadless.FactoryGUIHeadlessInput)">
            <summary>
            Start will first execute Initialization Tasks, then look for the 
            device on PMBus, then execute Normal tasks and then Shutdown tasks.
            If the handler is not defined for a task group it will simply skip 
            it and go to the next task group. So you don't have to provide an 
            initialization/shutdown..  This also sets the device.
            </summary>
            <param name="factory_headless_input"></param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryGUIHeadless.Dispose">
            <summary>
            Call to unsubscribe from events.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryGUIHeadless.FactoryGUIHeadlessInput.#ctor(TIDP.PMBus.SAAPrefs,TIDP.PMBus.PartID,System.Int32,System.Boolean)">
            <summary>
            Input object required to set up the pmbus communication for the execution of tasks.
            </summary>
            <param name="saa_prefs">defaults are  SAAPrefs pref= new SAAPrefs(), 
            pref.Mode = TIDP.SAA.SMBusAdapter.BusMode.Serial;
            pref.PEC = true;
            pref.Speed = TIDP.SAA.SMBusAdapter.BusSpeed.Speed400KHz;</param>
            <param name="part_id">intellisense will give a list of devices, ex. UCD9240, ...</param>
            <param name="address">PMBus address</param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryGUIHeadless.FactoryGUIHeadlessInput.#ctor(TIDP.PMBus.PartID,System.Int32)">
            <summary>
            Input object required to set up the pmbus communication for the execution of tasks.
            defaults for SAA are used in this constructor, which are SAAPrefs pref= new SAAPrefs(), 
            pref.Mode = TIDP.SAA.SMBusAdapter.BusMode.Serial;
            pref.PEC = true;
            pref.Speed = TIDP.SAA.SMBusAdapter.BusSpeed.Speed400KHz;
            </summary>            
            <param name="part_id">intellisense will give a list of devices, ex. UCD9240, ...</param>
            <param name="address">PMBus address</param>
        </member>
        <member name="T:TIDP.Factory.Core.ConnectionPointEnum">
            <summary>
            Don't play with this enum input is assumed to be index 0 and
            rail 1 to be index 1.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.GPIBVisaInstrumentationDevice">
            <summary>
            
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.IInstrumentationDevice.Initialize_Device">
            <summary>
            initialize equipment for a particular type of calibration.  This function is different from a general initialize in which everything is prepared
            As you may or may not be using all of a set up... A backdoor basically.
            </summary>
            <param name="initialization_type"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IInstrumentationDevice.Test">
            <summary>
            GPIB SCPI type of test... not intended to ask the user to test anything as they can visually tell if everything is working.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IInstrumentationDevice.Shutdown">
            <summary>
            Shuts down all the equipment via instrumentation... not intended for manual as the user can manually shut everything down.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.#ctor">
            <summary>
            MFR GUI assembles everything and uses this constructor
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.GPIB_Parameters_Visibility(TIDP.Factory.Core.InstrumentationIdentificationEnum)">
            <summary>
            conditional parameter visibility static functions.  The function name is used although you can't find any references for it.
            Search for the string name.
            </summary>
            <param name="Instrument_Identification_Mode"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Resource_Parameters_Visibility(TIDP.Factory.Core.InstrumentationIdentificationEnum)">
            <summary>
            conditional parameter visibility static functions.  The function name is used although you can't find any references for it.
            Search for the string name.
            </summary>
            <param name="Instrument_Identification_Mode"></param>
            <returns></returns>
        </member>
        <member name="F:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Instrumented">
            <summary>
            something I may make public in order to aid a task not needing to specify if it is 
            instrumented or not.  I may decide against that.  So currently not used...
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Initialize_Device">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Initialize_Device(System.String)">
            <summary>
            Initialize Visa Device using resource name.
            If using GPIB use the other constructor specifying the gpib addresses.
            </summary>
            <param name="resource_name"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Initialize_Device(System.Int32,System.Byte,System.Byte)">
            <summary>
            Constructor to speak with a device over GPIB.
            </summary>
            <param name="board_address">usually zero - controller index</param>
            <param name="primary_address">primary gpib address</param>
            <param name="secondary_address">secondary gpib address</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Bus_Write(System.String)">
            <summary>
            If the device driver doesn't have the funciton you are looking for you can either
            add that function to the device driver or simply talk SCPI using this function.
            </summary>
            <param name="p"></param>
            <param name="p_2"></param>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Bus_VISA_Read_Status_Byte">
            <summary>
            Only devices initialized with a resource name, i.e via VISA protocol will return a valid value.
            If a gpib device calls this then exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Bus_Read_To_File(System.String,System.Boolean)">
            <summary>
            append to file only works for VISA not GPIB
            </summary>
            <param name="file_name"></param>
            <param name="append_to_file"></param>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Rail_Number">
            <summary>
            If value is 0 that means it is in the input... all other values indicate the rail.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Rail_Index">
            <summary>
            Rail_Number() - 1;
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Is_Connected_To_A_Rail">
            <summary>
            If true, can look at Rail().
            </summary>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Instrument_Identification_Mode">
            <summary>
            The way the device will be initialized: GPIB or VISA Resource Name
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Is_Measuring_Voltage">
            <summary>
            Will this instrument be used for measuring voltage?
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Is_Measuring_Current">
            <summary>
            Will this instrument be used for measuring current?
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Is_Measuring_Temperature">
            <summary>
            Will this instrument be used for measuring temperature?
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Connected_To">
            <summary>
            What will this instrument be connected to? 
            </summary>        
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Address_Board">
            <summary>
            Index of controller.  It is usually 0.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Address_Primary">
            <summary>
            Primary GPIB address of equipment.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.GPIBVisaInstrumentationDevice.Address_Secondary">
            <summary>
            Secondary GPIB address of equipment.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ICanMeasureVoltage.Measure_Voltage(System.Boolean)">
            <summary>
            uses a default message for measuring.
            </summary>
            <param name="instrumented"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ICanMeasureCurrent.Measure_Current(System.Boolean)">
            <summary>
            uses a default message.
            </summary>
            <param name="instrumented"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.IDCsource.Set_Power(System.Double,System.Double,System.Boolean)">
            <summary>
            uses default noninstrumentedmessage
            </summary>
            <param name="input_voltage_V"></param>
            <param name="input_current_A"></param>
            <param name="instrumented"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IDCsource.Turn_Output_On(System.Boolean,System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            
            </summary>
            <param name="turn_on">true to turn on, false to turn off.</param>
            <param name="instrumented"></param>
            <param name="message"></param>
        </member>
        <member name="M:TIDP.Factory.Core.IDCsource.Turn_Output_On(System.Boolean,System.Boolean)">
            <summary>
            uses the default message of turning input on and off in non-instrumented.
            </summary>
            <param name="turn_on"></param>
            <param name="instrumented"></param>
        </member>
        <member name="M:TIDP.Factory.Core.DCsource.Configure_Generic_Properties(TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.String)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using resource name.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.DCsource.Configure_Generic_Properties(TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.Int32,System.Byte,System.Byte)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using GPIB.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.DCsource.Measure_Voltage(System.Boolean)">
            <summary>
            provided default message.
            </summary>
            <param name="instrumented"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DCsource.Measure_Voltage">
            <summary>
            All drivers will implement this.  no drivers should override the instrumented versions, unless they don't support it and want
            the manual message to always show up.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DCsource.Measure_Current(System.Boolean)">
            <summary>
            provides default message.
            </summary>
            <param name="instrumented"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.DCsource.Connected_To">
            <summary>
            For a power supply, it is always connected to the Input.
            </summary>
            <remarks>
            The reason it doesn't show up, in the property grid, is because we manually remove the propertydescriptor in the FactoryTask class.
            We could add support to go based on attribute Browsable but to much work...
            </remarks>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryBaseUnit.ToHtml">
            <summary>
            function meant to be overrided.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryBaseUnit.Table_Header">
            <summary>
            so that I only have to define the table header in one place...
            </summary>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryBaseUnit.Retry">
            <summary>
            total number of times to retry this unit if it fails.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryBaseUnit.Enabled">
            <summary>
            
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTask.Is_Everything_The_Same_Besides_Parameter_Values(TIDP.Factory.Core.FactoryTask)">
            <summary>
            if anything other than a task is being compared then an exception will be thrown.
            If you pass null it will throw an exception.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTask.Value_Of_Parameter(System.String)">
            <summary>
            looks for the parameter if it finds it returns the value of that paramter.
            If doesn't find it then returns null.
            </summary>
            <param name="parameter_name"></param>
            <returns></returns>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryTask.Disimilarity.DisimilarityType">
            <summary>
            Parameter type would refer to input type and actual type. input type refers to if it is a file/folder/normal actual type/string/int/bool etc..
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.Instrumentation.EquipmentAttribute">
            <summary>
            For use with empty constructors.  Will throw an error at run time if this is not the case.
            Properties of the class will be shown in the script editor only.
            Properties can be decorated with the attributes for tasks just specify the index to be 0.  Doesn't matter.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.TaskAttribute.#ctor(TIDP.Factory.Core.TaskAttribute.TaskType,System.String,System.String)">
            <summary>
            Attribute to be used over a method.
            </summary>        
            <param name="task_type">Type of task</param>
            <param name="version">what is the version of this task.</param>
            <param name="reason_for_version">what is the reason for this new version.</param>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryInstrumentationItem">
            <summary>
            This object contains all the instrumented equipment.  Equipment items are only shown when
            this object is clicked.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted">
            <summary>
            There is a list in the Plugin class that each dll potentially adds to if they have renamed or deleted a task.  These are for tasks that are changed between different builds if it is for the same build no need to do this. 
            Purpose is that if soemone loads a script for an older build they will see where there tasks have been updated. 
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted.Reason_For_Change_Deletion_Or_Rename">
            <summary>
            will be shown in html browser.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted.#ctor(System.String,System.String,System.String,System.String)">
            <summary>
            When changing task A to task B (A->B).  Use this constructor for A. Use the other constructor to specify the Reason for B.
            The task A identifier will be used as the key in a dictionary so the message will be ignored to find equality.
            </summary>
            <param name="method_name"></param>
            <param name="name_space"></param>
            <param name="class_name"></param>
            <param name="assembly_name_without_extension"></param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            When task A changes to task B (A->B) use this constructor to describe B)and supply a reason.
            There is a list in the Plugin class that each dll potentially adds to if they have renamed or deleted a task.  
            These are for tasks that are changed between different builds if it is for the same build no need to do this. 
            Purpose is that if soemone loads a script for an older build they will see where there tasks have been updated. 
            Set parameters to null if they don't apply.  Which is the case if there isn't a replacement.
            </summary>
            <param name="method_name"></param>
            <param name="name_space"></param>
            <param name="class_name"></param>
            <param name="assembly_name_without_extension"></param>
            <param name="reason_for_change_deletion_or_rename">will be shown in an html browser so can use html syntax.</param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted.Equals(System.Object)">
            <summary>
            checks that all fields match however it doesn't check for the message so with/out message the object will return true if that is the only difference.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted.Equals(TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted)">
            <summary>
            checks that all fields match however it doesn't check for the message so with/out message the object will return true if that is the only difference.
            This one is for performance.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Activate_Load(System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            will select the channel or the scpi related to the load setting the current for that rail and turn it on.
            </summary>
            <param name="device_type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Activate_Load(System.Boolean)">
            <summary>
            Uses the default message if not instrumented to activate the load.
            </summary>
            <param name="instrumented"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Deactivate_Load(System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            will select the channel  related to the load setting the current for that rail and turn it off.
            </summary>
            <param name="rail"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Deactivate_Load(System.Boolean)">
            <summary>
            Uses the default message if not instrumented to deactivate the load.
            </summary>
            <param name="instrumented"></param>
            <param name="message"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Configure_Load(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            This assumes that you will be configuring the load for ConstantCurrent and configuring both static low and high.
            </summary>
            <param name="CCLow"></param>
            <param name="CCHigh"></param>
            <param name="rail"></param>
            <param name="rise_time"></param>
            <param name="fall_time"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Set_Load_Current(System.Boolean,System.Double,System.Boolean,TIDP.Factory.Core.NonInstrumentedMessage)">
            <summary>
            assumes that you have already configured the load for CCL,CCH,CCDL,CCDH (static or dynamic) via Configure_Device.
            In this function you specify the level there is always 1 or 2.
            </summary>
            <param name="high"></param>
            <param name="dynamic"></param>
            <param name="level"></param>
            <param name="current_value"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Set_Load_Current(System.Boolean,System.Double,System.Boolean)">
            <summary>
            The loads have two levels, 1 or 2, or A or B, if non-instrumented it will use the default message.
            </summary>
            <param name="level"></param>
            <param name="current_value"></param>
            <param name="instrumented"></param>
            <param name="message"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ILoad.Set_Load_Current_Mode(System.Boolean,System.Boolean)">
            <summary>
            Set "low" to true for CCL. Set "low" to false for CCH.
            Set "dynamic" to true for dynamic.  Set "dynamic" to false for static.
            (Examples: CCL would be (true,false)  CCDH would be (false,true))
            </summary>
            <param name="low"></param>
            <param name="dynamic"></param>
        </member>
        <member name="T:TIDP.Factory.Core.IMultiMeter">
            <summary>
            A multi channel multimeter would be a list of multimeters...
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.InstrumentCommunicator">
            <summary>
            wrapper over GPIB Device and VISA session so that we can use the same instrument communicator
            for devices hooked up to both.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.InstrumentCommunicator.GPIB_Session">
            <summary>
            Use this if the function you need is not available a backdoor
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.InstrumentCommunicator.MB_Session">
            <summary>
            Use this if the function you need is not available a backdoor
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.#ctor(System.Int32,System.Byte,System.Byte)">
            <summary>
            for GPIB devices identifiable via address information to create a GPIB device.
            </summary>
            <param name="address_board"></param>
            <param name="address_primary"></param>
            <param name="address_secondary"></param>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.#ctor(System.String)">
            <summary>
            Using a visa resource name creates a message based session.
            </summary>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.Reset">
            <summary>
            only works for GPIB.  Does nothing for resource named instruments.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.Write(System.String)">
            <summary>
            Writes string data to a device.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.Bus_VISA_Read_Status_Byte">
            <summary>
            Only devices initialized with a resource name, i.e via VISA protocol will return a valid value.
            If a gpib device calls this then exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.Bus_Read_To_File(System.String,System.Boolean)">
            <summary>
            append to file only works for VISA not GPIB
            </summary>
            <param name="file_name"></param>
            <param name="append_to_file"></param>
        </member>
        <member name="M:TIDP.Factory.Core.InstrumentCommunicator.Query(System.String)">
            <summary>
            For gpib the equivalent of a write followed by a read.
            For resource using the direct api for Query which I assume is the same as above.
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="F:TIDP.Factory.Core.FullMeasurer.Assigned">
            <summary>
            If this rail has been assigned then the exception will be thrown if someone tries to read one of the measurers and it is null.
            Otherwise no exception.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Load.Configure_Generic_Properties(System.Int32,TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.String)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using resource name.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Load.Configure_Generic_Properties(System.Int32,TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.Int32,System.Byte,System.Byte)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using GPIB.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="P:TIDP.Factory.Core.Load.Channel">
            <summary>
            Set channel for load in a multi channel. If N/A then set to 1
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.MultiMeter.Configure_Generic_Properties(TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.Boolean,System.String)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using resource name.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.MultiMeter.Configure_Generic_Properties(TIDP.Factory.Core.ConnectionPointEnum,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Byte,System.Byte)">
            <summary>
            For headless mode - configuring equpment to be used genericially.  Configured for scanning using GPIB.
            </summary>
            <param name="channel"></param>
            <param name="connected_to"></param>
            <param name="is_measuring_voltage"></param>
            <param name="is_measuring_current"></param>
            <param name="resource_name"></param>
        </member>
        <member name="M:TIDP.Factory.Core.MultiMeter.Measure_Voltage(System.Boolean)">
            <summary>
            default message
            </summary>
            <param name="instrumented"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.MultiMeter.Is_Measuring_Voltage">
            <summary>
            Will this instrument be used for measuring voltage?
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryDeviceScript">
            <summary>
            Factory script contains a list of device scripts. There is only one factory script, so 
            this object should normally have a size representing the number of devices, since 
            one set of steps per devicescript.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryDeviceScript.ToString">
            <summary>
            Displays for example UCD9240@12
            </summary>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryDeviceScript.Clone">
            <summary>
            just clones the object not the factorytaskgroups.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryLogger">
            <summary>
            Logging system for Manufacturing GUI system. Can write to log files 
            in HTML or Text format in real-time. Call Add_Logfile() to define a 
            new real-time output log file. Will also fire a Message event, allowing 
            other interested components can do something with the log message (UI logging, 
            additional logging, etc.
            </summary>
            <remarks>
            The log can be cleared at any time by calling Clear(). This fires the Cleared
            event, but does not affect log files. You can save the state of the log by
            calling Save(). This could be done in place or in addition to the real-time
            log files.
            </remarks>
        </member>
        <member name="F:TIDP.Factory.Core.FactoryLogger.Write_To_Console">
            <summary>
            If true, the output will automatically be routed to the console
            (stdout). Default is false.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryLogger.Add_Logfile(TIDP.Factory.Core.FactoryLogger.LogType,System.String,System.Boolean)">
            <summary>
            Defines a logfile to save to every time a new log messages is
            added. If auto_flush is true, every time a log message is added,
            the disk file will be flushed (synced) to disk automatically.
            This is not recommended, since it will slow down the factory
            system.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryLogger.Flush_Logfiles">
            <summary>
            Forces any log files created via Add_Logfile() to have their 
            contents flushed. No need to call if auto_flush was set when you
            added your logfiles.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryLogger.Close_Logfiles">
            <summary>
            Stops logging to all logfiles and closes them. You must call Add_Logfile() again
            to start logging to a new logfile.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryLogger.Clear">
            <summary>
            Clears the log.
            </summary>
        </member>
        <member name="E:TIDP.Factory.Core.FactoryLogger.Message">
            <summary>
            Fired for each message that is logged.
            </summary>
        </member>
        <member name="E:TIDP.Factory.Core.FactoryLogger.Cleared">
            <summary>
            Fired when the Clear() event is called. The internal log
            has been cleared when this event is fired.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryLogger.Logs">
            <summary>
            This is the list of log entries, or order that they were logged.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryLogger.LogItem">
            <summary>
            A log entry.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryLogger.LogItem.ToString">
            <summary>
            Returns a single line message. Any multi-line message will get folded into one line,
            with string "; " seperating each line.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryLogger.LogItem.Time_Only_String">
            <summary>
            Returns something like 23:10:09.123, where 123 is fractional seconds.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.FactoryLogger.LoggerSeverity.PASS">
            <summary>
            A task has PASSed. This is color coded green in UI logs.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.FactoryLogger.LoggerSeverity.SUCCESS">
            <summary>
            Any other log message you want colored green.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.DllUtility">
            Idea for this class is that we pass the dll/assembly and what attributes we are interested in
            and all the methods with that attribute will be returned.
            The other assumption is that we are using TaskAttribute, so only supporting TaskAttribute right now.
            
            Another nice thing is that there needs to be no relation between the attribute_task name and function name
            so the programmer doesn't need to keep the functions names the same however they need to keep the same
            attribute names if they want to use the same script.This only applies to the task names not the taskgroup names.
            
            This class can also run a function and return an object called RunStatus.  runs function based on attribute.
            RunStatus indicates:startTime,duration of execution,result(pass,fail),and a message that is configurable and used to indicate error messages.
            
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Convert_FactoryTask_To_Equipment(TIDP.Factory.Core.Instrumentation.EquipmentTask)">
            <summary>
            If it can't convert it will return null.  Should only be called by factory tasks that are known to be of equipment type, otherwise an exception will be thrown.
            factory_task.Is_Equipment.
            </summary>
            <param name="factory_task"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Load_Tasks_Changed_Deleted_Log(System.String,System.Boolean)">
            <summary>
            build up the plugin list of ranamed or deleted tasks. If clear tasks is set to true then will not add to previously there in the list.
            will only take unique keys.
            </summary>
            <param name="directory"></param>
            <param name="clear_tasks_changed_deleted_log_first"></param>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Run_Item(System.String,System.String,TIDP.Factory.Core.FactoryTask,TIDP.Factory.Core.FactoryDeviceScript)">
            <summary>
            At this point validation of task existence and values properly set is passed and ready to run.
            
            </summary>
            <param name="AssemblyPath">path where assembly is stored.</param>
            <param name="Class_Type">full name based on namespace not on assembly name. ex. namespace.csharpClassName</param>
            <param name="factoryTask">function call containing function name and arguments.</param>
            <returns>true if ran sucessfully, false if failed.</returns>
            //this function is run on the Backgroundworker.        
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Get_Parameter_Types(TIDP.Factory.Core.FactoryTask)">
            <summary>
            For a factory task that isn't equipment all the parameters come from the function.
            </summary>
            <param name="factoryTask"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Get_Parameter_Types(TIDP.Factory.Core.FactoryTask,TIDP.Factory.Core.Instrumentation.EquipmentAttribute.EquipmentType)">
            <summary>
            For factory tasks that are equipment their parameters are partially from properties of the equipment type they subclass.
            So this function weeds those out so you are left with the types that the subclass adds to it's constructor.
            </summary>
            <param name="factory_task"></param>
            <param name="equipment_type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getTypes(System.String)">
            <summary>
            
            </summary>
            <param name="pluginAssembly">the path to this assembly</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getItems(System.Type,System.Type)">
            <summary>
            this function will scan the customer class looking for our attribute.
            </summary>
            <param name="type"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getFactoryTaskItems(System.String,System.Boolean)">
            <summary>
            just specify assembly and get all the factoryTasks.
            </summary>
            <param name="pluginAssembly">specify the assembly path.</param>
            <param name="sort_by_task_type">sort in list by task type will collect all pmbus tasks together, all instrumentation tasks together etc... Refer to TaskAttribute.TaskType</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Dll_Contains_FactoryTask(TIDP.Factory.Core.FactoryTask)">
            <summary>
            appears that need to go through the entire list to see if one of the factory tasks compares correctly if not then it fails.
            NOTE: July 27, 2015 - this function will also tag the task if it is obsolete and a newver version is available.
            </summary>
            <param name="list"></param>
            <param name="ft1"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Validate_DLL(System.String)">
            <summary>
            throws exceptions... if no excpetions then it passes.
            </summary>
            <param name="library_dll"></param>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.isFactoryTaskEqual(TIDP.Factory.Core.FactoryTask,TIDP.Factory.Core.FactoryTask)">
            <summary>
            trys to see if the tasks are equal 
            by looking at the name of the funcion, class type and namespace
            as well as comparing each argument to see if the name is the same and the type of the argument is the same.
            </summary>
            <param name="ft1"></param>
            <param name="ft2"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getFactoryTaskItems(System.String,TIDP.Factory.Core.TaskAttribute.TaskType)">
            <summary>
            just specify assembly and get all the factoryTasks.
            </summary>
            <param name="pluginAssembly"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getFactoryTasksItems(System.String,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="pluginAssembly">actual path like: @"C:\snapshots\a0389316_viewHPATORONTO\dp_dotnet\Apps\Desktop\Apps\Factory GUI\Source\SampleDlls\bin\Debug\SampleDlls.dll"</param>
            <param name="pluginType">namespace.class in assembly like:SampleDlls.SampleDll1</param>
            <param name="attributeAssembly">since we are using our own attribute we don't need to loadFile for attribute assembly we can just use the assembly name directly."FactoryLibrary"</param>
            <param name="attribute">we are currently using our own attribute so we know this too right now. "TIDP.Factory.Core.TaskAttribute"</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getFactoryTasks(System.Type,System.Boolean)">
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Generate_Task_Documentation(System.Collections.Generic.List{TIDP.Factory.Core.FactoryTask},System.String)">
            <summary>
            Will overwrite existing document at location.  Will create the files in the folder location specified.
            
            </summary>
            <param name="task_list"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Clear_Assembly_Search_Cache">
            <summary>
            This should be called if a plug-in assembly is updated or installed.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Find_Assembly_Path_With_Type_Full_Search(System.String,System.String)">
            <summary>
            will look through the customer type folder to find this type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.getCustomTaskAttributes(TIDP.Factory.Core.FactoryTask)">
            <summary>
            if found you will not get a null.  If the task is not found it will return null.  we couldv'e thrown an exception...
            returns other attributes like the custometypes and fileparameter directoryparameter defaultvalue etc... these are not stored in the
            xml rather they are obtained from the libraries as they are being editied in the property grid.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.DllUtility.Get_Task_Argument_Attributes(TIDP.Factory.Core.FactoryTask,System.Int32)">
            <summary>
            if found you will not get a null.  If the task is not found it will return null.  we couldv'e thrown an exception...
            returns other attributes like the custometypes and fileparameter directoryparameter defaultvalue etc... these are not stored in the
            xml rather they are obtained from the libraries as they are being editied in the property grid.
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.DllUtility.ATTRIBUTE_ASSEMBLY">
            <summary>
            assumed the the taskattribute is stored in the executing assembly.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.DllUtility.AssemblyCache">
            <summary>
            Maps an assembly directory name to the assemblies it contains.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryScript.#ctor">
            <summary>
            specify version
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryScript.#ctor(System.String)">
            <summary>
            specify version when making the script.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryScript.Save(System.String)">
            <summary>
            Saves the script. Throws an exception on any error.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryScript.Clone">
            <summary>
            This clone is disgusting.  It doesn't clone any of the devices just the device itself without the nested devices...
            used by the script configurer tree grid and needs each node to just have the tag of its parallel object.
            Then it builds the whole tree by cloning each item for a bunch of reasons...
            </summary>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryScript.Retry">
            <summary>
            hide it, since we won't retry the whole script.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryScript.Stop_On_Fail">
            <summary>
            Stop the test if error occur.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryScript.Enabled">
            <summary>
            hide it, since we it is pointless to disable a script.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryScript.Devices_Info_List">
            <summary>
            List of devices in factoryDeviceScripts
            Only contains Part_ID and PMBus Address
            Used to validate if all PMBus devices are present in the system
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.FactoryScriptErrorException">
            <summary>
            Represents a general error in a script or task. You can throw this or any 
            exception within your task to indicate error and cause the task to exit
            immediately.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.FactoryTaskArgument.Input_Type">
            <summary>
            this is automatically figured out based on the attributes used.  This helps to do export and validation.
            refers to whetther it is a file/folder/normal...
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskArgumentList.Update_Argument_List_Documentation(TIDP.Factory.Core.FactoryTaskArgumentList)">
            <summary>
            this function assumes that the eveything about the old parameters and the new parameters are the same except documentation.
            </summary>
            <param name="param_new"></param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskArgumentList.Update_New_Parameters(TIDP.Factory.Core.FactoryTaskArgumentList)">
            <summary>
            idea is if there is more or less than we will add or take away.  Handling type differene.
            </summary>
            <param name="params_new"></param>
        </member>
        <member name="M:TIDP.Factory.Core.FactoryTaskPropertyDescriptor.#ctor(TIDP.Factory.Core.FactoryTask,System.String,System.Object)">
            <summary>
            property name must be accurate.
            </summary>
            <param name="factoryTask"></param>
            <param name="propertyName"></param>
            <param name="type"></param>
            <param name="value"></param>
        </member>
        <member name="T:TIDP.Factory.Core.TaskAttributes.FileDirectoryAttribute">
            <summary>
            This class is used now.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.TaskAttributes.FileDirectoryAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            This parameter will have a DirectoryDialog that will be used to set it's value.  Should be used when this directory will be an output.
            If need a directory as an input. Usage where for_output as false is currently not supported.
            </summary>
            <param name="parameterIndex">0 based parameter index to indicate which argument in the method this attribute will be applied too. 0 starting from the left. 1 would be the second argument from the left.</param>
            <param name="filter">filter for values, example "FactoryScript (*.xml)|*.xml"</param>
            <param name="title">title of the dialog</param>
            <param name="for_output">if set to true the export function will use it as an output if false then export will collect all the files in this folder and include it as a input folder</param>
        </member>
        <member name="P:TIDP.Factory.Core.TaskAttributes.FileDirectoryAttribute.Title">
            <summary>
            Title for the title of the box displayed to obtatin the information about where the directory is.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.TaskAttributes.FileParameterAttribute">
            <summary>
            This parameter will have a FileOpenDialog that will be used to set it's value.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.TaskAttributes.FileParameterAttribute.#ctor(System.String,System.String)">
            <summary>
            This parameter will have a FileOpenDialog that will be used to set it's value.
            </summary>
            <param name="parameterIndex">0 based parameter index to indicate which argument in the method this attribute will be applied too. 0 starting from the left. 1 would be the second argument from the left.</param>
            <param name="filter">filter for values, example "FactoryScript (*.xml)|*.xml"</param>
            <param name="title">title of the dialog</param>
        </member>
        <member name="P:TIDP.Factory.Core.TaskAttributes.FileParameterAttribute.Filter">
            <summary>
            if null then it indicates that the index was used.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Helper.Save2XML(System.String,System.Object,System.Type[])">
            <summary>
            Serialized to XML. Throws an exception on any error.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Helper.Obtain_Argument_Types(System.String)">
            <summary>
            obtains the types needed from the file so it can inform the deserializer about hte added types needed.
            </summary>
            <param name="factory_script_xml_file_path"></param>
            <returns></returns>
        </member>
        <member name="T:TIDP.Factory.Core.NewFactoryInstrumentation">
            <summary>
            
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.NewFactoryInstrumentation.Assigned">
            <summary>
            when assigned is true then any calls to any measurer/power setter etc.. that is null will throw an exception.
            it is thrown because it means a task is trying to do some instrumentation when that thing was not assigned.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.NewFactoryInstrumentation.Rail_Measurers">
            <summary>
            corresponds to the number of rails...
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Add(System.Object,TIDP.Factory.Core.Instrumentation.EquipmentTask)">
            <summary>
            Add the instrument to the NewFactoryInstrumentationList.  This is used by the MFR GUI.      
            </summary>
            <param name="equipment">instantiated equipment object</param>
            <param name="equipment_task"></param>
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Add(System.Object)">
            <summary>
            Add the instrument to the NewFactoryInstrumentationList.
            Use if calling from Headless mode.
            </summary>
            <param name="equipment"></param>
            <param name="equipment_task"></param>
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Wire_Up_And_Test_For_Overlap(TIDP.PMBus.PartID)">
            <summary>
            Throws an exception if overlapped. So caller should be using try/catch... if no exception then no problem.
            There may be issues that the user may have assigned the same GPIB address but we can't really konw how it is being used
            as a multiple channel multimeter in our sett up would require multiple of them at the same address, I think... or maybe
            the primaries are the same but the secondary addresses are different in which case we could catch that but I'm not sure
            we can add this later to the test.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Reset">
            <summary>
            When it sets up after the reset needs to know the device for the number of rails.
            int num_rails = Globals.Parts[device_part_id].Num_Outputs;
            </summary>
            <param name="device_part_id"></param>
            
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Initialize_Boards">
            <summary>
            I think we do this seperately because we don't want to have people need gpib boards to write scripts.  Need to test.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.NewFactoryInstrumentation.Initialize(System.Object[])">
            <summary>
            Most like this is called after the equipment list has been set up.
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.NewFactoryInstrumentation.Power_Setter">
            <summary>
            Only a power supply can set voltage/current.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.NonInstrumentedMessage.#ctor(System.String,System.String)">
            <summary>
            displays an ok and cancel button.
            </summary>
            <param name="message"></param>
            <param name="title"></param>
        </member>
        <member name="T:TIDP.Factory.Core.ConditionalParameterVisibilityAttribute">
            <summary>
            Conditionalizes a task/equipment parameter's visibility based upon the return type of the static bool function.
            The static bool function will be searched for and in the worst case will recurse up through the entire hiearcy of the task class and 
            throw an exception if not found.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin.Test_Cases_Failed">
            <summary>
            This is not currently used - Don't touch.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin.Serial_Number">
            <summary>
            Purpose of this field is to provide the serial number in the summary of the session information.  It will be set by the Serial_Number task.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin.Task_Cancel_Mode">
            <summary>
            If the task has an abort attribute and then this will be set to AbortImmediately otherwise WaitForTaskToComplete.
            When the user clicks cancel this value will be checked to see how to respond.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin.New_Factory_Instrumentation">
            <summary>
            This is set by the Manufacturing GUI automatically, This needs to be configured in headlessmode.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin._Logger">
            <summary>
            Add to this list the instrument you created... for example, a power supply, load etc...
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Add_To_Tasks_Renamed_Or_Deleted(TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted,TIDP.Factory.Core.FactoryTaskIdentifierRenamedOrDeleted)">
            <summary>
            return true if it was added successfully returns false otherwise.
            </summary>
            <param name="old_task">task being changed - do not provide a reason.</param>
            <param name="new_task">new task, if there isn't a new task put null,  Need to use the constructor with a reason.</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Message(System.String,System.String,System.String,TIDP.Factory.Core.PluginTypes.MessageBoxType,TIDP.Factory.Core.PluginTypes.MessageBoxIconType)">
            <summary>
            This overload allows for a picture to be present after the prompt.
            </summary>
            <param name="title"></param>
            <param name="prompt"></param>
            <param name="image_location"></param>
            <param name="buttons"></param>
            <param name="icon"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Recreate_Device_If_Necessary">
            <summary>
            Must call after any activity which could download a new configuration and change
            the # rails or phases on a rail or change the actual part number. For example, 
            project file write or data flash download. Recreates the PMBusDevice object only if
            the PHASE_INFO setting for a UCD92xx device has changed. See Recreate_Device()
            for function to always recreate.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Recreate_Device">
            <summary>
            Not a clone. Creates a new device based on the current device's address,
            PartID, and optionally current DEVICE_ID as read from hardware (ignored for
            controllers that do not support DEVICE_ID). Re-reads all PMBus commands.
            Essentially the same result as if you called Discover() again and it nuked
            all existing PMBusDevice objects. DOES NOT UPDATE PMBusDevice.Devices static
            list.
            </summary>       
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log(System.String)">
            <summary>
            general log for customer
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log(System.Exception)">
            <summary>
            Adds an exception to the factory log. Adds stack trace, which includes each exception message
            in the trace.
            </summary>
            <param name="ex"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.LogError(System.String)">
            <summary>
            used by customer reporting error
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log_Error(System.String,System.String)">
            <summary>
            used by customer reporting error
            </summary>
            <param name="log"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log(System.String,TIDP.Factory.Core.FactoryLogger.LoggerSeverity,TIDP.Factory.Core.FactoryLogger.LoggerType,System.String)">
            <summary>
            added later so user can add their own category.
            </summary>
            <param name="log"></param>
            <param name="serverity"></param>
            <param name="lType"></param>
            <param name="extra"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log(System.String,System.String)">
            <summary>
            added later so user can add their own category.  This will log as an general.
            </summary>
            <param name="log"></param>
            <param name="serverity"></param>
            <param name="lType"></param>
            <param name="extra"></param>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log2(System.String,System.Object[])">
            <summary>
            Uses StringUtils.Format() to replace {} tokens in format, similar
            to printf. For example, Log2("write 0x{:X2} to {}", data, cmd_id).
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log2(TIDP.Factory.Core.FactoryLogger.LoggerSeverity,System.String,System.Object[])">
            <summary>
            Uses StringUtils.Format() to replace {} tokens in format, similar
            to printf. For example, Log2("write 0x{:X2} to {}", data, cmd_id).
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Log2(TIDP.Factory.Core.FactoryLogger.LoggerSeverity,TIDP.Factory.Core.FactoryLogger.LoggerType,System.String,System.Object[])">
            <summary>
            Uses StringUtils.Format() to replace {} tokens in format, similar
            to printf. For example, Log2("write 0x{:X2} to {}", data, cmd_id).
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.Plugin.Session_Directory">
            <summary>
            Something like C:\Program Files\Texas Instruments Fusion Digital Power Manufacturing Tool\
            data\Logs\Session_2009_06_15D_18h32m. This a unique directory created each time the
            MFR GUI is opened.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Get_String(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Used by factory task to request a string.  if the length is null then no length will be forced on the user.
            </summary>
            <param name="prompt"></param>
            <param name="title"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Verify_Device_Supports_Commands(TIDP.PMBus.CommandID[])">
            <summary>
            Throws an exception if any one of the specified commands is not supported
            on Plugin.Device. Exception will be something along the lines 
            "Task not supported on TPSXXXX @ Address 46 because the following commands 
            are used by the task but not supported on this device: READ_VOUT, STATUS_VOUT".
            This avoids confusing "object reference not found" errors when a task is run
            but a command object is not available.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Timestamp_For_Filename">
            <summary>
            Returns a string like "2010.02.24_18.04.38.135". This is YYYY.MM.DD_HH.MM.SS.TTT
            format, where TTT is in milliseconds.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Compare_Command_String_Value(TIDP.PMBus.CommandID,System.String)">
            <summary>
            Task will read the specified command from the device. The task will PASS if the ASCII encoded version of the value read matches the string input. 
            In addition to failing if different, the task will also FAIL if you specify a command that does not represent a string. 
            Examples of supported commands include MFR_MODEL, MFR_REVISION, and MFR_ID.
            </summary>
            <param name="cmd_id"></param>
            <param name="expected_value"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Validate_Device_In_Script(TIDP.PMBus.SAAPrefs,TIDP.PMBus.PartID,System.Int32,System.Boolean,System.Int32)">
            <summary>
            This is the direct call for the Factory GUI headless and is also part of the calls from the script runner.
            </summary>
            <param name="SAA_prefs"></param>
            <param name="part_id"></param>
            <param name="device_address"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Validate_Device_In_Script(TIDP.Factory.Core.FactoryScript,TIDP.Factory.Core.FactoryDeviceScript)">
            <summary>
            This function casues the PMBus api to update its list of devices based on what is present on the SAA.
            Since this is the case it should clear the device that is currently cached so that it can be updated
            when being re-read.  The caller should take care of this.
            </summary>
            <param name="fact_script"></param>
            <param name="factory_device"></param>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.Plugin.User_Cancelled">
            <summary>
            Indicates if the User clicked cancel.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.Plugin.Is_Logging_PMBus">
            <summary>
            get/set logging PMBus ReadParameter/Write Parameter/Operation/Warning and Paused.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.Plugin.Device">
            <summary>
            This can only be set if in Headless mode! meaning headless_mode=true.  If in head_less mode you need to set the device otherwise when a read device is called it will throw an exception that it wasn't set.
            If scriptrunner is executing a script you shouldn't set the device as this is done by the script runner.
            I guess you can potentially set the mode to true set your device and put it back to false.  However on a subsequent call it will look at the factoryscriptdevice and set it back as it will be different.  This is checked when not in headless mode.
            </summary>
            <returns></returns>
        </member>
        <member name="P:TIDP.Factory.Core.Plugin.Logger">
            <summary>
            The factory logger. This object is created for you and is never
            recreated. Logfiles can be defined through the class, the log
            appended to, log files closed, and the log cache cleared.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.Plugin.Instruments">
            <summary>
            Use this if you've implemented an entire driver.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Math.Average(System.Boolean,System.Double[])">
            <summary>
            return double average of array passed in.  Also, It doesn't alter the array passed in.
            </summary>
            <param name="array"></param>
            <param name="drop_high_low">if true will drop the highest value and lowest and then average the remaining values</param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Math.Max(System.Double[])">
            <summary>
            returns max double value.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.Plugin.Math.Min(System.Double[])">
            <summary>
            returns max double value.
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="T:TIDP.Factory.Core.Plugin.ComparisonResult">
            <summary>
            Simple class to hold the result of Compare_Command_String_Value.  Basically an Equalled property and a message summary.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.PluginConsumerEvents.TaskGroupEventArgs.#ctor(System.String,TIDP.Factory.Core.PluginConsumerEvents.EventType,System.Int32,System.Int32,System.Int32,System.TimeSpan)">
            <summary>
            
            </summary>
            <param name="tName"></param>
            <param name="tt"></param>
            <param name="numberOfUnits">refers to number of tasks within this group. Word units is used
            because this class in inherited by DeviceScriptEventArgs</param>
        </member>
        <member name="T:TIDP.Factory.Core.PropertyGridManipulator">
            <summary>
            Great helper class to move the splitter to fit the whole property name.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.PropertyGridManipulator.Move_Splitter_To_Longest_Display_Name(System.Windows.Forms.PropertyGrid,System.Int32)">
             <summary>
             Moves the property Grid's splitter bar over to fit the width ofthe longest display name string + padding
            
             </summary>
             <param name="propertyGrid">The property Grid whose splitter baris to be moved</param>
             <param name="iPadding">Right padding to include with longestdisplay name width</param>
        </member>
        <member name="M:TIDP.Factory.Core.PropertyHandler.SetProperties(TIDP.Factory.Core.FactoryTask,System.Reflection.PropertyInfo[],System.Object)">
            <summary>
            Usually the FactoryTask has more parameters, due to the custom add-on properties, than the object(equipment) you are copying too so 
            we scan the to_object and search for them in the factorytask.  If they don't exist it could be because they have been
            overriden in the equipment to have browsable set to false...  In this case the default value for the equipment will be used.
            Not the default set in the derived equipment class.
            </summary>
            <param name="factory_task"></param>
            <param name="to_fields"></param>
            <param name="to_object"></param>
        </member>
        <member name="M:TIDP.Factory.Core.PropertyHandler.SetProperties(System.Reflection.PropertyInfo[],System.Reflection.PropertyInfo[],System.Object,System.Object)">
            <summary>        
            </summary>
            <param name="fromFields"></param>
            <param name="toFields"></param>
            <param name="fromRecord"></param>
            <param name="toRecord"></param>
        </member>
        <member name="T:TIDP.Factory.Core.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:TIDP.Factory.Core.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.RunStatus">
            <summary>
            first call start, pause and resume if needed, and end.
            may not need to use start,pause and resume may just want to add times to the duration directly.
            sort of our error keeper.
            </summary>
        </member>
        <member name="T:TIDP.Factory.Core.ScriptInfo">
            <summary>
            this class provides an object that will load a script by fileName and return a FactoryScript.
            this class may be needed or can be incorporated into FactoryScript. The idea here is that perhaps we
            can provide a class that can be used to quickly get information about a script, perhaps it may be useful
            if we have a number of scripts and are looking for one based on device detection etc... something for the future.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.LoadScript(System.String,System.Boolean)">
            <summary>
            Loads the factory script from a file name.
            If the script contains disabled items they will be removed from the script depending on
            the "remove_disabled_tasks" argument.
            </summary>
            <param name="fileName"></param>
            <param name="remove_disabled_tasks"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Create_Script_From_System_File(System.String)">
            <summary>
            Load the system file (.tifsp) and create a download config script
            </summary>
            <param name="system_file"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Validate_Full_Script(System.String,System.String)">
            <summary>
            Use this function when users open a script file, edit the script, but do not want to save changes to the script
            Just wan to run the script to experiment the changes. We allow them to set the current working folder so that 
            we can validate the input files relatively to the working folder. The filename (script file), however have to be full path
            
            </summary>
            <param name="fileName"></param>
            <param name="current_directory"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Validate_Factory_Task_Item(TIDP.Factory.Core.FactoryDeviceScript,TIDP.Factory.Core.FactoryTaskGroup,TIDP.Factory.Core.FactoryTask,System.Boolean)">
            <summary>
            even if it is ignored we still want to indicate to them that certain tasks don't work.
            </summary>
            <param name="ft"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Validate_Script_No_Instrumentation(TIDP.Factory.Core.FactoryScript,System.Boolean)">
            <summary>
            Will validate only existence/and input validation.
            throws an exceptoin if it fails.
            </summary>
            <param name="fs"></param>
            <param name="ignore_disabled_items"></param>
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Validate_Instrumentation(TIDP.Factory.Core.FactoryScript)">
            <summary>
            We catch one error per device and report all findings at the end in one dialog. 
            We don't find more than one error in a device as there is no point in looking for more errors as they are not independent like tasks.        
            If there is one error it needs to be corrected and then we continue.
            If there is no exception then it passed.
            </summary>
            <remarks>
            1. obtain instrumentation node.
            2. take each device
            3. wire up to cover a part of nfi
            4. if the same part is being covered should be an error
            --------------------------
            At this point we identify overlap errors. Anotber type of error is not having enough equipment to cover instrumentation needs.
            So if each task that requires instrumentation, indicates which part of the api needs to be covered then we can see what needs to be done.
            might be nice to make an enum with each API function. </remarks>        /// 
            <returns></returns>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptInfo.Ensure_All_Arguments_Have_Values(TIDP.Factory.Core.FactoryTask)">
            <summary>
            Throws exception if a parameter hasn't been specified or specifies a file location that is incorrect.
            </summary>
            <param name="ft"></param>
        </member>
        <member name="T:TIDP.Factory.Core.ScriptRunner">
            <summary>
            ScriptRunner should be able to run any task device or non device oriented.  So it shouldn't be dependent on a device
            It runs the tasks with a backgroundworker.  So UI clients can rest assured that they won't starve the GUI.
            UI clients have a number of events that they can listen too and display in their own way.
            such events include: taskStarted.  The nice thing about a backgroundworker is that when they report
            progress they report on a UI thread which can be used for controls.  
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.ScriptRunner._Only_Run_When_All_Devices_In_Script_Are_Present">
            <summary>
            Only run when all devices in the script are present on the bus
            For system file script (from .tifsp), this is always true. For other, default is false unless users change it in the user preferences
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.ScriptRunner._Display_Summary_Popup_Message_When_Completed">
            <summary>
            Per Cisco request, display popup summary when script finishes for both pass/fail
            For system file script (from .tifsp), this is always true. For other, default is false unless users change it in the user preferences
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.#ctor(TIDP.Factory.Core.FactoryBackgroundWorker)">
            <summary>
            constructor initalized by FactoryGuiState
            </summary>
            <param name="bg"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Init">
            <summary>
            Sets up the status messages...
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.setFactoryScript(TIDP.Factory.Core.FactoryScript)">
            <summary>
            Although the runner is setup, the actual setting of which script the runner executes is here.
            This is set in the RunForm click button method.
            </summary>
            <param name="fs"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Run_Script">
            <summary>
            This is called by RunForm to execute the loaded script in the runner.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Report_Progress_And_Log(System.Object)">
            <summary>
            Pre-cursor to the Report_Progress(..) call.
            </summary>
            <param name="userState"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Report_Progress(System.Object,System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
            all the events are abusing this reportProgress function.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Run_Script_Worker(System.Object,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            Background worker calls this in the async execution.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.ScriptRunner.Run_Task(System.String,TIDP.Factory.Core.FactoryTask,System.ComponentModel.DoWorkEventArgs)">
            <summary>
            runs the task by calling DllUtility.runItem(assPath,typeOfClass full string name.,factoryTask)
            </summary>
            <param name="ft"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="F:TIDP.Factory.Core.ScriptRunner.Failed">
            <summary>
            this is called when user wants to cancel manufacturing.
            if cancel is true it means that the stopRunning was due to a cancellation
            if the cancel argument is false then it means stopRunning was due to a failure.
            </summary>
        </member>
        <member name="F:TIDP.Factory.Core.TaskDeletedAttribute.Reason_For_Deletion">
            <summary>
            will be shown in html browser.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.TaskDeletedAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            When a task is deleted specify it's full details and the reason why.  Use this if there isn't a replacement.
            If there is a replacement use TaskRenamedFrom attribute over the new task.
            This task is an assembly attribute and can be placed in the AssemblyInfo.cs as follows
            [assembly: TaskDeletedAttribute(...,...,...,...)]
            </summary>
            <param name="method_name"></param>
            <param name="name_space"></param>
            <param name="class_name"></param>
            <param name="assembly_name_without_extension"></param>
            <param name="reason_for_change_deletion_or_rename">will be shown in an html browser so can use html syntax.</param>
        </member>
        <member name="F:TIDP.Factory.Core.TaskRenamedFromAttribute.Reason_For_Change_Rename">
            <summary>
            will be shown in html browser.
            </summary>
        </member>
        <member name="M:TIDP.Factory.Core.TaskRenamedFromAttribute.#ctor(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            When task A changes to task B (A->B) use this constructor to describe B)and supply a reason.
            There is a list in the Plugin class that each dll potentially adds to if they have renamed or deleted a task.  
            These are for tasks that are changed between different builds if it is for the same build no need to do this. 
            Purpose is that if soemone loads a script for an older build they will see where there tasks have been updated. 
            Set parameters to null if they don't apply.  Which is the case if there isn't a replacement.
            </summary>
            <param name="method_name"></param>
            <param name="name_space"></param>
            <param name="class_name"></param>
            <param name="assembly_name_without_extension"></param>
            <param name="reason_for_change_deletion_or_rename">will be shown in an html browser so can use html syntax.</param>
        </member>
        <member name="M:TIDP.Factory.Core.TaskRenamedFromAttribute.#ctor(System.String,System.String)">
            <summary>
            This is the lazy man form that assumes the namespace,class name, assembly name without extension are all the same.  Be cautious when renaming a class name etc... that you update this attribute to the more informative form.
            </summary>
            <param name="method_name"></param>
            <param name="reason_for_change_deletion_or_rename"></param>
        </member>
    </members>
</doc>
